"""
Generated by Gemini AI 2.5 Pro, modified by Gemini AI 2.5 Flash
"""


class KuhnMatchingAlgorithm:
    """
    Implements Kuhn's Algorithm to find maximum matchings in bipartite graphs.

    This class provides methods to find both a single maximum matching and to enumerate
    all maximum matchings.

    :param graph: The bipartite graph represented as an adjacency list.
                  Keys are vertices from the left set, and values are lists of
                  adjacent vertices from the right set.
                  Example: ``{ 'L1': ['R1', 'R2'], 'L2': ['R2'] }``
    :type graph: dict
    """

    def __init__(self, graph):
        self.graph = graph  # Adjacency list: {left_vertex: [right_vertex1, ...]}
        self.left_to_right = {}  # Stores the current matching: {left_vertex: right_vertex}
        self.right_to_left = {}  # Stores the reverse matching: {right_vertex: left_vertex}
        self.visited = set()  # Used for DFS to avoid cycles
        self.all_max_matchings = []  # Stores all found maximum matchings
        self.max_matching_size = 0  # Size of a maximum matching

    def find_max_matching(self):
        """
        Finds one maximum matching using the standard Kuhn's algorithm (DFS-based).

        This method initializes a matching and iteratively tries to augment it by
        finding augmenting paths. The `max_matching_size` attribute will be set
        after this method is called.

        :returns: A dictionary representing one maximum matching, where keys are
                  left vertices and values are their matched right vertices.
        :rtype: dict
        """
        # Initialize matchings: no vertex is matched initially
        self.left_to_right = {v: None for v in self.graph}
        self.right_to_left = {}

        # Iterate through each left vertex to try and find an augmenting path
        for vertex in self.graph:
            self.visited = set()  # Reset visited set for each DFS call
            self._dfs(vertex)

        # Calculate the size of the found maximum matching
        self.max_matching_size = sum(1 for u in self.left_to_right.values() if u is not None)

        # Return only the actual matched pairs
        return {k: v for k, v in self.left_to_right.items() if v is not None}

    def _dfs(self, v):
        """
        Performs a Depth-First Search to find an augmenting path.

        This is a helper method for `find_max_matching`.

        :param v: The current left vertex to start DFS from.
        :type v: hashable
        :returns: True if an augmenting path starting from `v` was found and
                  the matching was successfully augmented, False otherwise.
        :rtype: bool
        """
        if v in self.visited:
            return False  # Already visited in this DFS path
        self.visited.add(v)

        for u in self.graph[v]:  # Iterate through neighbors of v in the right set
            # If u is unmatched OR if u is matched and its partner can find another match
            if u not in self.right_to_left or self._dfs(self.right_to_left[u]):
                self.left_to_right[v] = u  # Match v with u
                self.right_to_left[u] = v  # Match u with v
                return True  # Augmenting path found
        return False  # No augmenting path found from v

    def find_all_max_matchings(self):
        """
        Finds all maximum matchings of the graph.

        This method first determines the size of a maximum matching using
        :py:meth:`find_max_matching`, then uses a backtracking approach to
        enumerate all matchings of that specific size. Note that finding
        all maximum matchings can be computationally intensive for large graphs.

        :returns: A list of dictionaries, where each dictionary represents a unique
                  maximum matching (left_vertex: right_vertex pairs).
        :rtype: list[dict]
        """
        # First, find the size of a maximum matching
        # This also initializes self.max_matching_size
        self.find_max_matching()

        # Get all left-side vertices to iterate through
        left_vertices = list(self.graph.keys())

        # Initialize variables for the backtracking process
        current_matching = {v: None for v in left_vertices}  # Represents a potential matching being built
        used_right = set()  # Keeps track of right vertices already used in current_matching
        self.all_max_matchings = []  # Reset the list for this call

        # Start the recursive backtracking process from the first left vertex
        self._backtrack(left_vertices, 0, current_matching, used_right, 0)

        # Filter out incomplete matchings (if any) and ensure uniqueness
        # The backtracking logic should primarily generate full max matchings,
        # but this step provides robustness against potential duplicates
        # arising from different exploration orders.
        unique_matchings = []
        seen_matchings = set()
        for matching in self.all_max_matchings:
            # Convert dictionary to a frozenset of (key, value) tuples for hashability
            # Only include actual matched pairs (where value is not None)
            match_tuple = frozenset(item for item in matching.items() if item[1] is not None)
            if match_tuple not in seen_matchings:
                seen_matchings.add(match_tuple)
                unique_matchings.append({k: v for k, v in matching.items() if v is not None})

        return unique_matchings

    def _backtrack(self, left_vertices, index, current_matching, used_right, current_size):
        """
        Recursive backtracking function to enumerate all maximum matchings.

        This is a private helper method for :py:meth:`find_all_max_matchings`.

        :param left_vertices: A list of all left-side vertices in the graph.
        :type left_vertices: list
        :param index: The current index in the `left_vertices` list, indicating
                      which left vertex is currently being considered.
        :type index: int
        :param current_matching: The dictionary representing the matching being
                                 built in the current recursive path.
        :type current_matching: dict
        :param used_right: A set of right vertices that are already matched in
                           the `current_matching` for the current path.
        :type used_right: set
        :param current_size: The current number of matched edges in the
                             `current_matching`.
        :type current_size: int
        """
        # Base Case 1: A maximum matching of the required size is found
        # If the current matching size equals the pre-determined maximum size,
        # it's a valid maximum matching, so we add a copy to the results.
        if current_size == self.max_matching_size:
            self.all_max_matchings.append(current_matching.copy())
            return

        # Base Case 2: All left vertices have been processed
        # If we've considered all left vertices but haven't reached the
        # maximum matching size, this path does not lead to a max matching.
        if index >= len(left_vertices):
            return

        v = left_vertices[index]  # The current left vertex to consider for matching

        # Option 1: Do NOT include the current vertex 'v' in the matching
        # We recursively move to the next left vertex without attempting to match 'v'.
        self._backtrack(left_vertices, index + 1, current_matching, used_right, current_size)

        # Option 2: Try to include the current vertex 'v' in the matching
        # Iterate through all neighbors of 'v' in the right set.
        for u in self.graph[v]:
            # Check if the right vertex 'u' is not yet matched in the current path
            if u not in used_right:
                # Make the match: assign 'v' to 'u' and mark 'u' as used
                current_matching[v] = u
                used_right.add(u)

                # Recursively call for the next left vertex with the updated matching.
                # Increment the current_size as a new match has been made.
                self._backtrack(left_vertices, index + 1, current_matching, used_right, current_size + 1)

                # Backtrack: Undo the match for 'v' and 'u'.
                # This is crucial to explore other possibilities for 'v'
                # or for subsequent left vertices if 'u' is needed elsewhere.
                current_matching[v] = None
                used_right.remove(u)
