"""
Tests for StringTemplate predicate.

This module tests the StringTemplate predicate which provides pattern matching
for common string formats like IP addresses and UUIDs.

Generated by Claude Sonnet 4 (Anthropic)
"""

import uuid

from core.predicates import AvailableTemplate, ResultContext, StringTemplate


class TestStringTemplate:
    """Test cases for StringTemplate predicate."""

    def test_ip_v4_template(self):
        """Test IPv4 template matching."""
        template = StringTemplate(template=AvailableTemplate.IP_V4, var='ip')

        # Valid IPv4 addresses
        valid_ips = [
            '192.168.1.1',
            '10.0.0.1',
            '127.0.0.1',
            '255.255.255.255',
            '0.0.0.0',
        ]

        for ip in valid_ips:
            result_ctx = ResultContext()
            assert template.is_matched(ip, result_ctx=result_ctx), f"Should match IPv4: {ip}"
            assert result_ctx.get_user_var_value('ip') == ip

        # Invalid IPv4 addresses
        invalid_ips = [
            '256.1.1.1',  # Out of range
            '192.168.1',  # Missing octet
            '192.168.1.1.1',  # Extra octet
            'not.an.ip.address',  # Non-numeric
            '192.168.01.1',  # Leading zeros (depends on regex)
        ]

        for ip in invalid_ips:
            assert not template.is_matched(ip), f"Should not match invalid IPv4: {ip}"

    def test_ip_v6_template(self):
        """Test IPv6 template matching."""
        template = StringTemplate(template=AvailableTemplate.IP_V6, var='ipv6')

        # Valid IPv6 addresses
        valid_ips = [
            '2001:0db8:85a3:0000:0000:8a2e:0370:7334',
            '2001:db8:85a3::8a2e:370:7334',
            '::1',
            '::',
            'fe80::1',
            '2001:db8::1',
        ]

        for ip in valid_ips:
            result_ctx = ResultContext()
            assert template.is_matched(ip, result_ctx=result_ctx), f"Should match IPv6: {ip}"
            assert result_ctx.get_user_var_value('ipv6') == ip

    def test_uuid_template(self):
        """Test generic UUID template matching."""
        template = StringTemplate(template=AvailableTemplate.UUID, var='uuid')

        # Generate test UUIDs
        test_uuids = [
            str(uuid.uuid1()),
            str(uuid.uuid4()),
            str(uuid.uuid1()).replace('-', ''),  # Without dashes
            str(uuid.uuid4()).replace('-', ''),  # Without dashes
        ]

        for test_uuid in test_uuids:
            result_ctx = ResultContext()
            assert template.is_matched(test_uuid, result_ctx=result_ctx), f"Should match UUID: {test_uuid}"
            assert result_ctx.get_user_var_value('uuid') == test_uuid

    def test_uuid_v1_template(self):
        """Test UUID v1 template matching."""
        template = StringTemplate(template=AvailableTemplate.UUID_V1, var='uuid_v1')

        # Generate UUID v1
        uuid_v1 = str(uuid.uuid1())
        uuid_v1_no_dash = uuid_v1.replace('-', '')

        result_ctx = ResultContext()
        assert template.is_matched(uuid_v1, result_ctx=result_ctx)
        assert result_ctx.get_user_var_value('uuid_v1') == uuid_v1

        result_ctx = ResultContext()
        assert template.is_matched(uuid_v1_no_dash, result_ctx=result_ctx)
        assert result_ctx.get_user_var_value('uuid_v1') == uuid_v1_no_dash

    def test_uuid_v4_template(self):
        """Test UUID v4 template matching."""
        template = StringTemplate(template=AvailableTemplate.UUID_V4, var='uuid_v4')

        # Generate UUID v4
        uuid_v4 = str(uuid.uuid4())
        uuid_v4_no_dash = uuid_v4.replace('-', '')

        result_ctx = ResultContext()
        assert template.is_matched(uuid_v4, result_ctx=result_ctx)
        assert result_ctx.get_user_var_value('uuid_v4') == uuid_v4

        result_ctx = ResultContext()
        assert template.is_matched(uuid_v4_no_dash, result_ctx=result_ctx)
        assert result_ctx.get_user_var_value('uuid_v4') == uuid_v4_no_dash

    def test_all_uuid_versions(self):
        """Test all UUID version templates."""
        uuid_templates = [
            (AvailableTemplate.UUID_V1, '12345678-1234-1234-8234-123456789012'),
            (AvailableTemplate.UUID_V2, '12345678-1234-2234-8234-123456789012'),
            (AvailableTemplate.UUID_V3, '12345678-1234-3234-8234-123456789012'),
            (AvailableTemplate.UUID_V4, '12345678-1234-4234-8234-123456789012'),
            (AvailableTemplate.UUID_V5, '12345678-1234-5234-8234-123456789012'),
            (AvailableTemplate.UUID_V6, '12345678-1234-6234-8234-123456789012'),
            (AvailableTemplate.UUID_V7, '12345678-1234-7234-8234-123456789012'),
            (AvailableTemplate.UUID_V8, '12345678-1234-8234-8234-123456789012'),
        ]

        for template_type, test_uuid in uuid_templates:
            template = StringTemplate(template=template_type, var='test_uuid')
            result_ctx = ResultContext()
            assert template.is_matched(test_uuid, result_ctx=result_ctx), (
                f"Should match {template_type.value}: {test_uuid}"
            )
            assert result_ctx.get_user_var_value('test_uuid') == test_uuid

    def test_compiled_value_property(self):
        """Test that compiled_value returns correct StringPattern."""
        template = StringTemplate(template=AvailableTemplate.UUID_V4, var='test')
        compiled = template.compiled_value

        # Should return a StringPattern
        from core.predicates.scalars.string_predicates import StringPattern

        assert isinstance(compiled, StringPattern)
        assert compiled.var == 'test'
        assert '4[0-9a-fA-F]{3}' in compiled.pattern  # UUID v4 specific pattern

    def test_invalid_template(self):
        """Test behavior with invalid template."""
        # This would require modifying the enum or using a mock
        # For now, test that all enum values work
        for template_type in AvailableTemplate:
            template = StringTemplate(template=template_type, var='test')
            compiled = template.compiled_value
            assert compiled is not None

    def test_template_without_var(self):
        """Test template without variable assignment."""
        template = StringTemplate(template=AvailableTemplate.IP_V4)

        result_ctx = ResultContext()
        # When var is None, verify returns None, so we test the compiled pattern directly
        assert template.compiled_value.verify('192.168.1.1')
        # No variable should be set - check that context is empty
        assert len(result_ctx._user_variables) == 0

    def test_template_inheritance(self):
        """Test that StringTemplate properly inherits from BaseCompoundPredicate."""
        template = StringTemplate(template=AvailableTemplate.UUID_V4, var='test')

        # Should have correct type_of
        assert template.type_of == '$-mockau-str-template'

        # Should have template property
        assert template.template == AvailableTemplate.UUID_V4

        # Should have var property
        assert template.var == 'test'

    def test_template_serialization(self):
        """Test template serialization/deserialization."""
        template = StringTemplate(template=AvailableTemplate.UUID_V4, var='test')

        # Test model_dump
        data = template.model_dump()
        assert data['type_of'] == '$-mockau-str-template'
        # Enum is serialized as enum object, not string
        assert data['template'] == AvailableTemplate.UUID_V4
        assert data['var'] == 'test'

        # Test reconstruction
        new_template = StringTemplate.model_validate(data)
        assert new_template.template == AvailableTemplate.UUID_V4
        assert new_template.var == 'test'

    def test_edge_cases(self):
        """Test edge cases and boundary conditions."""
        template = StringTemplate(template=AvailableTemplate.UUID_V4, var='test')

        # Empty string
        result_ctx = ResultContext()
        assert not template.is_matched('', result_ctx=result_ctx)

        # Very long string
        long_string = 'a' * 1000
        result_ctx = ResultContext()
        assert not template.is_matched(long_string, result_ctx=result_ctx)

        # Special characters
        special_string = '!@#$%^&*()'
        result_ctx = ResultContext()
        assert not template.is_matched(special_string, result_ctx=result_ctx)

    def test_case_sensitivity(self):
        """Test case sensitivity in templates."""
        template = StringTemplate(template=AvailableTemplate.UUID_V4, var='test')

        # Test with different cases
        test_cases = [
            '12345678-1234-4234-8234-123456789012',  # lowercase
            '12345678-1234-4234-8234-123456789ABC',  # mixed case
            '12345678-1234-4234-8234-123456789abc',  # lowercase
        ]

        for test_case in test_cases:
            result_ctx = ResultContext()
            assert template.is_matched(test_case, result_ctx=result_ctx), f"Should match case: {test_case}"
            assert result_ctx.get_user_var_value('test') == test_case

    def test_template_with_complex_patterns(self):
        """Test templates with complex regex patterns."""
        # Test IPv6 with various formats
        ipv6_template = StringTemplate(template=AvailableTemplate.IP_V6, var='ipv6')

        complex_ipv6_cases = [
            '2001:0db8:85a3:0000:0000:8a2e:0370:7334',  # Full format
            '2001:db8:85a3::8a2e:370:7334',  # Compressed
            '::1',  # Loopback
            '::',  # All zeros
            'fe80::1%lo0',  # With zone ID (may not match depending on regex)
        ]

        for ipv6 in complex_ipv6_cases[:4]:  # Skip zone ID case
            result_ctx = ResultContext()
            if ipv6_template.is_matched(ipv6, result_ctx=result_ctx):
                assert result_ctx.get_user_var_value('ipv6') == ipv6

    def test_template_error_handling(self):
        """Test error handling in templates."""
        template = StringTemplate(template=AvailableTemplate.UUID_V4, var='test')

        # Test with None input
        result_ctx = ResultContext()
        try:
            result = template.is_matched(None, result_ctx=result_ctx)
            # Should handle gracefully
            assert result is False or result is None
        except (TypeError, AttributeError):
            # Also acceptable to raise an error
            pass

    def test_template_performance(self):
        """Test template performance with multiple matches."""
        template = StringTemplate(template=AvailableTemplate.UUID_V4, var='test')

        # Generate multiple UUIDs
        test_uuids = [str(uuid.uuid4()) for _ in range(10)]

        for test_uuid in test_uuids:
            result_ctx = ResultContext()
            assert template.is_matched(test_uuid, result_ctx=result_ctx)
            assert result_ctx.get_user_var_value('test') == test_uuid

    def test_template_regex_compilation(self):
        """Test that templates compile to valid regex patterns."""
        for template_type in AvailableTemplate:
            template = StringTemplate(template=template_type, var='test')
            compiled = template.compiled_value

            # Should be a StringPattern
            from core.predicates.scalars.string_predicates import StringPattern

            assert isinstance(compiled, StringPattern)

            # Pattern should not be empty
            assert compiled.pattern
            assert len(compiled.pattern) > 0

            # Should have correct variable
            assert compiled.var == 'test'
