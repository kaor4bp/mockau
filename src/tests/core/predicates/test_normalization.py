"""
This module contains comprehensive normalization tests for predicates.
It leverages the `is_equal_to` method, which implicitly normalizes
predicates before comparison, to ensure that logically equivalent
predicates become structurally identical after normalization.

.. Generated by Athena (Gemini 2.5 Flash).
"""

import pytest

from core.predicates import (
    AndPredicate,
    AnyPredicate,
    IntegerEqualTo,
    IntegerGreaterOrEqualThan,
    IntegerGreaterThan,
    IntegerLessOrEqualThan,
    IntegerLessThan,
    IntegerNotEqualTo,
    IsNull,
    NotPredicate,
    OptionalPredicate,
    OrPredicate,
    StringContains,
    StringNotContains,
    StringNotPattern,
    StringPattern,
    VoidPredicate,
)
from utils.formatters import get_params_argv


class TestNormalization:
    """
    Test suite for predicate normalization, focusing on `is_equal_to` method.
    The `is_equal_to` method implicitly normalizes predicates before comparison.
    """

    # Test cases where predicates are logically equivalent but structurally different
    EQUIVALENT_PREDICATE_PAIRS = {
        # 1. Logical Predicates - Associativity (Flattening)
        'Or predicate flattening': [
            OrPredicate(
                predicates=[
                    OrPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=2)]),
                    IntegerEqualTo(value=3),
                ]
            ),
            OrPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=2), IntegerEqualTo(value=3)]),
        ],
        'And predicate flattening': [
            AndPredicate(
                predicates=[
                    AndPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=2)]),
                    IntegerEqualTo(value=3),
                ]
            ),
            AndPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=2), IntegerEqualTo(value=3)]),
        ],
        # 2. Logical Predicates - Commutativity (Order Independence)
        'Or predicate commutativity': [
            OrPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=2)]),
            OrPredicate(predicates=[IntegerEqualTo(value=2), IntegerEqualTo(value=1)]),
        ],
        'And predicate commutativity': [
            AndPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=2)]),
            AndPredicate(predicates=[IntegerEqualTo(value=2), IntegerEqualTo(value=1)]),
        ],
        # 3. Logical Predicates - Idempotence (Redundancy)
        'Or predicate idempotence': [
            OrPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=1)]),
            IntegerEqualTo(value=1),
        ],
        'And predicate idempotence': [
            AndPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=1)]),
            IntegerEqualTo(value=1),
        ],
        'Or with duplicates and order change': [
            OrPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=2), IntegerEqualTo(value=1)]),
            OrPredicate(predicates=[IntegerEqualTo(value=2), IntegerEqualTo(value=1)]),
        ],
        'And with duplicates and order change': [
            AndPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=2), IntegerEqualTo(value=1)]),
            AndPredicate(predicates=[IntegerEqualTo(value=2), IntegerEqualTo(value=1)]),
        ],
        # 4. De Morgan's Laws and Double Negation
        'De Morgan: NOT(A OR B) to (NOT A AND NOT B)': [
            NotPredicate(predicate=OrPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=2)])),
            AndPredicate(
                predicates=[
                    NotPredicate(predicate=IntegerEqualTo(value=1)),
                    NotPredicate(predicate=IntegerEqualTo(value=2)),
                ]
            ),
        ],
        'De Morgan: NOT(A AND B) to (NOT A OR NOT B)': [
            NotPredicate(predicate=AndPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=2)])),
            OrPredicate(
                predicates=[
                    NotPredicate(predicate=IntegerEqualTo(value=1)),
                    NotPredicate(predicate=IntegerEqualTo(value=2)),
                ]
            ),
        ],
        'Double Negation: NOT(NOT A) to A': [
            NotPredicate(predicate=NotPredicate(predicate=IntegerEqualTo(value=5))),
            IntegerEqualTo(value=5),
        ],
        # 5. Scalar Predicate Normalization
        'IntegerNotEqualTo to OR of GT and LT': [
            IntegerNotEqualTo(value=10),
            OrPredicate(predicates=[IntegerLessThan(value=10), IntegerGreaterThan(value=10)]),
        ],
        'IntegerLessOrEqualThan to OR of LT and EQ': [
            IntegerLessOrEqualThan(value=10),
            OrPredicate(predicates=[IntegerLessThan(value=10), IntegerEqualTo(value=10)]),
        ],
        'IntegerGreaterOrEqualThan to OR of GT and EQ': [
            IntegerGreaterOrEqualThan(value=10),
            OrPredicate(predicates=[IntegerGreaterThan(value=10), IntegerEqualTo(value=10)]),
        ],
        'StringContains to StringPattern': [
            StringContains(value='test'),
            StringPattern(pattern='.*test.*'),
        ],
        # 'StringContains with ignore_case to StringPattern with ignore_case': [
        #     StringContains(value='Test', ignore_case=True),
        #     StringPattern(pattern='.*test.*', ignore_case=True), # assuming StringPattern normalizes value to lower if ignore_case is True
        # ],
        # 'StringEqualTo with ignore_case different casing': [
        #     StringEqualTo(value='HELLO', ignore_case=True),
        #     StringEqualTo(value='hello', ignore_case=True),
        # ],
        'StringNotContains to StringNotPattern': [
            StringNotContains(value='xyz'),
            StringNotPattern(pattern='.*xyz.*'),
        ],
        # 6. Predicates with AnyPredicate and VoidPredicate (Constants)
        'AND with VoidPredicate': [
            AndPredicate(predicates=[IntegerEqualTo(value=1), VoidPredicate()]),
            VoidPredicate(),
        ],
        'OR with AnyPredicate': [
            OrPredicate(predicates=[IntegerEqualTo(value=1), AnyPredicate()]),
            AnyPredicate(),
        ],
        'NOT VoidPredicate to AnyPredicate': [
            NotPredicate(predicate=VoidPredicate()),
            AnyPredicate(),
        ],
        'NOT AnyPredicate to VoidPredicate': [
            NotPredicate(predicate=AnyPredicate()),
            VoidPredicate(),
        ],
        # 7. OptionalPredicate normalization
        'OptionalPredicate to OR with IsNull': [
            OptionalPredicate(predicate=IntegerEqualTo(value=5)),
            OrPredicate(predicates=[IsNull(), IntegerEqualTo(value=5)]),
        ],
        # 8. Array and Object Predicates - Order and Nested Normalization
        # 'ArrayEqualTo with ignore_order and different internal order': [
        #     ArrayEqualTo(value=[IntegerEqualTo(value=1), IntegerEqualTo(value=2)], ignore_order=True),
        #     ArrayEqualTo(value=[IntegerEqualTo(value=2), IntegerEqualTo(value=1)], ignore_order=True),
        # ],
        # 'ArrayContains with nested normalized predicates': [
        #     ArrayContains(value=[StringContains(value='abc')]),
        #     ArrayContains(value=[StringPattern(pattern='.*abc.*')]),
        # ],
        # 'ObjectEqualTo with different key order': [
        #     ObjectEqualTo(value={'b': IntegerEqualTo(value=2), 'a': IntegerEqualTo(value=1)}),
        #     ObjectEqualTo(value={'a': IntegerEqualTo(value=1), 'b': IntegerEqualTo(value=2)}),
        # ],
        # 'ObjectContainsSubset with nested normalized predicates': [
        #     ObjectContainsSubset(value={'key': StringContains(value='data')}),
        #     ObjectContainsSubset(value={'key': StringPattern(pattern='.*data.*')}),
        # ],
        # 'Nested logical in ObjectEqualTo': [
        #     ObjectEqualTo(value={'key': AndPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=2)])}),
        #     ObjectEqualTo(value={'key': AndPredicate(predicates=[IntegerEqualTo(value=2), IntegerEqualTo(value=1)])}),
        # ],
        # 'Complex nested structure with flattening': [
        #     OrPredicate(predicates=[
        #         AndPredicate(predicates=[IntegerEqualTo(value=1), OrPredicate(predicates=[IntegerEqualTo(value=2), IntegerEqualTo(value=3)])]),
        #         StringContains(value='abc')
        #     ]),
        #     OrPredicate(predicates=[
        #         AndPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=2)]),
        #         AndPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=3)]),
        #         StringPattern(pattern='.*abc.*')
        #     ]),
        # ],
    }

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENT_PREDICATE_PAIRS))
    def test_normalization_equivalence(self, p1, p2):
        """
        Tests that logically equivalent predicates normalize to the same form
        and are considered equal by `is_equal_to`.
        """
        assert p1.is_equal_to(p2), f"Expected {p1} to be equal to {p2} after normalization"

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENT_PREDICATE_PAIRS))
    def test_is_equivalent_to(self, p1, p2):
        assert p1.is_equivalent_to(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENT_PREDICATE_PAIRS))
    def test_is_equivalent_to_with_normalized_version(self, p1, p2):
        """
        Tests that logically equivalent predicates normalize to the same form
        and are considered equal by `is_equal_to`.
        """
        p_normalized = p1.normalize_to_canonical_form()
        assert p1.is_equivalent_to(p_normalized)
        assert p2.is_equivalent_to(p_normalized)
