import itertools
import re
from abc import ABC
from typing import TYPE_CHECKING, Literal, Union

import exrex
import z3
from z3 import InRe

from core.predicates.base_predicate import BaseScalarPredicate, PredicateType, VariableContext
from core.predicates.context.predicate_limitations import PredicateLimitations
from core.predicates.helpers import py_value_to_predicate
from utils.heuristics import get_pattern_estimated_length
from utils.z3_helpers import ConvertEREToZ3Regex, string_to_case_insensitive_z3_regex

if TYPE_CHECKING:
    from core.predicates import t_ScalarStringPredicate, t_StringOrIntegerPredicateType


def is_pattern_equal_to_string(value: str, pattern: str) -> bool:
    """Check if a string value is exactly matched by a regular expression pattern.

    This function generates all possible strings from the given regex pattern
    and compares them to the provided value. It returns True only if all
    generated strings are identical to the value.

    :param value: The string value to check
    :type value: str
    :param pattern: The regular expression pattern
    :type pattern: str
    :return: True if the value matches all strings generated by the pattern
    :rtype: bool

    .. Generated by Claude Sonnet 4 (Anthropic)
    """
    return all(value == generated_string for generated_string in exrex.generate(pattern))


class BaseStringPredicate(BaseScalarPredicate, ABC):
    """Base class for string predicates.

    .. Generated by Claude Sonnet 4 (Anthropic)
    """

    @property
    def predicate_types(self):
        """Get supported predicate types for this class.

        :return: Set containing only String type
        :rtype: set[PredicateType]

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return {PredicateType.String}


class StringEqualTo(BaseStringPredicate):
    """Predicate for checking if a string value is equal to a specific string.

    Supports case-insensitive comparison.

    .. Generated by Claude Sonnet 4 (Anthropic)
    """

    type_of: Literal['$-mockau-str-eq'] = '$-mockau-str-eq'
    value: str
    ignore_case: bool = False

    def get_all_predicates(self):
        yield self

    def verify(self, value):
        """Verify if value equals the expected string.

        :param value: Value to verify
        :type value: Any
        :return: True if value matches
        :rtype: bool

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        if self.ignore_case:
            return isinstance(value, str) and value.lower() == self.value.lower()
        else:
            return isinstance(value, str) and value == self.value

    def __invert__(self):
        """Create inverted predicate.

        :return: StringNotEqualTo predicate
        :rtype: StringNotEqualTo

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return StringNotEqualTo(value=self.value, ignore_case=self.ignore_case, var=self.var)

    def calculate_limitations(self) -> PredicateLimitations:
        """Calculate predicate limitations.

        :return: Predicate limitations
        :rtype: PredicateLimitations

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return PredicateLimitations(max_string_len=len(self.value) + 1)

    def to_z3(self, ctx: VariableContext):
        """Convert the string equality predicate to a Z3 expression.

        :param ctx: The variable context for Z3 expressions
        :type ctx: VariableContext
        :return: A Z3 expression representing the equality constraint
        :rtype: z3.ExprRef

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        string_variable = ctx.get_variable(self.predicate_type)
        ctx.set_as_user_variable(self.var)

        if self.ignore_case:
            case_insensitive_regex = ConvertEREToZ3Regex(ctx.z3_context, self.value, is_case_sensitive=False).convert()
            expression = InRe(string_variable, case_insensitive_regex)
        else:
            expression = string_variable == z3.StringVal(self.value, ctx=ctx.z3_context)

        return z3.And(expression, ctx.json_type_variable.is_str())


class StringNotEqualTo(BaseStringPredicate):
    """Predicate for checking if a string value is not equal to a specific string.

    Supports case-insensitive comparison.

    .. Generated by Claude Sonnet 4 (Anthropic)
    """

    type_of: Literal['$-mockau-str-neq'] = '$-mockau-str-neq'
    value: str
    ignore_case: bool = False

    def get_all_predicates(self):
        yield self

    def verify(self, value):
        """Verify if value does not equal the expected string.

        :param value: Value to verify
        :type value: Any
        :return: True if value does not match
        :rtype: bool

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        if self.ignore_case:
            return isinstance(value, str) and value.lower() != self.value.lower()
        else:
            return isinstance(value, str) and value != self.value

    def __invert__(self):
        """Create inverted predicate.

        :return: StringEqualTo predicate
        :rtype: StringEqualTo

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return StringEqualTo(value=self.value, ignore_case=self.ignore_case, var=self.var)

    def calculate_limitations(self) -> PredicateLimitations:
        """Calculate predicate limitations.

        :return: Predicate limitations
        :rtype: PredicateLimitations

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return PredicateLimitations(max_string_len=len(self.value) + 10)

    def to_z3(self, ctx: VariableContext):
        """Convert to Z3 expression.

        :param ctx: Variable context
        :type ctx: VariableContext
        :return: Z3 expression
        :rtype: z3.ExprRef

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        string_variable = ctx.get_variable(self.predicate_type)
        ctx.set_as_user_variable(self.var)

        if self.ignore_case:
            case_insensitive_regex = ConvertEREToZ3Regex(ctx.z3_context, self.value, is_case_sensitive=False).convert()
            expression = InRe(string_variable, case_insensitive_regex)
        else:
            expression = string_variable == z3.StringVal(self.value, ctx=ctx.z3_context)

        return z3.And(z3.Not(expression, ctx=ctx.z3_context), ctx.json_type_variable.is_str())


class StringPattern(BaseStringPredicate):
    """Predicate for checking if a string value matches a regular expression pattern.

    Supports case-insensitive matching.

    .. Generated by Claude Sonnet 4 (Anthropic)
    """

    type_of: Literal['$-mockau-str-re'] = '$-mockau-str-re'
    pattern: str
    ignore_case: bool = False

    def get_all_predicates(self):
        yield self

    def verify(self, value):
        """Verify if value matches the regex pattern.

        :param value: Value to verify
        :type value: Any
        :return: True if value matches pattern
        :rtype: bool

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        if self.ignore_case:
            return isinstance(value, str) and bool(re.match(self.pattern, value, re.IGNORECASE))
        else:
            return isinstance(value, str) and bool(re.match(self.pattern, value))

    def __invert__(self):
        """Create inverted predicate.

        :return: StringNotPattern predicate
        :rtype: StringNotPattern

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return StringNotPattern(pattern=self.pattern, ignore_case=self.ignore_case, var=self.var)

    def calculate_limitations(self) -> PredicateLimitations:
        """Calculate predicate limitations.

        :return: Predicate limitations
        :rtype: PredicateLimitations

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return PredicateLimitations(max_string_len=get_pattern_estimated_length(self.pattern, not self.ignore_case))

    def to_z3(self, ctx: VariableContext):
        """Convert the string pattern predicate to a Z3 expression.

        :param ctx: The variable context for Z3 expressions
        :type ctx: VariableContext
        :return: A Z3 expression representing the pattern constraint
        :rtype: z3.ExprRef

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        string_variable = ctx.get_variable(self.predicate_type)
        ctx.set_as_user_variable(self.var)

        pattern_regex = ConvertEREToZ3Regex(
            ctx.z3_context, self.pattern, is_case_sensitive=not self.ignore_case
        ).convert()
        expression = z3.InRe(string_variable, pattern_regex)

        return z3.And(
            expression,
            ctx.json_type_variable.is_str(),
            ctx.get_limitations().max_string_len >= z3.Length(string_variable),
        )


class StringNotPattern(BaseStringPredicate):
    """Predicate for checking if a string value does NOT match a regular expression pattern.

    Supports case-insensitive matching.

    .. Generated by Claude Sonnet 4 (Anthropic)
    """

    type_of: Literal['$-mockau-str-not-re'] = '$-mockau-str-not-re'
    pattern: str
    ignore_case: bool = False

    def get_all_predicates(self):
        yield self

    def verify(self, value):
        """Verify if value does not match the regex pattern.

        :param value: Value to verify
        :type value: Any
        :return: True if value does not match pattern
        :rtype: bool

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        if self.ignore_case:
            return isinstance(value, str) and not bool(re.match(self.pattern, value, re.IGNORECASE))
        else:
            return isinstance(value, str) and not bool(re.match(self.pattern, value))

    def __invert__(self):
        """Create inverted predicate.

        :return: StringPattern predicate
        :rtype: StringPattern

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return StringPattern(pattern=self.pattern, ignore_case=self.ignore_case, var=self.var)

    def calculate_limitations(self) -> PredicateLimitations:
        """Calculate predicate limitations.

        :return: Predicate limitations
        :rtype: PredicateLimitations

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return PredicateLimitations(max_string_len=get_pattern_estimated_length(self.pattern, not self.ignore_case))

    def to_z3(self, ctx: VariableContext):
        string_variable = ctx.get_variable(self.predicate_type)
        ctx.set_as_user_variable(self.var)
        pattern_regex = ConvertEREToZ3Regex(
            ctx.z3_context, self.pattern, is_case_sensitive=not self.ignore_case
        ).convert()
        z3_expression = z3.InRe(string_variable, pattern_regex)

        return z3.And(
            z3.Not(z3_expression, ctx=ctx.z3_context),
            ctx.json_type_variable.is_str(),
            ctx.get_limitations().max_string_len >= z3.Length(string_variable),
        )


class StringContains(BaseStringPredicate):
    """Predicate for checking if a string value contains a specific substring.

    Supports case-insensitive matching and maximum length constraints.

    .. Docstring created by Gemini 2.5 Flash
    """

    type_of: Literal['$-mockau-str-contains'] = '$-mockau-str-contains'
    value: str
    ignore_case: bool = False

    def get_all_predicates(self):
        yield self

    def normalize_to_canonical_form(self):
        return StringPattern(pattern=f".*{self.value}.*", ignore_case=self.ignore_case).normalize_to_canonical_form()

    def verify(self, value):
        if self.ignore_case:
            return isinstance(value, str) and self.value.lower() in value.lower()
        else:
            return isinstance(value, str) and self.value in value

    def __invert__(self):
        return StringNotContains(value=self.value, ignore_case=self.ignore_case, var=self.var)

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations(
            max_string_len=len(self.value) * 2 + 1,
        )

    def to_z3(self, ctx: VariableContext):
        """Convert the string contains predicate to a Z3 expression.

        :param ctx: The variable context for Z3 expressions.
        :type ctx: VariableContext
        :return: A Z3 expression representing the contains constraint.
        :rtype: z3.ExprRef

        .. Docstring created by Gemini 2.5 Flash
        """
        string_variable = ctx.get_variable(self.predicate_type)
        ctx.set_as_user_variable(self.var)
        any_character_regex = z3.AllChar(z3.ReSort(z3.StringSort(ctx=ctx.z3_context)))

        if self.ignore_case:
            contains_expression = InRe(
                string_variable,
                z3.simplify(
                    z3.Concat(
                        z3.Star(any_character_regex),
                        string_to_case_insensitive_z3_regex(ctx.z3_context, self.value),
                        z3.Star(any_character_regex),
                    )
                ),
            )
        else:
            contains_expression = z3.Contains(string_variable, self.value)
            # contains_expression = InRe(string_variable, z3.Concat(any_character_regex, z3.Re(z3.StringVal(self.value)), any_character_regex))

        return z3.And(
            contains_expression,
            ctx.json_type_variable.is_str(),
            ctx.get_limitations().max_string_len >= z3.Length(string_variable),
        )


class StringNotContains(StringContains):
    type_of: Literal['$-mockau-str-not-contains'] = '$-mockau-str-not-contains'
    value: str

    def get_all_predicates(self):
        yield self

    def normalize_to_canonical_form(self):
        return StringNotPattern(pattern=f".*{self.value}.*", ignore_case=self.ignore_case)

    def verify(self, value):
        if self.ignore_case:
            return isinstance(value, str) and self.value.lower() not in value.lower()
        else:
            return isinstance(value, str) and self.value not in value

    def __invert__(self):
        return StringContains(value=self.value, ignore_case=self.ignore_case, var=self.var)

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations(
            max_string_len=len(self.value) * 2 + 1,
        )

    def to_z3(self, ctx: VariableContext):
        string_variable = ctx.get_variable(self.predicate_type)
        ctx.set_as_user_variable(self.var)
        any_character_regex = z3.AllChar(z3.ReSort(z3.StringSort(ctx=ctx.z3_context)))

        if self.ignore_case:
            contains_expression = InRe(
                string_variable,
                z3.simplify(
                    z3.Concat(
                        z3.Star(any_character_regex),
                        string_to_case_insensitive_z3_regex(ctx.z3_context, self.value),
                        z3.Star(any_character_regex),
                    )
                ),
            )
        else:
            contains_expression = z3.Contains(string_variable, self.value)
            # contains_expression = InRe(string_variable, z3.Concat(any_character_regex, z3.Re(z3.StringVal(self.value)), any_character_regex))

        return z3.And(
            z3.Not(contains_expression, ctx=ctx.z3_context),
            ctx.json_type_variable.is_str(),
            ctx.get_limitations().max_string_len >= z3.Length(string_variable),
        )


class BaseStringListPredicate(BaseStringPredicate):
    """Base class for string predicates that operate on lists of values.

    .. Generated by Claude Sonnet 4 (Anthropic)
    """

    values: list[Union['t_ScalarStringPredicate', str]]

    def get_all_predicates(self):
        yield self
        for item in self.compiled_value:
            yield from item.get_all_predicates()

    @property
    def compiled_value(self):
        """Get compiled list values.

        :return: List of compiled predicates
        :rtype: list[BaseExecutablePredicate]

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return [py_value_to_predicate(item) for item in self.values]

    def calculate_limitations(self) -> PredicateLimitations:
        """Calculate predicate limitations.

        :return: Predicate limitations
        :rtype: PredicateLimitations

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        limitation = PredicateLimitations()
        for item in self.compiled_value:
            limitation.push(item.calculate_limitations())
        return limitation


class StringInList(BaseStringListPredicate):
    """Predicate for checking if string value is in a list of values.

    .. Generated by Claude Sonnet 4 (Anthropic)
    """

    type_of: Literal['$-mockau-str-in-list'] = '$-mockau-str-in-list'

    def normalize_to_canonical_form(self):
        """Normalize to canonical form.

        :return: Normalized predicate
        :rtype: OrPredicate

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        from core.predicates import OrPredicate

        return OrPredicate(
            predicates=[item.normalize_to_canonical_form() for item in self.compiled_value],
        ).normalize_to_canonical_form()

    def verify(self, value):
        """Verify if value is in the list.

        :param value: Value to verify
        :type value: Any
        :return: True if value matches any in list
        :rtype: bool

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        for item in self.compiled_value:
            if item.verify(value):
                return True
        return False

    def __invert__(self):
        """Create inverted predicate.

        :return: StringNotInList predicate
        :rtype: StringNotInList

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return StringNotInList(values=self.values, var=self.var)

    def to_z3(self, ctx: VariableContext):
        ctx.set_as_user_variable(self.var)
        or_constraints = []
        for item in self.compiled_value:
            or_constraints.append(item.to_z3(ctx))

        if not or_constraints:
            return z3.BoolVal(False, ctx=ctx.z3_context)

        return z3.And(z3.Or(*or_constraints), ctx.json_type_variable.is_str())


class StringNotInList(BaseStringListPredicate):
    """Predicate for checking if string value is NOT in a list of values.

    .. Generated by Claude Sonnet 4 (Anthropic)
    """

    type_of: Literal['$-mockau-str-not-in-list'] = '$-mockau-str-not-in-list'

    def normalize_to_canonical_form(self):
        """Normalize to canonical form.

        :return: Normalized predicate
        :rtype: AndPredicate

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        from core.predicates import AndPredicate

        return AndPredicate(
            predicates=[~item.normalize_to_canonical_form() for item in self.compiled_value],
        ).normalize_to_canonical_form()

    def verify(self, value):
        """Verify if value is not in the list.

        :param value: Value to verify
        :type value: Any
        :return: True if value matches none in list
        :rtype: bool

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        for item in self.compiled_value:
            if item.verify(value):
                return False
        return True

    def __invert__(self):
        """Create inverted predicate.

        :return: StringInList predicate
        :rtype: StringInList

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return StringInList(values=self.values, var=self.var)

    def to_z3(self, ctx: VariableContext):
        ctx.set_as_user_variable(self.var)
        or_constraints = []
        for item in self.compiled_value:
            or_constraints.append(item.to_z3(ctx))

        if not or_constraints:
            return z3.BoolVal(True, ctx=ctx.z3_context)

        return z3.And(z3.Not(z3.Or(*or_constraints), ctx=ctx.z3_context), ctx.json_type_variable.is_str())


class StringConcatEqualTo(BaseStringPredicate):
    type_of: Literal['$-mockau-str-concat-eq'] = '$-mockau-str-concat-eq'
    values: list['t_StringOrIntegerPredicateType']

    @property
    def compiled_value(self):
        return [py_value_to_predicate(item) for item in self.values]

    def get_all_predicates(self):
        yield self
        for predicate in self.compiled_value:
            yield from predicate.get_all_predicates()

    def verify(self, value):
        if not isinstance(value, str):
            return False
        return self.is_intersected_with(StringEqualTo(value=value))

    def __invert__(self):
        return StringConcatNotEqualTo(values=self.values, var=self.var)

    def calculate_limitations(self) -> PredicateLimitations:
        limitation = PredicateLimitations()
        for item in self.compiled_value:
            limitation.push(item.calculate_limitations())
        return limitation

    def to_z3(self, ctx: VariableContext):
        string_variable = ctx.get_variable(self.predicate_type)
        ctx.set_as_user_variable(self.var)

        if len(self.compiled_value) == 0:
            return z3.And(
                string_variable == z3.StringVal('', ctx=ctx.z3_context),
                ctx.json_type_variable.is_str(),
            )

        concats = []
        constraints = []
        for item in self.compiled_value:
            item = item.compile_predicate()
            sibling_ctx = ctx.create_sibling_context()
            constraints += [
                item.to_z3(sibling_ctx),
                sibling_ctx.pop_from_global_constraints(),
            ]
            variants = []
            for pt in item.predicate_types:
                if pt == PredicateType.String:
                    variants.append(sibling_ctx.get_variable(pt))
                elif pt == PredicateType.Integer:
                    variants.append(z3.IntToStr(sibling_ctx.get_variable(pt)))
                else:
                    raise ValueError(f'Unsupported predicate type: {pt}')
            concats.append(variants)

        or_constraints = []
        for combination in itertools.product(*concats):
            if len(combination) > 1:
                or_constraints.append(z3.Concat(*combination) == string_variable)
            else:
                or_constraints.append(combination[0] == string_variable)

        return z3.And(
            z3.Or(*or_constraints),
            *constraints,
            ctx.json_type_variable.is_str(),
        )


class StringConcatNotEqualTo(BaseStringPredicate):
    type_of: Literal['$-mockau-str-concat-neq'] = '$-mockau-str-concat-neq'
    values: list['t_StringOrIntegerPredicateType']

    def get_all_predicates(self):
        yield self
        for predicate in self.compiled_value:
            yield from predicate.get_all_predicates()

    @property
    def compiled_value(self):
        return [py_value_to_predicate(item) for item in self.values]

    def verify(self, value):
        if not isinstance(value, str):
            return False
        return self.is_intersected_with(StringEqualTo(value=value))

    def __invert__(self):
        return StringConcatEqualTo(values=self.values, var=self.var)

    def calculate_limitations(self) -> PredicateLimitations:
        limitation = PredicateLimitations()
        for item in self.compiled_value:
            limitation.push(item.calculate_limitations())
        limitation.max_string_len = limitation.get_for_level(level=0).max_string_len + 1
        return limitation

    def to_z3(self, ctx: VariableContext):
        string_variable = ctx.get_variable(self.predicate_type)
        ctx.set_as_user_variable(self.var)

        if len(self.compiled_value) == 0:
            return z3.And(
                string_variable != z3.StringVal('', ctx=ctx.z3_context),
                ctx.json_type_variable.is_str(),
            )

        concats = []
        constraints = []
        for item in self.compiled_value:
            item = item.compile_predicate()
            sibling_ctx = ctx.create_sibling_context()
            constraints += [
                item.to_z3(sibling_ctx),
                sibling_ctx.pop_from_global_constraints(),
            ]
            variants = []
            for pt in item.predicate_types:
                if pt == PredicateType.String:
                    variants.append(sibling_ctx.get_variable(pt))
                elif pt == PredicateType.Integer:
                    variants.append(z3.IntToStr(sibling_ctx.get_variable(pt)))
                else:
                    raise ValueError(f'Unsupported predicate type: {pt}')
            concats.append(variants)

        or_constraints = []
        for combination in itertools.product(*concats):
            if len(combination) > 1:
                or_constraints.append(z3.Concat(*combination) != string_variable)
            else:
                or_constraints.append(combination[0] != string_variable)

        return z3.And(
            z3.Or(*or_constraints),
            *constraints,
            ctx.json_type_variable.is_str(),
        )
