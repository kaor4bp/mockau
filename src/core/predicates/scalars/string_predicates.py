import itertools
import re
from typing import TYPE_CHECKING, Literal, Union

import exrex
import z3
from z3 import InRe

from core.predicates.base_predicate import BaseScalarPredicate, PredicateType, VariableContext
from core.predicates.context.predicate_limitations import PredicateLimitations
from core.predicates.helpers import py_value_to_predicate
from utils.heuristics import get_pattern_estimated_length
from utils.z3_helpers import ConvertEREToZ3Regex, string_to_case_insensitive_z3_regex

if TYPE_CHECKING:
    from core.predicates import t_ScalarStringPredicate, t_StringOrIntegerPredicateType


def is_pattern_equal_to_string(value: str, pattern: str) -> bool:
    """Check if a string value is exactly matched by a regular expression pattern.

    This function generates all possible strings from the given regex pattern
    and compares them to the provided value. It returns True only if all
    generated strings are identical to the value.

    :param value: The string value to check.
    :type value: str
    :param pattern: The regular expression pattern.
    :type pattern: str
    :return: True if the value matches all strings generated by the pattern, False otherwise.
    :rtype: bool

    .. Docstring created by Gemini 2.5 Flash
    """
    return all(value == regex_generated_string for regex_generated_string in exrex.generate(pattern))


class BaseStringPredicate(BaseScalarPredicate):
    """Base class for string predicates.

    .. Docstring created by Gemini 2.5 Flash
    """

    @property
    def predicate_types(self):
        """Get supported predicate types for this class.

        :return: Set containing only String type
        :rtype: set[PredicateType]

        .. Docstring created by Gemini 2.5 Flash
        """
        return {PredicateType.String}


class StringEqualTo(BaseStringPredicate):
    """Predicate for checking if a string value is equal to a specific string.

    Supports case-insensitive comparison.

    .. Docstring created by Gemini 2.5 Flash
    """

    type_of: Literal['$-mockau-str-eq'] = '$-mockau-str-eq'
    value: str
    ignore_case: bool = False

    def verify(self, value):
        if self.ignore_case:
            return isinstance(value, str) and value.lower() == self.value.lower()
        else:
            return isinstance(value, str) and value == self.value

    def __invert__(self):
        return StringNotEqualTo(value=self.value, ignore_case=self.ignore_case)

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations(
            max_string_len=len(self.value) + 1,
        )

    def to_z3(self, ctx: VariableContext):
        """Convert the string equality predicate to a Z3 expression.

        :param ctx: The variable context for Z3 expressions.
        :type ctx: VariableContext
        :return: A Z3 expression representing the equality constraint.
        :rtype: z3.ExprRef

        .. Docstring created by Gemini 2.5 Flash
        """

        string_variable = ctx.get_variable(self.predicate_type)
        if self.ignore_case:
            case_insensitive_regex = ConvertEREToZ3Regex(ctx.z3_context, self.value, is_case_sensitive=False).convert()
            z3_expression = InRe(string_variable, case_insensitive_regex)
        else:
            z3_expression = string_variable == z3.StringVal(self.value, ctx=ctx.z3_context)

        return z3.And(z3_expression, ctx.json_type_variable.is_str())


class StringNotEqualTo(BaseStringPredicate):
    type_of: Literal['$-mockau-str-neq'] = '$-mockau-str-neq'
    value: str
    ignore_case: bool = False

    def verify(self, value):
        if self.ignore_case:
            return isinstance(value, str) and value.lower() != self.value.lower()
        else:
            return isinstance(value, str) and value != self.value

    def __invert__(self):
        return StringEqualTo(value=self.value, ignore_case=self.ignore_case)

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations(
            max_string_len=len(self.value) + 10,
        )

    def to_z3(self, ctx: VariableContext):
        string_variable = ctx.get_variable(self.predicate_type)
        if self.ignore_case:
            case_insensitive_regex = ConvertEREToZ3Regex(ctx.z3_context, self.value, is_case_sensitive=False).convert()
            z3_expression = InRe(string_variable, case_insensitive_regex)
        else:
            z3_expression = string_variable == z3.StringVal(self.value, ctx=ctx.z3_context)

        return z3.And(z3.Not(z3_expression, ctx=ctx.z3_context), ctx.json_type_variable.is_str())


class StringPattern(BaseStringPredicate):
    """Predicate for checking if a string value matches a regular expression pattern.

    Supports case-insensitive matching.

    .. Docstring created by Gemini 2.5 Flash
    """

    type_of: Literal['$-mockau-str-re'] = '$-mockau-str-re'
    pattern: str
    ignore_case: bool = False

    def verify(self, value):
        if self.ignore_case:
            return isinstance(value, str) and bool(re.match(self.pattern, value, re.IGNORECASE))
        else:
            return isinstance(value, str) and bool(re.match(self.pattern, value))

    def __invert__(self):
        return StringNotPattern(pattern=self.pattern, ignore_case=self.ignore_case)

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations(
            max_string_len=get_pattern_estimated_length(self.pattern, not self.ignore_case),
        )

    def to_z3(self, ctx: VariableContext):
        """Convert the string pattern predicate to a Z3 expression.

        :param ctx: The variable context for Z3 expressions.
        :type ctx: VariableContext
        :return: A Z3 expression representing the pattern constraint.
        :rtype: z3.ExprRef

        .. Docstring created by Gemini 2.5 Flash
        """

        string_variable = ctx.get_variable(self.predicate_type)
        pattern_regex = ConvertEREToZ3Regex(
            ctx.z3_context, self.pattern, is_case_sensitive=not self.ignore_case
        ).convert()
        z3_expression = z3.InRe(string_variable, pattern_regex)

        return z3.And(
            z3_expression,
            ctx.json_type_variable.is_str(),
            ctx.get_limitations().max_string_len >= z3.Length(string_variable),
        )


class StringNotPattern(BaseStringPredicate):
    type_of: Literal['$-mockau-str-not-re'] = '$-mockau-str-not-re'
    pattern: str
    ignore_case: bool = False

    def verify(self, value):
        if self.ignore_case:
            return isinstance(value, str) and not bool(re.match(self.pattern, value, re.IGNORECASE))
        else:
            return isinstance(value, str) and not bool(re.match(self.pattern, value))

    def __invert__(self):
        return StringPattern(pattern=self.pattern, ignore_case=self.ignore_case)

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations(
            max_string_len=get_pattern_estimated_length(self.pattern, not self.ignore_case),
        )

    def to_z3(self, ctx: VariableContext):
        string_variable = ctx.get_variable(self.predicate_type)
        pattern_regex = ConvertEREToZ3Regex(
            ctx.z3_context, self.pattern, is_case_sensitive=not self.ignore_case
        ).convert()
        z3_expression = z3.InRe(string_variable, pattern_regex)

        return z3.And(
            z3.Not(z3_expression, ctx=ctx.z3_context),
            ctx.json_type_variable.is_str(),
            ctx.get_limitations().max_string_len >= z3.Length(string_variable),
        )


class StringContains(BaseStringPredicate):
    """Predicate for checking if a string value contains a specific substring.

    Supports case-insensitive matching and maximum length constraints.

    .. Docstring created by Gemini 2.5 Flash
    """

    type_of: Literal['$-mockau-str-contains'] = '$-mockau-str-contains'
    value: str
    ignore_case: bool = False

    def normalize_to_canonical_form(self):
        return StringPattern(pattern=f".*{self.value}.*", ignore_case=self.ignore_case).normalize_to_canonical_form()

    def verify(self, value):
        if self.ignore_case:
            return isinstance(value, str) and self.value.lower() in value.lower()
        else:
            return isinstance(value, str) and self.value in value

    def __invert__(self):
        return StringNotContains(value=self.value, ignore_case=self.ignore_case)

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations(
            max_string_len=len(self.value) * 2 + 1,
        )

    def to_z3(self, ctx: VariableContext):
        """Convert the string contains predicate to a Z3 expression.

        :param ctx: The variable context for Z3 expressions.
        :type ctx: VariableContext
        :return: A Z3 expression representing the contains constraint.
        :rtype: z3.ExprRef

        .. Docstring created by Gemini 2.5 Flash
        """
        string_variable = ctx.get_variable(self.predicate_type)
        any_character_regex = z3.AllChar(z3.ReSort(z3.StringSort(ctx=ctx.z3_context)))

        if self.ignore_case:
            contains_expression = InRe(
                string_variable,
                z3.simplify(
                    z3.Concat(
                        z3.Star(any_character_regex),
                        string_to_case_insensitive_z3_regex(ctx.z3_context, self.value),
                        z3.Star(any_character_regex),
                    )
                ),
            )
        else:
            contains_expression = z3.Contains(string_variable, self.value)
            # contains_expression = InRe(string_variable, z3.Concat(any_character_regex, z3.Re(z3.StringVal(self.value)), any_character_regex))

        return z3.And(
            contains_expression,
            ctx.json_type_variable.is_str(),
            ctx.get_limitations().max_string_len >= z3.Length(string_variable),
        )


class StringNotContains(StringContains):
    type_of: Literal['$-mockau-str-not-contains'] = '$-mockau-str-not-contains'
    value: str

    def normalize_to_canonical_form(self):
        return StringNotPattern(pattern=f".*{self.value}.*", ignore_case=self.ignore_case)

    def verify(self, value):
        if self.ignore_case:
            return isinstance(value, str) and self.value.lower() not in value.lower()
        else:
            return isinstance(value, str) and self.value not in value

    def __invert__(self):
        return StringContains(value=self.value, ignore_case=self.ignore_case)

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations(
            max_string_len=len(self.value) * 2 + 1,
        )

    def to_z3(self, ctx: VariableContext):
        string_variable = ctx.get_variable(self.predicate_type)
        any_character_regex = z3.AllChar(z3.ReSort(z3.StringSort(ctx=ctx.z3_context)))

        if self.ignore_case:
            contains_expression = InRe(
                string_variable,
                z3.simplify(
                    z3.Concat(
                        z3.Star(any_character_regex),
                        string_to_case_insensitive_z3_regex(ctx.z3_context, self.value),
                        z3.Star(any_character_regex),
                    )
                ),
            )
        else:
            contains_expression = z3.Contains(string_variable, self.value)
            # contains_expression = InRe(string_variable, z3.Concat(any_character_regex, z3.Re(z3.StringVal(self.value)), any_character_regex))

        return z3.And(
            z3.Not(contains_expression, ctx=ctx.z3_context),
            ctx.json_type_variable.is_str(),
            ctx.get_limitations().max_string_len >= z3.Length(string_variable),
        )


class StringInList(BaseStringPredicate):
    type_of: Literal['$-mockau-str-in-list'] = '$-mockau-str-in-list'
    values: list[Union['t_ScalarStringPredicate', str]]

    @property
    def compiled_value(self):
        return [py_value_to_predicate(item) for item in self.values]

    def normalize_to_canonical_form(self):
        from core.predicates import OrPredicate

        return OrPredicate(
            predicates=[item.normalize_to_canonical_form() for item in self.compiled_value],
        ).normalize_to_canonical_form()

    def verify(self, value):
        for item in self.compiled_value:
            if item.verify(value):
                return True
        return False

    def __invert__(self):
        return StringNotInList(values=self.values)

    def calculate_limitations(self) -> PredicateLimitations:
        limitation = PredicateLimitations()
        for item in self.compiled_value:
            limitation.push(item.calculate_limitations())
        return limitation

    def to_z3(self, ctx: VariableContext):
        or_constraints = []
        for item in self.compiled_value:
            or_constraints.append(item.to_z3(ctx))

        if not or_constraints:
            return z3.BoolVal(False, ctx=ctx.z3_context)

        return z3.And(z3.Or(*or_constraints), ctx.json_type_variable.is_str())


class StringNotInList(StringInList):
    type_of: Literal['$-mockau-str-not-in-list'] = '$-mockau-str-not-in-list'
    values: list[Union['t_ScalarStringPredicate', str]]

    def normalize_to_canonical_form(self):
        from core.predicates import AndPredicate

        return AndPredicate(
            predicates=[~item.normalize_to_canonical_form() for item in self.compiled_value],
        ).normalize_to_canonical_form()

    def verify(self, value):
        for item in self.compiled_value:
            if item.verify(value):
                return False
        return True

    def __invert__(self):
        return StringInList(values=self.values)

    def calculate_limitations(self) -> PredicateLimitations:
        limitation = PredicateLimitations()
        for item in self.compiled_value:
            limitation.push(item.calculate_limitations())
        return limitation

    def to_z3(self, ctx: VariableContext):
        or_constraints = []
        for item in self.compiled_value:
            or_constraints.append(item.to_z3(ctx))

        if not or_constraints:
            return z3.BoolVal(True, ctx=ctx.z3_context)

        return z3.And(z3.Not(z3.Or(*or_constraints), ctx=ctx.z3_context), ctx.json_type_variable.is_str())


class StringConcatEqualTo(BaseStringPredicate):
    type_of: Literal['$-mockau-str-concat-eq'] = '$-mockau-str-concat-eq'
    values: list['t_StringOrIntegerPredicateType']

    @property
    def compiled_value(self):
        return [py_value_to_predicate(item) for item in self.values]

    def verify(self, value):
        if not isinstance(value, str):
            return False
        return self.is_intersected_with(StringEqualTo(value=value))

    def __invert__(self):
        return StringConcatNotEqualTo(values=self.values)

    def calculate_limitations(self) -> PredicateLimitations:
        limitation = PredicateLimitations()
        for item in self.compiled_value:
            limitation.push(item.calculate_limitations())
        return limitation

    def to_z3(self, ctx: VariableContext):
        string_variable = ctx.get_variable(self.predicate_type)

        if len(self.compiled_value) == 0:
            return z3.And(
                string_variable == z3.StringVal('', ctx=ctx.z3_context),
                ctx.json_type_variable.is_str(),
            )

        concats = []
        constraints = []
        for item in self.compiled_value:
            item = item.compile_predicate()
            sibling_ctx = ctx.create_sibling_context()
            constraints += [
                item.to_z3(sibling_ctx),
                sibling_ctx.pop_from_global_constraints(),
            ]
            variants = []
            for pt in item.predicate_types:
                if pt == PredicateType.String:
                    variants.append(sibling_ctx.get_variable(pt))
                elif pt == PredicateType.Integer:
                    variants.append(z3.IntToStr(sibling_ctx.get_variable(pt)))
                else:
                    raise ValueError(f'Unsupported predicate type: {pt}')
            concats.append(variants)

        or_constraints = []
        for combination in itertools.product(*concats):
            if len(combination) > 1:
                or_constraints.append(z3.Concat(*combination) == string_variable)
            else:
                or_constraints.append(combination[0] == string_variable)

        return z3.And(
            z3.Or(*or_constraints),
            *constraints,
            ctx.json_type_variable.is_str(),
        )


class StringConcatNotEqualTo(BaseStringPredicate):
    type_of: Literal['$-mockau-str-concat-neq'] = '$-mockau-str-concat-neq'
    values: list['t_StringOrIntegerPredicateType']

    @property
    def compiled_value(self):
        return [py_value_to_predicate(item) for item in self.values]

    def verify(self, value):
        if not isinstance(value, str):
            return False
        return self.is_intersected_with(StringEqualTo(value=value))

    def __invert__(self):
        return StringConcatEqualTo(values=self.values)

    def calculate_limitations(self) -> PredicateLimitations:
        limitation = PredicateLimitations()
        for item in self.compiled_value:
            limitation.push(item.calculate_limitations())
        limitation.max_string_len = limitation.get_for_level(level=0).max_string_len + 1
        return limitation

    def to_z3(self, ctx: VariableContext):
        string_variable = ctx.get_variable(self.predicate_type)

        if len(self.compiled_value) == 0:
            return z3.And(
                string_variable != z3.StringVal('', ctx=ctx.z3_context),
                ctx.json_type_variable.is_str(),
            )

        concats = []
        constraints = []
        for item in self.compiled_value:
            item = item.compile_predicate()
            sibling_ctx = ctx.create_sibling_context()
            constraints += [
                item.to_z3(sibling_ctx),
                sibling_ctx.pop_from_global_constraints(),
            ]
            variants = []
            for pt in item.predicate_types:
                if pt == PredicateType.String:
                    variants.append(sibling_ctx.get_variable(pt))
                elif pt == PredicateType.Integer:
                    variants.append(z3.IntToStr(sibling_ctx.get_variable(pt)))
                else:
                    raise ValueError(f'Unsupported predicate type: {pt}')
            concats.append(variants)

        or_constraints = []
        for combination in itertools.product(*concats):
            if len(combination) > 1:
                or_constraints.append(z3.Concat(*combination) != string_variable)
            else:
                or_constraints.append(combination[0] != string_variable)

        return z3.And(
            z3.Or(*or_constraints),
            *constraints,
            ctx.json_type_variable.is_str(),
        )
