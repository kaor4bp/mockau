import re
from typing import Literal

import exrex
import z3
from z3 import InRe

from core.predicates.base_predicate import BaseScalarPredicate, PredicateType, VariableContext
from core.predicates.context.predicate_limitations import PredicateLimitations
from utils.heuristics import get_pattern_estimated_length
from utils.z3_helpers import ConvertEREToZ3Regex, string_to_case_insensitive_z3_regex


def is_pattern_equal_to_string(value: str, pattern: str) -> bool:
    """Check if a string value is exactly matched by a regular expression pattern.

    This function generates all possible strings from the given regex pattern
    and compares them to the provided value. It returns True only if all
    generated strings are identical to the value.

    :param value: The string value to check.
    :type value: str
    :param pattern: The regular expression pattern.
    :type pattern: str
    :return: True if the value matches all strings generated by the pattern, False otherwise.
    :rtype: bool

    .. Docstring created by Gemini 2.5 Flash
    """
    return all(value == regex_generated_string for regex_generated_string in exrex.generate(pattern))


class BaseStringPredicate(BaseScalarPredicate):
    """Base class for string predicates.

    .. Docstring created by Gemini 2.5 Flash
    """

    @property
    def predicate_types(self):
        """Get supported predicate types for this class.

        :return: Set containing only String type
        :rtype: set[PredicateType]

        .. Docstring created by Gemini 2.5 Flash
        """
        return {PredicateType.String}


class StringEqualTo(BaseStringPredicate):
    """Predicate for checking if a string value is equal to a specific string.

    Supports case-insensitive comparison.

    .. Docstring created by Gemini 2.5 Flash
    """

    type_of: Literal['$-mockau-str-eq'] = '$-mockau-str-eq'
    value: str
    ignore_case: bool = False

    def verify(self, value):
        if self.ignore_case:
            return isinstance(value, str) and value.lower() == self.value.lower()
        else:
            return isinstance(value, str) and value == self.value

    def __invert__(self):
        return StringNotEqualTo(value=self.value, ignore_case=self.ignore_case)

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations(
            max_string_len=len(self.value) + 1,
        )

    def to_z3(self, ctx: VariableContext):
        """Convert the string equality predicate to a Z3 expression.

        :param ctx: The variable context for Z3 expressions.
        :type ctx: VariableContext
        :return: A Z3 expression representing the equality constraint.
        :rtype: z3.ExprRef

        .. Docstring created by Gemini 2.5 Flash
        """

        string_variable = ctx.get_variable(self.predicate_type)
        if self.ignore_case:
            case_insensitive_regex = ConvertEREToZ3Regex(ctx.z3_context, self.value, is_case_sensitive=False).convert()
            z3_expression = InRe(string_variable, case_insensitive_regex)
        else:
            z3_expression = string_variable == z3.StringVal(self.value, ctx=ctx.z3_context)

        return z3.And(z3_expression, ctx.json_type_variable.is_str())


class StringNotEqualTo(BaseStringPredicate):
    type_of: Literal['$-mockau-str-neq'] = '$-mockau-str-neq'
    value: str
    ignore_case: bool = False

    def verify(self, value):
        if self.ignore_case:
            return isinstance(value, str) and value.lower() != self.value.lower()
        else:
            return isinstance(value, str) and value != self.value

    def __invert__(self):
        return StringEqualTo(value=self.value, ignore_case=self.ignore_case)

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations(
            max_string_len=len(self.value) + 10,
        )

    def to_z3(self, ctx: VariableContext):
        string_variable = ctx.get_variable(self.predicate_type)
        if self.ignore_case:
            case_insensitive_regex = ConvertEREToZ3Regex(ctx.z3_context, self.value, is_case_sensitive=False).convert()
            z3_expression = InRe(string_variable, case_insensitive_regex)
        else:
            z3_expression = string_variable == z3.StringVal(self.value, ctx=ctx.z3_context)

        return z3.And(z3.Not(z3_expression, ctx=ctx.z3_context), ctx.json_type_variable.is_str())


class StringPattern(BaseStringPredicate):
    """Predicate for checking if a string value matches a regular expression pattern.

    Supports case-insensitive matching.

    .. Docstring created by Gemini 2.5 Flash
    """

    type_of: Literal['$-mockau-str-re'] = '$-mockau-str-re'
    pattern: str
    ignore_case: bool = False

    def verify(self, value):
        if self.ignore_case:
            return isinstance(value, str) and bool(re.match(self.pattern, value, re.IGNORECASE))
        else:
            return isinstance(value, str) and bool(re.match(self.pattern, value))

    def __invert__(self):
        return StringNotPattern(pattern=self.pattern, ignore_case=self.ignore_case)

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations(
            max_string_len=get_pattern_estimated_length(self.pattern, not self.ignore_case),
        )

    def to_z3(self, ctx: VariableContext):
        """Convert the string pattern predicate to a Z3 expression.

        :param ctx: The variable context for Z3 expressions.
        :type ctx: VariableContext
        :return: A Z3 expression representing the pattern constraint.
        :rtype: z3.ExprRef

        .. Docstring created by Gemini 2.5 Flash
        """

        string_variable = ctx.get_variable(self.predicate_type)
        pattern_regex = ConvertEREToZ3Regex(
            ctx.z3_context, self.pattern, is_case_sensitive=not self.ignore_case
        ).convert()
        z3_expression = z3.InRe(string_variable, pattern_regex)

        return z3.And(
            z3_expression,
            ctx.json_type_variable.is_str(),
            ctx.get_limitations().max_string_len >= z3.Length(string_variable),
        )


class StringNotPattern(BaseStringPredicate):
    type_of: Literal['$-mockau-str-not-re'] = '$-mockau-str-not-re'
    pattern: str
    ignore_case: bool = False

    def verify(self, value):
        if self.ignore_case:
            return isinstance(value, str) and not bool(re.match(self.pattern, value, re.IGNORECASE))
        else:
            return isinstance(value, str) and not bool(re.match(self.pattern, value))

    def __invert__(self):
        return StringPattern(pattern=self.pattern, ignore_case=self.ignore_case)

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations(
            max_string_len=get_pattern_estimated_length(self.pattern, not self.ignore_case),
        )

    def to_z3(self, ctx: VariableContext):
        string_variable = ctx.get_variable(self.predicate_type)
        pattern_regex = ConvertEREToZ3Regex(
            ctx.z3_context, self.pattern, is_case_sensitive=not self.ignore_case
        ).convert()
        z3_expression = z3.InRe(string_variable, pattern_regex)

        return z3.And(
            z3.Not(z3_expression, ctx=ctx.z3_context),
            ctx.json_type_variable.is_str(),
            ctx.get_limitations().max_string_len >= z3.Length(string_variable),
        )


class StringContains(BaseStringPredicate):
    """Predicate for checking if a string value contains a specific substring.

    Supports case-insensitive matching and maximum length constraints.

    .. Docstring created by Gemini 2.5 Flash
    """

    type_of: Literal['$-mockau-str-contains'] = '$-mockau-str-contains'
    value: str
    ignore_case: bool = False

    def verify(self, value):
        if self.ignore_case:
            return isinstance(value, str) and self.value.lower() in value.lower()
        else:
            return isinstance(value, str) and self.value in value

    def __invert__(self):
        return StringNotContains(value=self.value, ignore_case=self.ignore_case)

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations(
            max_string_len=len(self.value) * 2 + 1,
        )

    def to_z3(self, ctx: VariableContext):
        """Convert the string contains predicate to a Z3 expression.

        :param ctx: The variable context for Z3 expressions.
        :type ctx: VariableContext
        :return: A Z3 expression representing the contains constraint.
        :rtype: z3.ExprRef

        .. Docstring created by Gemini 2.5 Flash
        """
        string_variable = ctx.get_variable(self.predicate_type)
        any_character_regex = z3.AllChar(z3.ReSort(z3.StringSort(ctx=ctx.z3_context)))

        if self.ignore_case:
            contains_expression = InRe(
                string_variable,
                z3.simplify(
                    z3.Concat(
                        z3.Star(any_character_regex),
                        string_to_case_insensitive_z3_regex(ctx.z3_context, self.value),
                        z3.Star(any_character_regex),
                    )
                ),
            )
        else:
            contains_expression = z3.Contains(string_variable, self.value)
            # contains_expression = InRe(string_variable, z3.Concat(any_character_regex, z3.Re(z3.StringVal(self.value)), any_character_regex))

        return z3.And(
            contains_expression,
            ctx.json_type_variable.is_str(),
            ctx.get_limitations().max_string_len >= z3.Length(string_variable),
        )


class StringNotContains(StringContains):
    type_of: Literal['$-mockau-str-not-contains'] = '$-mockau-str-not-contains'
    value: str

    def verify(self, value):
        if self.ignore_case:
            return isinstance(value, str) and self.value.lower() not in value.lower()
        else:
            return isinstance(value, str) and self.value not in value

    def __invert__(self):
        return StringContains(value=self.value, ignore_case=self.ignore_case)

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations(
            max_string_len=len(self.value) * 2 + 1,
        )

    def to_z3(self, ctx: VariableContext):
        string_variable = ctx.get_variable(self.predicate_type)
        any_character_regex = z3.AllChar(z3.ReSort(z3.StringSort(ctx=ctx.z3_context)))

        if self.ignore_case:
            contains_expression = InRe(
                string_variable,
                z3.simplify(
                    z3.Concat(
                        z3.Star(any_character_regex),
                        string_to_case_insensitive_z3_regex(ctx.z3_context, self.value),
                        z3.Star(any_character_regex),
                    )
                ),
            )
        else:
            contains_expression = z3.Contains(string_variable, self.value)
            # contains_expression = InRe(string_variable, z3.Concat(any_character_regex, z3.Re(z3.StringVal(self.value)), any_character_regex))

        return z3.And(
            z3.Not(contains_expression, ctx=ctx.z3_context),
            ctx.json_type_variable.is_str(),
            ctx.get_limitations().max_string_len >= z3.Length(string_variable),
        )
