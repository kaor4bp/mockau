# Generated by Gemini AI 2.5 Pro
import pytest

from core.predicates.logical.logical_predicates import AndPredicate, AnyPredicate, NotPredicate, OrPredicate
from core.predicates.scalars.integer_predicates import (
    IntegerEqualTo,
    IntegerGreaterOrEqualThan,
    IntegerGreaterThan,
    IntegerLessOrEqualThan,
    IntegerLessThan,
)
from utils.formatters import get_params_argv

# Rebuild Pydantic models to correctly resolve forward references
NotPredicate.model_rebuild()
AndPredicate.model_rebuild()
OrPredicate.model_rebuild()

EQUIVALENTS = {
    'x_eq_1_equiv_not_gt_1_and_not_lt_1': [
        IntegerEqualTo(value=1),
        AndPredicate(
            predicates=[
                NotPredicate(predicate=IntegerGreaterThan(value=1)),
                NotPredicate(predicate=IntegerLessThan(value=1)),
            ]
        ),
    ],
    'x_ge_1_equiv_x_gt_1_or_x_eq_1': [
        IntegerGreaterOrEqualThan(value=1),
        OrPredicate(predicates=[IntegerGreaterThan(value=1), IntegerEqualTo(value=1)]),
    ],
    'range_1_lt_x_lt_5_or_x_eq_1_or_x_eq_5_equiv_1_le_x_le_5': [
        OrPredicate(
            predicates=[
                AndPredicate(
                    predicates=[
                        IntegerGreaterThan(value=1),
                        IntegerLessThan(value=5),
                    ]
                ),
                IntegerEqualTo(value=1),
                IntegerEqualTo(value=5),
            ]
        ),
        AndPredicate(predicates=[IntegerGreaterOrEqualThan(value=1), IntegerLessOrEqualThan(value=5)]),
    ],
    'range_1_lt_x_lt_5_equiv_1_le_x_le_5_and_x_ne_1_and_x_ne_5': [
        AndPredicate(  # Changed from OrPredicate(predicates=[AndPredicate(...)]) to just AndPredicate(...)
            predicates=[
                IntegerGreaterThan(value=1),
                IntegerLessThan(value=5),
            ]
        ),
        AndPredicate(
            predicates=[
                IntegerGreaterOrEqualThan(value=1),
                IntegerLessOrEqualThan(value=5),
                NotPredicate(predicate=IntegerEqualTo(value=1)),
                NotPredicate(predicate=IntegerEqualTo(value=5)),
            ]
        ),
    ],
    'x_ne_1_equiv_x_lt_1_or_x_gt_1': [
        NotPredicate(predicate=IntegerEqualTo(value=1)),
        OrPredicate(predicates=[IntegerLessThan(value=1), IntegerGreaterThan(value=1)]),
    ],
    'double_negation_x_eq_1': [
        NotPredicate(predicate=NotPredicate(predicate=IntegerEqualTo(value=1))),
        IntegerEqualTo(value=1),
    ],
    'x_le_5_equiv_not_x_gt_5': [
        IntegerLessOrEqualThan(value=5),
        NotPredicate(predicate=IntegerGreaterThan(value=5)),
    ],
}

SUPERSETS = {
    'x_gt_5_supset_x_eq_6': [IntegerGreaterThan(value=5), IntegerEqualTo(value=6)],
    'x_gt_5_supset_x_gt_6': [IntegerGreaterThan(value=5), IntegerGreaterThan(value=6)],
    'x_gt_5_supset_x_ge_7': [IntegerGreaterThan(value=5), IntegerGreaterOrEqualThan(value=7)],
    'x_ge_5_supset_x_gt_5': [IntegerGreaterOrEqualThan(value=5), IntegerGreaterThan(value=5)],
    'x_ge_5_supset_x_ge_6': [IntegerGreaterOrEqualThan(value=5), IntegerGreaterOrEqualThan(value=6)],
    'x_lt_5_supset_x_lt_4': [IntegerLessThan(value=5), IntegerLessThan(value=4)],
    'x_lt_5_supset_x_le_3': [IntegerLessThan(value=5), IntegerLessOrEqualThan(value=3)],
    'x_le_5_supset_x_lt_5': [IntegerLessOrEqualThan(value=5), IntegerLessThan(value=5)],
    'x_le_5_supset_x_le_4': [IntegerLessOrEqualThan(value=5), IntegerLessOrEqualThan(value=4)],
    'range_1_le_x_lt_5_supset_1_lt_x_lt_5': [
        AndPredicate(
            predicates=[
                IntegerGreaterOrEqualThan(value=1),
                IntegerLessThan(value=5),
            ]
        ),
        AndPredicate(predicates=[IntegerGreaterThan(value=1), IntegerLessThan(value=5)]),
    ],
    'range_1_lt_x_lt_5_or_x_eq_1_supset_1_lt_x_lt_5': [
        OrPredicate(
            predicates=[
                AndPredicate(
                    predicates=[
                        IntegerGreaterThan(value=1),
                        IntegerLessThan(value=5),
                    ]
                ),
                IntegerEqualTo(value=1),
            ]
        ),
        AndPredicate(predicates=[IntegerGreaterThan(value=1), IntegerLessThan(value=5)]),
    ],
    'range_1_lt_x_lt_5_or_x_eq_1_or_x_eq_5_supset_1_lt_x_le_5': [
        OrPredicate(
            predicates=[
                AndPredicate(
                    predicates=[
                        IntegerGreaterThan(value=1),
                        IntegerLessThan(value=5),
                    ]
                ),
                IntegerEqualTo(value=1),
                IntegerEqualTo(value=5),
            ]
        ),
        AndPredicate(predicates=[IntegerGreaterThan(value=1), IntegerLessOrEqualThan(value=5)]),
    ],
    'x_ne_0_supset_x_gt_0': [NotPredicate(predicate=IntegerEqualTo(value=0)), IntegerGreaterThan(value=0)],
    'any_supset_x_eq_10': [AnyPredicate(), IntegerEqualTo(value=10)],
}

INTERSECTIONS = {
    'x_gt_5_cap_x_lt_7': [IntegerGreaterThan(value=5), IntegerLessThan(value=7)],  # 6
    'x_gt_5_cap_not_x_gt_6': [IntegerGreaterThan(value=5), NotPredicate(predicate=IntegerGreaterThan(value=6))],  # 6
    'x_gt_5_cap_x_le_6': [IntegerGreaterThan(value=5), IntegerLessOrEqualThan(value=6)],  # 6
    'x_ge_5_cap_x_lt_6': [IntegerGreaterOrEqualThan(value=5), IntegerLessThan(value=6)],  # 5
    'x_ge_5_cap_x_le_5': [IntegerGreaterOrEqualThan(value=5), IntegerLessOrEqualThan(value=5)],  # 5
    'x_ge_5_cap_x_le_6': [IntegerGreaterOrEqualThan(value=5), IntegerLessOrEqualThan(value=6)],  # 5, 6
    'x_ge_5_cap_not_x_gt_6': [
        IntegerGreaterOrEqualThan(value=5),
        NotPredicate(predicate=IntegerGreaterThan(value=6)),
    ],  # 5, 6
    'x_ge_5_cap_range_6_lt_x_lt_8': [
        IntegerGreaterOrEqualThan(value=5),  # x >= 5
        AndPredicate(predicates=[IntegerLessThan(value=8), IntegerGreaterThan(value=6)]),  # 6 < x < 8 -> x = 7
    ],  # intersection is x = 7
    'or_ge5_le2_cap_or_gt5_le2': [  # (x >= 5 or x <= 2) AND (x > 5 or x <= 2)
        OrPredicate(predicates=[IntegerGreaterOrEqualThan(value=5), IntegerLessOrEqualThan(value=2)]),
        OrPredicate(predicates=[IntegerGreaterThan(value=5), IntegerLessOrEqualThan(value=2)]),
    ],  # Common: x > 5 or x <= 2
    'x_eq_5_cap_any': [IntegerEqualTo(value=5), AnyPredicate()],
}

NOT_INTERSECTIONS = {
    'x_lt_0_cap_x_gt_0': [IntegerLessThan(value=0), IntegerGreaterThan(value=0)],
    'x_eq_1_cap_x_eq_2': [IntegerEqualTo(value=1), IntegerEqualTo(value=2)],
    'x_le_5_cap_x_gt_5': [IntegerLessOrEqualThan(value=5), IntegerGreaterThan(value=5)],
    'range_1_to_3_cap_range_5_to_7': [
        AndPredicate(predicates=[IntegerGreaterOrEqualThan(value=1), IntegerLessOrEqualThan(value=3)]),
        AndPredicate(predicates=[IntegerGreaterOrEqualThan(value=5), IntegerLessOrEqualThan(value=7)]),
    ],
}


class TestIntegerIsSubsetOf:
    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_one_equivalent_is_subset_of_another(self, p1, p2):
        assert p1.is_subset_of(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_subset_is_subset_of_superset(self, p1, p2):
        assert p2.is_subset_of(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_superset_is_not_subset_of_subset(self, p1, p2):
        # Test that p1 (superset) is not a subset of p2 (subset)
        # unless they are equivalent
        if not p1.is_equivalent_to(p2):
            assert not p1.is_subset_of(p2)
        else:
            assert p1.is_subset_of(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_subset_of_equivalents_is_symmetric(self, p1, p2):
        assert p2.is_subset_of(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_non_intersecting_are_not_subsets_unless_specific_cases(self, p1, p2):
        # Generally, if two sets don't intersect, one isn't a subset of the other unless one is empty set
        # This logic is complex for predicates, for now, just a basic check.
        # If we define an "empty" predicate, more specific tests can be added.
        assert not p1.is_subset_of(p2) or p1.is_equivalent_to(AnyPredicate())  # Placeholder for empty set concept
        assert not p2.is_subset_of(p1) or p2.is_equivalent_to(AnyPredicate())


class TestIntegerIsSupersetOf:
    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_superset_is_superset_of_subset(self, p1, p2):
        assert p1.is_superset_of(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_subset_is_not_superset_of_superset(self, p1, p2):
        # Test that p2 (subset) is not a superset of p1 (superset)
        # unless they are equivalent
        if not p2.is_equivalent_to(p1):
            assert not p2.is_superset_of(p1)
        else:
            assert p2.is_superset_of(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_one_equivalent_is_superset_of_another(self, p1, p2):
        assert p1.is_superset_of(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_superset_of_equivalents_is_symmetric(self, p1, p2):
        assert p2.is_superset_of(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_non_intersecting_are_not_supersets_unless_specific_cases(self, p1, p2):
        assert not p1.is_superset_of(p2) or p2.is_equivalent_to(AnyPredicate())  # Placeholder
        assert not p2.is_superset_of(p1) or p1.is_equivalent_to(AnyPredicate())


class TestIntegerIsIntersectedWith:
    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(INTERSECTIONS))
    def test_intersections_are_intersected(self, p1, p2):
        assert p1.is_intersected_with(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(INTERSECTIONS))
    def test_intersections_are_symmetrical_intersected(self, p1, p2):
        assert p2.is_intersected_with(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_intersected(self, p1, p2):
        assert p1.is_intersected_with(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_symmetrically_intersected(self, p1, p2):
        assert p2.is_intersected_with(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_superset_and_subset_are_intersected(self, p1, p2):
        assert p2.is_intersected_with(p1)  # p2 (subset) intersects p1 (superset)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_subset_and_superset_are_symmetrically_intersectable(self, p1, p2):
        assert p1.is_intersected_with(p2)  # p1 (superset) intersects p2 (subset)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_not_intersections_are_not_intersected(self, p1, p2):
        assert not p1.is_intersected_with(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_not_intersections_are_symmetrically_not_intersected(self, p1, p2):
        assert not p2.is_intersected_with(p1)


class TestIntegerIsEquivalentTo:
    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_equivalent(self, p1, p2):
        assert p1.is_equivalent_to(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_symmetrically_equivalent(self, p1, p2):
        assert p2.is_equivalent_to(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_subset_is_not_equivalent_to_superset(self, p1, p2):
        if p1.is_equivalent_to(p2):  # handles AnyPredicate case
            return
        assert not p2.is_equivalent_to(p1)  # p2 (subset) is not equivalent to p1 (superset)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_superset_is_not_equivalent_to_subset(self, p1, p2):
        if p1.is_equivalent_to(p2):  # handles AnyPredicate case
            return
        assert not p1.is_equivalent_to(p2)  # p1 (superset) is not equivalent to p2 (subset)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(INTERSECTIONS))
    def test_intersecting_non_equivalents_are_not_equivalent(self, p1, p2):
        if not p1.is_equivalent_to(p2):
            assert not p1.is_equivalent_to(p2)
            assert not p2.is_equivalent_to(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_non_intersecting_are_not_equivalent(self, p1, p2):
        assert not p1.is_equivalent_to(p2)
        assert not p2.is_equivalent_to(p1)


class TestIntegerPredicates:
    # IntegerEqualTo tests
    @pytest.mark.parametrize(
        ['value', 'test_value', 'expected'],
        [
            [5, 5, True],  # exact match
            [5, 5.0, False],  # float with .0 should not match an integer predicate
            [5, 6, False],  # not equal
            [0, -0, True],  # zero equality
            # [5, None, False], # test with None
            [5, "5", False],  # test with string
        ],
    )
    def test_integer_equal_to_valid(self, value, test_value, expected):
        predicate = IntegerEqualTo(value=value)
        assert predicate.is_matched(test_value) == expected

    # IntegerGreaterThan tests
    @pytest.mark.parametrize(
        ['value', 'test_value', 'expected'],
        [
            [5, 6, True],
            [5, 5, False],
            [5, 4, False],
            [-5, -4, True],
            # [5, None, False],
            [5, "6", False],
            [2147483647, 2147483647, False],  # Max Int
            [2147483646, 2147483647, True],  # Max Int
        ],
    )
    def test_integer_greater_than(self, value, test_value, expected):
        predicate = IntegerGreaterThan(value=value)
        assert predicate.is_matched(test_value) == expected

    # IntegerGreaterOrEqualThan tests
    @pytest.mark.parametrize(
        ['value', 'test_value', 'expected'],
        [
            [5, 6, True],
            [5, 5, True],
            [5, 4, False],
            [-5, -5, True],
            # [5, None, False],
            [5, "5", False],
            [2147483647, 2147483647, True],  # Max Int
        ],
    )
    def test_integer_greater_or_equal_than(self, value, test_value, expected):
        predicate = IntegerGreaterOrEqualThan(value=value)
        assert predicate.is_matched(test_value) == expected

    # IntegerLessThan tests
    @pytest.mark.parametrize(
        ['value', 'test_value', 'expected'],
        [
            [5, 4, True],
            [5, 5, False],
            [5, 6, False],
            [-5, -6, True],
            # [5, None, False],
            [5, "4", False],
            [-2147483648, -2147483648, False],  # Min Int
            [-2147483647, -2147483648, True],  # Min Int
        ],
    )
    def test_integer_less_than(self, value, test_value, expected):
        predicate = IntegerLessThan(value=value)
        assert predicate.is_matched(test_value) == expected

    # IntegerLessOrEqualThan tests
    @pytest.mark.parametrize(
        ['value', 'test_value', 'expected'],
        [
            [5, 4, True],
            [5, 5, True],
            [5, 6, False],
            [-5, -5, True],
            # [5, None, False],
            [5, "5", False],
            [-2147483648, -2147483648, True],  # Min Int
        ],
    )
    def test_integer_less_or_equal_than(self, value, test_value, expected):
        predicate = IntegerLessOrEqualThan(value=value)
        assert predicate.is_matched(test_value) == expected

    # NotPredicate tests
    @pytest.mark.parametrize(
        ['predicate', 'test_value', 'expected'],
        [
            [IntegerEqualTo(value=5), 5, False],
            [IntegerEqualTo(value=5), 6, True],
            [IntegerGreaterThan(value=5), 6, False],
            [IntegerGreaterThan(value=5), 4, True],
            [NotPredicate(predicate=IntegerEqualTo(value=10)), 10, True],  # Double negation
        ],
    )
    def test_integer_not(self, predicate, test_value, expected):
        not_predicate = NotPredicate(predicate=predicate)
        assert not_predicate.is_matched(test_value) == expected

    # AndPredicate tests
    @pytest.mark.parametrize(
        ['predicates', 'test_value', 'expected'],
        [
            [[IntegerEqualTo(value=5), IntegerLessThan(value=10)], 5, True],
            [[IntegerEqualTo(value=5), IntegerLessThan(value=10)], 11, False],
            [[IntegerGreaterThan(value=0), IntegerLessThan(value=10)], 5, True],
            [[IntegerGreaterThan(value=5), IntegerLessThan(value=10)], 10, False],  # boundary
            [
                [IntegerGreaterThan(value=0), IntegerLessThan(value=10), IntegerEqualTo(value=5)],
                5,
                True,
            ],  # three predicates
            [
                [IntegerGreaterThan(value=0), IntegerLessThan(value=3), IntegerEqualTo(value=5)],
                5,
                False,
            ],  # three predicates, one false
            # [[], 5, True], # Empty AndPredicate
        ],
    )
    def test_integer_and(self, predicates, test_value, expected):
        and_predicate = AndPredicate(predicates=predicates)
        assert and_predicate.is_matched(test_value) == expected

    # OrPredicate tests
    @pytest.mark.parametrize(
        ['predicates', 'test_value', 'expected'],
        [
            [[IntegerEqualTo(value=5), IntegerEqualTo(value=10)], 5, True],
            [[IntegerEqualTo(value=5), IntegerEqualTo(value=10)], 10, True],
            [[IntegerEqualTo(value=5), IntegerEqualTo(value=10)], 7, False],
            [
                [IntegerLessThan(value=0), IntegerGreaterThan(value=100), IntegerEqualTo(value=50)],
                50,
                True,
            ],  # three predicates
            [
                [IntegerLessThan(value=0), IntegerGreaterThan(value=100), IntegerEqualTo(value=50)],
                7,
                False,
            ],  # three predicates, all false
            [[], 5, False],  # Empty OrPredicate
        ],
    )
    def test_integer_or(self, predicates, test_value, expected):
        or_predicate = OrPredicate(predicates=predicates)
        assert or_predicate.is_matched(test_value) == expected

    # AnyPredicate tests
    @pytest.mark.parametrize(
        ['test_value'],
        [
            [123],
            [0],
            [-123],
            # [None], # AnyPredicate should match any value, including None or different types.
            ["string"],
        ],
    )
    def test_integer_any(self, test_value):  # Renamed from test_value to make it a list of single elements
        any_predicate = AnyPredicate()
        assert any_predicate.is_matched(test_value) is True
