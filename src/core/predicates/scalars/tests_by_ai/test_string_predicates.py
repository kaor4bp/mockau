# Generated by Gemini AI 2.5 Pro
import re

import pytest

from core.predicates.logical.logical_predicates import AndPredicate, AnyPredicate, NotPredicate, OrPredicate
from core.predicates.scalars.string_predicates import StringContains, StringEqualTo, StringPattern
from utils.formatters import get_params_argv  # Assuming this is the intended usage based on other files

# Rebuild Pydantic models
NotPredicate.model_rebuild()
AndPredicate.model_rebuild()
OrPredicate.model_rebuild()

EQUIVALENTS = {
    'equal_to_identical': [StringEqualTo(value='hello'), StringEqualTo(value='hello')],
    'contains_identical': [StringContains(value='hello'), StringContains(value='hello')],
    'pattern_identical': [StringPattern(pattern='hello.*'), StringPattern(pattern='hello.*')],
    'pattern_equiv_contains': [StringPattern(pattern='.*hello.*'), StringContains(value='hello')],
    'pattern_fixed_equiv_equal_to': [StringPattern(pattern='^hello$'), StringEqualTo(value='hello')],
    'equal_to_ignore_case_identical': [
        StringEqualTo(value='Hello', ignore_case=True),
        StringEqualTo(value='hello', ignore_case=True),
    ],
    'contains_ignore_case_identical': [
        StringContains(value='hello', ignore_case=True),
        StringContains(value='hello', ignore_case=True),
    ],
    'pattern_ignore_case_identical': [
        StringPattern(pattern='hello.*', ignore_case=True),
        StringPattern(pattern='hello.*', ignore_case=True),
    ],
    'any_pattern_equiv_empty_contains': [StringPattern(pattern='.*'), StringContains(value='')],
    'empty_equal_to_empty_pattern': [StringEqualTo(value=''), StringPattern(pattern='^$')],
}

SUPERSETS = {
    'pattern_supset_equal_to': [StringPattern(pattern='hello(.*)'), StringEqualTo(value='hello123')],
    'contains_supset_equal_to': [StringContains(value='hello'), StringEqualTo(value='hello world')],
    'equal_to_ignore_case_supset_equal_to': [
        StringEqualTo(value='Hello', ignore_case=True),
        StringEqualTo(value='hello'),
    ],
    'pattern_ignore_case_supset_pattern': [
        StringPattern(pattern='Hello.*', ignore_case=True),
        StringPattern(pattern='hello.*'),
    ],
    'contains_empty_supset_contains_char': [StringContains(value=''), StringContains(value='a')],
    'any_supset_specific_string': [AnyPredicate(), StringEqualTo(value='specific')],
}

INTERSECTIONS = {
    'pattern_intersect_pattern': [
        StringPattern(pattern='hello world.*'),
        StringPattern(pattern='.*hello world'),  # "hello world" itself
    ],
    'contains_intersect_contains': [StringContains(value='hello'), StringContains(value='ello')],  # "hello"
    'pattern_ignore_case_intersect_pattern': [
        StringPattern(pattern='Hello world.*', ignore_case=True),
        StringPattern(pattern='.*Hello world'),  # "hello world" case insensitive
    ],
    'contains_ignore_case_intersect_contains': [
        StringContains(value='hello', ignore_case=True),
        StringContains(value='ElLo'),  # "hello" case insensitive
    ],
    'starts_with_apple_intersects_ends_with_apple': [
        StringPattern(pattern='^apple.*'),
        StringPattern(pattern='.*apple$'),  # "apple"
    ],
    'contains_a_intersects_contains_b_for_ab': [
        StringContains(value='a'),
        StringContains(value='b'),  # "ab", "banana", "table"
    ],
    'any_intersects_specific_string': [AnyPredicate(), StringEqualTo(value='test')],
}

NOT_INTERSECTIONS = {
    'equal_to_hello_cap_equal_to_world': [StringEqualTo(value='hello'), StringEqualTo(value='world')],
    'pattern_digits_only_cap_pattern_alpha_only': [
        StringPattern(pattern='^[0-9]+$'),
        StringPattern(pattern='^[a-zA-Z]+$'),
    ],
    'exact_foo_cap_exact_bar': [StringEqualTo(value="foo"), StringEqualTo(value="bar")],
}


class TestStringIsSubsetOf:
    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_one_equivalent_is_subset_of_another(self, p1, p2):
        assert p1.is_subset_of(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_subset_is_subset_of_superset(self, p1, p2):
        assert p2.is_subset_of(p1)  # p2 is subset, p1 is superset

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_superset_is_not_subset_of_subset(self, p1, p2):
        if not p1.is_equivalent_to(p2):
            assert not p1.is_subset_of(p2)  # p1 is superset, p2 is subset
        else:
            assert p1.is_subset_of(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_subset_of_equivalents_is_symmetric(self, p1, p2):
        assert p2.is_subset_of(p1)


class TestStringIsSupersetOf:
    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_superset_is_superset_of_subset(self, p1, p2):
        assert p1.is_superset_of(p2)  # p1 is superset, p2 is subset

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_subset_is_not_superset_of_superset(self, p1, p2):
        if not p2.is_equivalent_to(p1):
            assert not p2.is_superset_of(p1)  # p2 is subset, p1 is superset
        else:
            assert p2.is_superset_of(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_one_equivalent_is_superset_of_another(self, p1, p2):
        assert p1.is_superset_of(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_superset_of_equivalents_is_symmetric(self, p1, p2):
        assert p2.is_superset_of(p1)


class TestStringIsIntersectedWith:
    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(INTERSECTIONS))
    def test_intersections_are_intersected(self, p1, p2):
        assert p1.is_intersected_with(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(INTERSECTIONS))
    def test_intersections_are_symmetrical_intersected(self, p1, p2):
        assert p2.is_intersected_with(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_intersected(self, p1, p2):
        assert p1.is_intersected_with(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_symmetrically_intersected(self, p1, p2):
        assert p2.is_intersected_with(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_superset_and_subset_are_intersected(self, p1, p2):
        assert p2.is_intersected_with(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_subset_and_superset_are_symmetrically_intersectable(self, p1, p2):
        assert p1.is_intersected_with(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_not_intersections_are_not_intersected(self, p1, p2):
        assert not p1.is_intersected_with(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_not_intersections_are_symmetrically_not_intersected(self, p1, p2):
        assert not p2.is_intersected_with(p1)


class TestStringIsEquivalentTo:
    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_equivalent(self, p1, p2):
        assert p1.is_equivalent_to(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_symmetrically_equivalent(self, p1, p2):
        assert p2.is_equivalent_to(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_subset_is_not_equivalent_to_superset(self, p1, p2):
        if p1.is_equivalent_to(p2):
            return  # e.g. AnyPredicate
        assert not p2.is_equivalent_to(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_superset_is_not_equivalent_to_subset(self, p1, p2):
        if p1.is_equivalent_to(p2):
            return
        assert not p1.is_equivalent_to(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_non_intersecting_are_not_equivalent(self, p1, p2):
        assert not p1.is_equivalent_to(p2)


class TestStringPredicates:
    # StringEqualTo tests
    @pytest.mark.parametrize(
        ['value', 'test_value', 'ignore_case', 'expected'],
        [
            ['hello', 'hello', False, True],
            ['HELLO', 'hello', True, True],
            ['hello', 'world', False, False],
            ['HELLO', 'hello', False, False],
            ['', '', False, True],  # Empty string
            # ['hello', None, False, False], # Test with None
            ['hello', 123, False, False],  # Test with number
            [' leading', ' leading', False, True],
            ['trailing ', 'trailing ', False, True],
        ],
    )
    def test_string_equal_to(self, value, test_value, ignore_case, expected):
        predicate = StringEqualTo(value=value, ignore_case=ignore_case)
        assert predicate.is_matched(test_value) == expected

    # StringPattern tests
    @pytest.mark.parametrize(
        ['pattern', 'test_value', 'ignore_case', 'expected'],
        [
            ['hello.*', 'hello world', False, True],
            ['HELLO.*', 'hello world', True, True],
            ['hello.*', 'HELLO world', False, False],
            ['hello\\d+', 'hello123', False, True],
            ['hello\\d+', 'helloworld', False, False],
            ['^start$', 'start', False, True],  # Exact match pattern
            ['^$', '', False, True],  # Empty string pattern
            ['\d{3}-\d{3}', '123-456', False, True],  # More complex pattern
            ['.*', 'any string', False, True],
            ['(abc)+', 'abcabc', False, True],
            ['(abc)+', 'ab', False, False],
            # ['hello', None, False, False], # Test with None
        ],
    )
    def test_string_pattern(self, pattern, test_value, ignore_case, expected):
        predicate = StringPattern(pattern=pattern, ignore_case=ignore_case)
        # Test for invalid regex pattern (assuming it should not raise error during match but return False)
        # Or, if it should raise error, then test for that. Let's assume it returns False.
        try:
            re.compile(pattern)
        except re.error:
            if expected is not False:  # if an error is expected, this test is not for valid patterns
                pytest.skip("Skipping test with invalid regex for successful match expectation")
            assert not predicate.is_matched(test_value)  # Invalid pattern should not match
            return
        assert predicate.is_matched(test_value) == expected

    # StringContains tests
    @pytest.mark.parametrize(
        ['value', 'test_value', 'ignore_case', 'expected'],
        [
            ['llo', 'hello world', False, True],
            ['LLO', 'hello world', True, True],
            ['LLO', 'hello world', False, False],  # Case sensitive mismatch
            ['world', 'hello', False, False],
            ['', 'any string', False, True],  # Empty string is contained in any string
            ['string', '', False, False],  # Non-empty string not in empty string (unless value itself is empty)
            ['hello', 'hello', False, True],  # Exact match
            ['hello', 'prefixhelloSuffix', False, True],
            # ['substring', None, False, False], # Test with None
            ['你好', '世界你好', False, True],  # Unicode
        ],
    )
    def test_string_contains(self, value, test_value, ignore_case, expected):
        predicate = StringContains(value=value, ignore_case=ignore_case)
        assert predicate.is_matched(test_value) == expected

    # NotPredicate tests
    @pytest.mark.parametrize(
        ['predicate', 'test_value', 'expected'],
        [
            [StringEqualTo(value='hello'), 'hello', False],
            [StringEqualTo(value='hello'), 'world', True],
            [StringContains(value='llo'), 'hello', False],
            [StringContains(value='xyz'), 'hello', True],
            [StringPattern(pattern='^\\d+$'), '123', False],
            [StringPattern(pattern='^\\d+$'), 'abc', True],
        ],
    )
    def test_string_not(self, predicate, test_value, expected):
        not_predicate = NotPredicate(predicate=predicate)
        assert not_predicate.is_matched(test_value) == expected

    # AndPredicate tests
    @pytest.mark.parametrize(
        ['predicates', 'test_value', 'expected'],
        [
            [[StringEqualTo(value='hello'), StringContains(value='ell')], 'hello', True],
            [[StringEqualTo(value='hello'), StringContains(value='xyz')], 'hello', False],
            [[StringPattern(pattern='h.*o'), StringContains(value='ell')], 'hello', True],
            [[StringContains(value='a'), StringContains(value='b'), StringContains(value='c')], 'axbyc', True],
            [[StringContains(value='a'), StringContains(value='b'), StringContains(value='d')], 'axbyc', False],
        ],
    )
    def test_string_and(self, predicates, test_value, expected):
        and_predicate = AndPredicate(predicates=predicates)
        assert and_predicate.is_matched(test_value) == expected

    # OrPredicate tests
    @pytest.mark.parametrize(
        ['predicates', 'test_value', 'expected'],
        [
            [[StringEqualTo(value='hello'), StringContains(value='xyz')], 'hello', True],
            [[StringEqualTo(value='world'), StringContains(value='ell')], 'hello', True],
            [[StringEqualTo(value='world'), StringPattern(pattern='xyz.*')], 'hello', False],
            [[StringEqualTo(value='a'), StringEqualTo(value='b'), StringEqualTo(value='c')], 'b', True],
            [[StringEqualTo(value='x'), StringEqualTo(value='y'), StringEqualTo(value='z')], 'a', False],
            [[], "anything", False],  # Empty Or
        ],
    )
    def test_string_or(self, predicates, test_value, expected):
        or_predicate = OrPredicate(predicates=predicates)
        assert or_predicate.is_matched(test_value) == expected

    # AnyPredicate tests
    @pytest.mark.parametrize(
        'test_value',
        [
            'hello',
            '',
            '123_symbols_!@#',
            # None, # Should AnyPredicate match None for strings? Let's assume yes.
            123,  # Or even non-strings, if type check is lenient for Any.
        ],
    )
    def test_string_any(self, test_value):
        any_predicate = AnyPredicate()
        assert any_predicate.is_matched(test_value) is True
