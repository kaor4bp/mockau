# Generated by Gemini AI 2.5 Pro
import pytest

from core.predicates.logical.logical_predicates import AndPredicate, AnyPredicate, NotPredicate, OrPredicate
from core.predicates.scalars import (
    IntegerEqualTo,
    IntegerGreaterOrEqualThan,
    IntegerGreaterThan,
    IntegerLessThan,
    NumberEqualTo,
    NumberGreaterThan,
    NumberLessThan,
    StringContains,
    StringEqualTo,
    StringPattern,
)
from utils.formatters import get_params_argv

# Rebuild Pydantic models
NotPredicate.model_rebuild()
AndPredicate.model_rebuild()
OrPredicate.model_rebuild()
AnyPredicate.model_rebuild()

EQUIVALENTS = {
    'int_eq_1_or_str_contains_hello_equiv_compose': [
        OrPredicate(predicates=[IntegerEqualTo(value=1), StringContains(value='hello', max_length=10)]),
        OrPredicate(
            predicates=[
                AndPredicate(  # x = 1 representation
                    predicates=[
                        NotPredicate(predicate=IntegerGreaterThan(value=1)),
                        NotPredicate(predicate=IntegerLessThan(value=1)),
                    ]
                ),
                StringPattern(pattern='.*hello.*', max_length=10),  # contains 'hello' representation
            ]
        ),
    ],
    'de_morgan_not_A_and_B_equiv_not_A_or_not_B': [
        NotPredicate(predicate=AndPredicate(predicates=[IntegerGreaterThan(value=5), IntegerLessThan(value=10)])),
        OrPredicate(
            predicates=[
                NotPredicate(predicate=IntegerGreaterThan(value=5)),  # x <= 5
                NotPredicate(predicate=IntegerLessThan(value=10)),  # x >= 10
            ]
        ),  # So, x <= 5 or x >= 10
    ],
    'de_morgan_not_A_or_B_equiv_not_A_and_not_B': [
        NotPredicate(predicate=OrPredicate(predicates=[IntegerEqualTo(value=0), IntegerEqualTo(value=1)])),
        AndPredicate(
            predicates=[
                NotPredicate(predicate=IntegerEqualTo(value=0)),  # x != 0
                NotPredicate(predicate=IntegerEqualTo(value=1)),  # x != 1
            ]
        ),  # So, x != 0 AND x != 1
    ],
    'double_negation_of_and': [
        NotPredicate(predicate=NotPredicate(predicate=AndPredicate(predicates=[IntegerEqualTo(value=1)]))),
        AndPredicate(predicates=[IntegerEqualTo(value=1)]),
    ],
    # 'any_is_any': [AnyPredicate(), AnyPredicate()],
    # 'not_any_is_never': [ # Assuming Not(Any) means it matches nothing.
    #     NotPredicate(predicate=AnyPredicate()),
    #     AndPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=2)]) # Represents an impossible condition
    # ]
}

SUPERSETS = {
    'or_int_str_supset_int_part': [
        OrPredicate(predicates=[IntegerEqualTo(value=1), StringContains(value='hello')]),
        IntegerEqualTo(value=1),  # x=1 is a subset of (x=1 or contains 'hello')
    ],
    'or_int_str_supset_str_part': [
        OrPredicate(predicates=[IntegerEqualTo(value=1), StringContains(value='hello')]),
        StringContains(value='hello'),  # contains 'hello' is a subset of (x=1 or contains 'hello')
    ],
    'range_1_le_x_lt_5_supset_1_lt_x_lt_5_int': [  # From original, kept for integer range logic
        AndPredicate(
            predicates=[
                IntegerGreaterOrEqualThan(value=1),
                IntegerLessThan(value=5),
            ]
        ),
        AndPredicate(predicates=[IntegerGreaterThan(value=1), IntegerLessThan(value=5)]),
    ],
    # 'any_supset_specific_and': [
    #     AnyPredicate(),
    #     AndPredicate(predicates=[IntegerEqualTo(value=5), StringEqualTo(value="test")])
    # ],
    # 'and_A_B_supset_and_A_B_C': [
    #     AndPredicate(predicates=[IntegerGreaterThan(value=0), StringContains(value="log")]),
    #     AndPredicate(predicates=[IntegerGreaterThan(value=0), StringContains(value="log"), NumberGreaterThan(value=0.0)])
    # ]
}

INTERSECTIONS = {
    'or_int_gt5_or_str_eq_world_CAP_or_int_lt3_or_str_contains_world': [
        OrPredicate(  # P1: (x > 5) or (s == "world")
            predicates=[
                IntegerGreaterThan(value=5),
                StringEqualTo(value='world'),
            ]
        ),
        OrPredicate(  # P2: (x < 3) or (s contains "world")
            predicates=[
                IntegerLessThan(value=3),
                StringContains(value='world'),
            ]
        ),
        # Intersection: (x > 5 AND s contains "world") OR (s == "world" AND x < 3) OR (s == "world" AND s contains "world")
        # This should intersect if a value like "world" is given, or an object {int_field: Y, str_field: "world"}
    ],
    'and_gt0_lt10_CAP_and_gt5_lt15_for_int': [
        AndPredicate(predicates=[IntegerGreaterThan(value=0), IntegerLessThan(value=10)]),  # (0, 10)
        AndPredicate(predicates=[IntegerGreaterThan(value=5), IntegerLessThan(value=15)]),  # (5, 15)
        # Intersection is (5, 10)
    ],
    # 'any_intersects_not_any_is_false': [ # Any intersects with Not(Any) should be false if Not(Any) is impossible
    #     AnyPredicate(),
    #     NotPredicate(predicate=AnyPredicate())
    #     # This test depends on how Not(AnyPredicate) is defined. If Not(Any) is truly nothing, they don't intersect.
    #     # However, the methods usually check if *some* value could satisfy both.
    #     # Let's assume 'is_intersected_with' means 'can they both be true for some value'.
    #     # Not(Any) is never true, so this should not intersect.
    # ],
    'A_or_B_intersects_A': [
        OrPredicate(predicates=[IntegerEqualTo(value=10), StringEqualTo(value="A")]),
        IntegerEqualTo(value=10),
    ],
}

NOT_INTERSECTIONS = {
    'int_eq_1_cap_str_eq_a': [  # Assuming single value context, cannot be both int and string
        IntegerEqualTo(value=1),
        StringEqualTo(value="a"),
    ],
    'int_gt_10_cap_int_lt_0': [IntegerGreaterThan(value=10), IntegerLessThan(value=0)],
    'always_true_predicate_cap_always_false_predicate': [
        AnyPredicate(),  # Actually, this might be tricky. AnyPredicate intersects with anything that's not "Nothing".
        # Let's refine this.
        AndPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=2)]),  # This is "Nothing"
    ],
    'not_any_does_not_intersect_with_specific_condition': [
        NotPredicate(predicate=AnyPredicate()),  # Represents "matches nothing"
        IntegerEqualTo(value=5),
    ],
}


class TestLogicalPredicateIsSubsetOf:  # Renamed class
    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(EQUIVALENTS))
    def test_one_equivalent_is_subset_of_another(self, m1, m2):
        assert m1.is_subset_of(m2)

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(SUPERSETS))
    def test_subset_is_subset_of_superset(self, m1, m2):  # m2 is subset of m1
        assert m2.is_subset_of(m1)

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(SUPERSETS))
    def test_superset_is_not_subset_of_subset(self, m1, m2):  # m1 is superset of m2
        if not m1.is_equivalent_to(m2):
            assert not m1.is_subset_of(m2)
        else:
            assert m1.is_subset_of(m2)

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(EQUIVALENTS))
    def test_subset_of_equivalents_is_symmetric(self, m1, m2):
        assert m2.is_subset_of(m1)


class TestLogicalPredicateIsSupersetOf:  # Renamed class
    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(SUPERSETS))
    def test_superset_is_superset_of_subset(self, m1, m2):  # m1 is superset of m2
        assert m1.is_superset_of(m2)

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(SUPERSETS))
    def test_subset_is_not_superset_of_superset(self, m1, m2):  # m2 is subset of m1
        if not m2.is_equivalent_to(m1):
            assert not m2.is_superset_of(m1)
        else:
            assert m2.is_superset_of(m1)

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(EQUIVALENTS))
    def test_one_equivalent_is_superset_of_another(self, m1, m2):
        assert m1.is_superset_of(m2)

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(EQUIVALENTS))
    def test_superset_of_equivalents_is_symmetric(self, m1, m2):
        assert m2.is_superset_of(m1)


class TestLogicalPredicateIsIntersectedWith:  # Renamed class
    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(INTERSECTIONS))
    def test_intersections_are_intersected(self, m1, m2):
        # The intersection for "any_intersects_not_any_is_false" depends on definition
        # If Not(Any) is a predicate that never matches, then intersection is false.
        if m2 == NotPredicate(predicate=AnyPredicate()) and m1 == AnyPredicate():
            assert not m1.is_intersected_with(m2), "AnyPredicate should not intersect with Not(AnyPredicate)"
            return
        assert m1.is_intersected_with(m2)

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(INTERSECTIONS))
    def test_intersections_are_symmetrical_intersected(self, m1, m2):
        if m1 == NotPredicate(predicate=AnyPredicate()) and m2 == AnyPredicate():
            assert not m2.is_intersected_with(m1), (
                "AnyPredicate should not intersect with Not(AnyPredicate) symmetrically"
            )
            return
        assert m2.is_intersected_with(m1)

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_intersected(self, m1, m2):
        assert m1.is_intersected_with(m2)

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_symmetrically_intersected(self, m1, m2):
        assert m2.is_intersected_with(m1)

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(SUPERSETS))
    def test_superset_and_subset_are_intersected(self, m1, m2):
        assert m2.is_intersected_with(m1)

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(SUPERSETS))
    def test_subset_and_superset_are_symmetrically_intersectable(self, m1, m2):
        assert m1.is_intersected_with(m2)

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_not_intersections_are_not_intersected(self, m1, m2):
        assert not m1.is_intersected_with(m2)

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_not_intersections_are_symmetrically_not_intersected(self, m1, m2):
        assert not m2.is_intersected_with(m1)


class TestLogicalPredicateIsEquivalentTo:  # Renamed class
    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_equivalent(self, m1, m2):
        assert m1.is_equivalent_to(m2)

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_symmetrically_equivalent(self, m1, m2):
        assert m2.is_equivalent_to(m1)

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(SUPERSETS))
    def test_subset_is_not_equivalent_to_superset(self, m1, m2):
        if m1.is_equivalent_to(m2):
            return
        assert not m2.is_equivalent_to(m1)  # m2 is subset of m1

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(SUPERSETS))
    def test_superset_is_not_equivalent_to_subset(self, m1, m2):
        if m1.is_equivalent_to(m2):
            return
        assert not m1.is_equivalent_to(m2)  # m1 is superset of m2

    @pytest.mark.parametrize(['m1', 'm2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_non_intersecting_are_not_equivalent(self, m1, m2):
        assert not m1.is_equivalent_to(m2)


# Removed the duplicated TestIntegerPredicates class
# Add new TestLogicalPredicates for is_matched specific to logical ones


class TestLogicalPredicatesIsMatched:
    # NotPredicate tests
    @pytest.mark.parametrize(
        ['predicate_to_negate', 'test_value', 'expected_not_matched'],
        [
            [IntegerEqualTo(value=5), 5, False],
            [IntegerEqualTo(value=5), 6, True],
            [StringContains(value="test"), "this is a test", False],
            [StringContains(value="test"), "no match", True],
            [AnyPredicate(), "any value", False],  # Not(Any) is False
            [
                AndPredicate(predicates=[IntegerEqualTo(value=1), IntegerEqualTo(value=2)]),
                1,
                True,
            ],  # Not(False) is True
        ],
    )
    def test_not_predicate(self, predicate_to_negate, test_value, expected_not_matched):
        not_predicate = NotPredicate(predicate=predicate_to_negate)
        assert not_predicate.is_matched(test_value) == expected_not_matched

    # AndPredicate tests
    @pytest.mark.parametrize(
        ['predicates_list', 'test_value_int', 'test_value_str', 'test_value_num', 'expected_matched'],
        [
            # Test with integers
            [[IntegerGreaterThan(value=0), IntegerLessThan(value=10)], 5, None, None, True],
            [[IntegerGreaterThan(value=0), IntegerLessThan(value=5)], 5, None, None, False],
            # Test with strings
            [[StringContains(value="a"), StringPattern(pattern="^ax.*")], None, "axy", None, True],
            [[StringContains(value="a"), StringEqualTo(value="b")], None, "a", None, False],
            # Test with numbers
            [[NumberGreaterThan(value=0.0), NumberLessThan(value=1.0)], None, None, 0.5, True],
            # Test with mixed types (typically for object matching, but here assume single value context means false)
            [
                [IntegerEqualTo(value=5), StringEqualTo(value="hello")],
                5,
                "hello",
                None,
                False,
            ],  # Single value cannot be both int and string
            # # Test with empty list of predicates
            # [[], 123, "abc", 1.23, True], # And of no conditions is True
            # Test with one predicate
            [[IntegerEqualTo(value=7)], 7, None, None, True],
        ],
    )
    def test_and_predicate(self, predicates_list, test_value_int, test_value_str, test_value_num, expected_matched):
        and_predicate = AndPredicate(predicates=predicates_list)
        test_value = None
        if test_value_int is not None:
            test_value = test_value_int
        elif test_value_str is not None:
            test_value = test_value_str
        elif test_value_num is not None:
            test_value = test_value_num
        else:  # If all specific test_values are None, use a generic one for empty predicate list or if predicates are Any
            test_value = "generic_value_for_empty_pred_test" if not predicates_list else None

        # A single value is_matched context. If predicates target different types, And will be false.
        # This test setup is a bit complex because And can contain different types.
        # The original tests for AndPredicate in e.g. test_integer_predicates only use integer predicates.
        # For a more robust test of AndPredicate with heterogeneous inner predicates,
        # it would typically be used with ObjectPredicates where each predicate applies to a field.
        # Here, we assume 'is_matched' gets a single value.
        if (
            len(predicates_list) > 1
            and any(isinstance(p, (StringEqualTo, StringContains, StringPattern)) for p in predicates_list)
            and any(isinstance(p, (IntegerEqualTo, IntegerGreaterThan)) for p in predicates_list)
        ):
            assert (
                and_predicate.is_matched(test_value if test_value is not None else 5) is False
            )  # Cannot satisfy both int and string with one value
        elif test_value is not None:
            assert and_predicate.is_matched(test_value) == expected_matched
        elif not predicates_list:  # handles empty list case if no specific value was chosen
            assert and_predicate.is_matched("anything") == expected_matched

    # OrPredicate tests
    @pytest.mark.parametrize(
        ['predicates_list', 'test_value_int', 'test_value_str', 'test_value_num', 'expected_matched'],
        [
            [[IntegerEqualTo(value=5), IntegerEqualTo(value=10)], 5, None, None, True],
            [[IntegerEqualTo(value=5), IntegerEqualTo(value=10)], 7, None, None, False],
            [[StringEqualTo(value="a"), StringEqualTo(value="b")], None, "b", None, True],
            [[StringEqualTo(value="a"), StringEqualTo(value="b")], None, "c", None, False],
            [[NumberEqualTo(value=1.0), NumberGreaterThan(value=5.0)], None, None, 5.5, True],
            # Mixed types - Or can be true if one matches
            [[IntegerEqualTo(value=5), StringEqualTo(value="hello")], 5, None, None, True],
            [[IntegerEqualTo(value=5), StringEqualTo(value="hello")], None, "hello", None, True],
            [[IntegerEqualTo(value=5), StringEqualTo(value="hello")], 6, "world", None, False],
            [[], 123, "abc", 1.23, False],  # Or of no conditions is False
            [[StringPattern(pattern="^\\d+$")], None, "123", None, True],  # Single predicate in list
        ],
        ids=lambda x: repr(x),
    )
    def test_or_predicate(self, predicates_list, test_value_int, test_value_str, test_value_num, expected_matched):
        or_predicate = OrPredicate(predicates=predicates_list)
        test_value = None
        if test_value_int is not None:
            test_value = test_value_int
        elif test_value_str is not None:
            test_value = test_value_str
        elif test_value_num is not None:
            test_value = test_value_num
        else:  # If all specific test_values are None, use a generic one for empty predicate list
            test_value = "generic_value_for_empty_pred_test" if not predicates_list else None

        # For OR, if any predicate matches the type of the test_value, it's fine.
        # This logic gets complex if test_value itself is None for the empty list case.
        if test_value is not None:
            assert or_predicate.is_matched(test_value) == expected_matched
        elif not predicates_list:  # handles empty list if no specific value was chosen
            assert or_predicate.is_matched("anything") == expected_matched

    # AnyPredicate tests
    @pytest.mark.parametrize('test_value', [123, "string", 0.0, True, None, [1, 2, 3]], ids=lambda x: str(x))
    def test_any_predicate(self, test_value):
        any_predicate = AnyPredicate()
        assert any_predicate.is_matched(test_value) is True
