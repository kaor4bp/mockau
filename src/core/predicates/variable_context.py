from abc import ABC

import z3

from core.predicates.base_predicate import PredicateType
from core.predicates.json_datatype import JsonDatatype


class _Undefined:
    pass


class BaseVariableContext(ABC):
    def __init__(self, level=0, prefix: str = 'var', parent=None) -> None:
        """Initialize variable context.

        :param level: Nesting level for JSON (None for max level)
        :type level: int | None

        .. Docstring generated by Gemini 2.5 Flash, modified by Gemini 2.5 Flash
        """
        self._parent = parent
        self._children = []
        self._global_constraints = []
        self._var_type_constraints = {}
        self._json_var = JsonDatatype(level=level, prefix=prefix)

        self._variables_by_type_mapping = {
            PredicateType.String: self._json_var.get_str(),
            PredicateType.Integer: self._json_var.get_int(),
            PredicateType.Real: self._json_var.get_real(),
            PredicateType.Boolean: self._json_var.get_bool(),
            PredicateType.Object: self._json_var.get_object(),
            PredicateType.Array: self._json_var.get_array(),
            PredicateType.Null: None,
            PredicateType.Any: None,
            PredicateType.Undefined: None,
        }

        self._type_expressions_by_type_mapping = {
            PredicateType.String: self._json_var.is_str(),
            PredicateType.Integer: self._json_var.is_int(),
            PredicateType.Real: self._json_var.is_real(),
            PredicateType.Boolean: self._json_var.is_bool(),
            PredicateType.Object: self._json_var.is_object(),
            PredicateType.Array: self._json_var.is_array(),
            PredicateType.Null: self._json_var.is_null(),
            PredicateType.Undefined: self._json_var.is_undefined(),
        }

    @property
    def json_type_variable(self) -> JsonDatatype:
        """Get JSON datatype variable.

        :return: JSON datatype instance
        :rtype: JsonDatatype

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_var

    def create_child_context(self, prefix: str = 'var') -> 'VariableContext':
        """Create nested variable context with reduced level.

        :return: New child context
        :rtype: VariableContext

        .. Docstring generated by Gemini 2.5 Flash, modified by Gemini 2.5 Flash
        """
        new_child_context = VariableContext(level=self.json_type_variable.level + 1, prefix=prefix, parent=self)
        self._children.append(new_child_context)
        return new_child_context

    @property
    def parent(self):
        return self._parent

    @property
    def root_parent(self):
        if self._parent is None:
            return self
        return self._parent.root_parent


class EvaluateValueMixin(BaseVariableContext):
    def __init__(self, level=0, prefix: str = 'var', parent=None) -> None:
        super().__init__(level=level, prefix=prefix, parent=parent)
        self._key_vars = []

    def register_key_var(self, key_var):
        self._key_vars.append(key_var)

    def _get_all_possible_keys(self, solver):
        results = [solver.model().eval(key_var, model_completion=True).as_string() for key_var in self._key_vars]
        for child in self._children:
            results += child._get_all_possible_keys(solver)
        return results

    def _guess_type(self, solver, var):
        for level in reversed(range(100)):
            try:
                json_var = JsonDatatype.from_var(solver.model().eval(var, model_completion=True), level=level)
                solver.model().eval(
                    json_var.is_object(),
                    model_completion=True,
                )
            except z3.Z3Exception:
                pass
            else:
                fake_context = self.__class__()
                fake_context._json_var = json_var
                return fake_context.evaluate_value(solver)

    def _calculate_var_values(self, solver: z3.Solver):
        results = {}
        for child in self._children:
            results.update(child._calculate_var_values(solver))

        raw_val = solver.model().eval(self._json_var.z3_variable, model_completion=True).ast.value

        if solver.model().eval(self._json_var.is_int(), model_completion=True):
            results[raw_val] = solver.model().eval(self._json_var.get_int(), model_completion=True).as_long()
        if solver.model().eval(self._json_var.is_str(), model_completion=True):
            results[raw_val] = solver.model().eval(self._json_var.get_str(), model_completion=True).as_string()
        if solver.model().eval(self._json_var.is_real(), model_completion=True):
            results[raw_val] = solver.model().eval(self._json_var.get_real(), model_completion=True).as_decimal(10)
        if solver.model().eval(self._json_var.is_bool(), model_completion=True):
            results[raw_val] = solver.model().eval(self._json_var.get_bool(), model_completion=True)
        if solver.model().eval(self._json_var.is_object(), model_completion=True):
            sub_result = {}
            for key in self._get_all_possible_keys(solver):
                if key:
                    var_id = solver.model().eval(z3.Select(self._json_var.get_object(), z3.StringVal(key))).ast.value
                    if var_id not in results.keys():
                        guessed_type = self._guess_type(
                            solver=solver,
                            var=solver.model().eval(
                                z3.Select(self._json_var.get_object(), z3.StringVal(key)),
                                model_completion=True,
                            ),
                        )
                        if guessed_type is not _Undefined:
                            sub_result[key] = guessed_type
                    elif results[var_id] is not _Undefined:
                        sub_result[key] = results[var_id]
                else:
                    break
            results[raw_val] = sub_result
        if solver.model().eval(self._json_var.is_array(), model_completion=True):
            sub_result = []
            array_len = solver.model().eval(z3.Length(self._json_var.get_array()), model_completion=True).as_long()
            for i in range(array_len):
                var_id = solver.model().eval(self._json_var.get_array()[i]).ast.value
                if var_id not in results.keys():
                    sub_result.append(
                        self._guess_type(
                            solver=solver, var=solver.model().eval(self._json_var.get_array()[i], model_completion=True)
                        )
                    )
                else:
                    sub_result.append(results[var_id])
            results[raw_val] = sub_result
        if solver.model().eval(self._json_var.is_null(), model_completion=True):
            results[raw_val] = None
        if solver.model().eval(self._json_var.is_undefined(), model_completion=True):
            results[raw_val] = _Undefined

        return results

    def evaluate_value(self, solver: z3.Solver):
        calculated_values = self._calculate_var_values(solver)
        var_id = solver.model().eval(self._json_var.z3_variable, model_completion=True).ast.value
        return calculated_values.get(var_id, _Undefined)  # known issue in some cases


class HandleUnboundedLengthMixin(BaseVariableContext):
    def __init__(self, level=0, prefix: str = 'var', parent=None) -> None:
        super().__init__(level=level, prefix=prefix, parent=parent)
        self._arrays_with_unbounded_length = []
        self._strings_with_unbounded_length = []
        self._default_array_len = 0
        self._default_string_len = 0

        if self._parent is None:
            self._max_nesting_level = 1

    def _get_unbounded_array_len(self):
        return max([c._get_unbounded_array_len() for c in self._children] + [self._default_array_len])

    def _get_unbounded_string_len(self):
        return max([c._get_unbounded_string_len() for c in self._children] + [self._default_string_len])

    def set_array_len(self, array_len: int):
        self._default_array_len = max(array_len, self._default_array_len)

    def add_unbounded_array(self, array_var):
        self._arrays_with_unbounded_length.append(array_var)

    def set_string_len(self, string_len: int):
        self._default_string_len = max(string_len, self._default_string_len)

    def add_unbounded_string(self, string_var):
        self._strings_with_unbounded_length.append(string_var)

    def get_unbounded_constraints(self):
        constraints = []
        for array_var in self._arrays_with_unbounded_length:
            constraints.append(z3.Length(array_var) <= self.root_parent._get_unbounded_array_len())
        for string_var in self._strings_with_unbounded_length:
            constraints.append(z3.Length(string_var) <= self.root_parent._get_unbounded_string_len())
        for c in self._children:
            constraints += c.get_unbounded_constraints()
        return constraints

    def set_max_nesting_level(self, level: int):
        self.root_parent._max_nesting_level = level

    def get_max_nesting_level(self):
        return self.root_parent._max_nesting_level


class VariableContext(HandleUnboundedLengthMixin, EvaluateValueMixin, BaseVariableContext):
    """Context manager for Z3 variables and constraints.

    Manages variable types, constraints, and nested contexts for predicate evaluation.

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    def __del__(self):
        for child in self._children:
            del child
        self._children.clear()

    def push_to_global_constraints(self, expr: z3.ExprRef | bool) -> None:
        """Add constraint to global context.

        :param expr: Z3 expression or boolean to add
        :type expr: z3.ExprRef | bool

        .. Docstring created by Gemini 2.5 Flash
        """
        constraint_expression = expr
        self._global_constraints.append(constraint_expression)

    def get_variable(self, predicate_type: PredicateType):
        """Get variable cast to specified type with type constraint.

        :param predicate_type: Target predicate type
        :type predicate_type: PredicateType
        :return: Z3 variable of specified type
        :rtype: z3.ExprRef
        :raises NotImplementedError: For unsupported predicate types

        .. Docstring created by Gemini 2.5 Flash
        """
        if predicate_type not in self._var_type_constraints.keys():
            self._var_type_constraints[predicate_type] = self._generate_type_expression(predicate_type)

        if predicate_type in self._variables_by_type_mapping.keys():
            z3_variable = self._variables_by_type_mapping[predicate_type]
            return z3_variable
        raise NotImplementedError(f'get_variable for predicate type {predicate_type} not implemented yet')

    def _generate_type_expression(self, predicate_type: PredicateType) -> z3.BoolRef:
        """Generate type constraint expression.

        :param predicate_type: Target predicate type
        :type predicate_type: PredicateType
        :return: Z3 boolean type constraint
        :rtype: z3.BoolRef

        .. Docstring created by Gemini 2.5 Flash
        """
        type_expressions = [
            current_type_expr
            if current_type == predicate_type or predicate_type is PredicateType.Any
            else z3.Not(current_type_expr)
            for current_type, current_type_expr in self._type_expressions_by_type_mapping.items()
        ]
        if predicate_type is PredicateType.Any:
            combined_type_expression = z3.Or(type_expressions)
        else:
            combined_type_expression = z3.And(type_expressions)
        return combined_type_expression

    def to_global_constraints(self) -> z3.BoolRef:
        """Combine all global constraints into single expression.

        :return: Combined Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring created by Gemini 2.5 Flash
        """

        variable_type_expressions = list(self._var_type_constraints.values())
        if not variable_type_expressions:
            type_union_expression = z3.BoolVal(True)
        else:
            type_union_expression = z3.PbEq([(v, 1) for v in variable_type_expressions], 1)
            # type_union_expression = variable_type_expressions[0]
            # for current_type_expression in variable_type_expressions[1:]:
            #     type_union_expression = z3.Xor(type_union_expression, current_type_expression)

        unbounded_constraints = self.get_unbounded_constraints()

        nested_context_constraints = [child.to_global_constraints() for child in self._children]

        return z3.And(
            type_union_expression,
            *self._global_constraints,
            *unbounded_constraints,
            *nested_context_constraints,
        )
