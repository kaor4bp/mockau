from abc import ABC
from typing import Self

import z3
from pydantic import BaseModel

from core.predicates.base_predicate import PredicateType
from core.predicates.json_datatype import JsonDatatype


class _Undefined:
    pass


class PredicateLimitations(BaseModel):
    max_nesting_level: int = 1
    max_array_size: int = 1
    max_string_len: int = 10

    level_gte: int | None = 0
    level_lte: int | None = 0

    next: 'PredicateLimitations | None' = None
    prev: 'PredicateLimitations | None' = None

    @classmethod
    def unknown(cls):
        return cls(
            max_string_len=3,
            max_array_size=10,
            max_nesting_level=1000,
            level_gte=None,
            level_lte=None,
        )

    def push(self: Self, limitation: 'PredicateLimitations') -> Self:
        if self.next is None:
            self.next = limitation._get_root()
            limitation._get_root().prev = self
        else:
            self.next.push(limitation)
        return self

    def _get_root(self):
        if self.prev is not None:
            return self.prev._get_root()
        else:
            return self

    def _get_all(self):
        limitations = [self]
        if self.next:
            limitations += self.next._get_all()
        return limitations

    def get_for_level(self, level: int) -> Self:
        all_limitations = self._get_root()._get_all()
        matched_limitations = []

        for limitation in all_limitations:
            if (limitation.level_gte is not None and limitation.level_gte < level) or (
                limitation.level_lte is not None and limitation.level_lte > level
            ):
                continue
            else:
                matched_limitations.append(limitation)

        limitation = self._union_limitations(matched_limitations)
        limitation.level_lte = level
        limitation.level_gte = level
        limitation.max_nesting_level = self.get_max_level()
        return limitation

    def get_max_level(self):
        cur_limit = self._get_root()
        max_level = 0
        while cur_limit:
            if cur_limit.level_lte is not None:
                max_level = max(max_level, cur_limit.level_lte)
            if cur_limit.level_gte is not None:
                max_level = max(max_level, cur_limit.level_gte)
            cur_limit = cur_limit.next

        return max_level

    def increment_level(self, reset_level_lte: bool = False) -> Self:
        cur_limit = self._get_root()
        while cur_limit:
            if cur_limit.level_lte is not None:
                cur_limit.level_lte += 1
            if cur_limit.level_gte is not None:
                cur_limit.level_gte += 1
            if reset_level_lte:
                cur_limit.level_lte = None
            cur_limit = cur_limit.next

        return self

    @classmethod
    def _union_limitations(cls, limitations: 'list[PredicateLimitations]') -> 'PredicateLimitations':
        limitations.append(cls())
        return cls(
            max_nesting_level=max([limitation.max_nesting_level for limitation in limitations]),
            max_array_size=max([limitation.max_array_size for limitation in limitations]),
            max_string_len=max([limitation.max_string_len for limitation in limitations]),
        )


class BaseVariableContext(ABC):
    @property
    def is_root(self):
        return self._parent is None

    def __init__(self, level: int = 0, prefix: str = 'var', parent=None) -> None:
        """Initialize variable context.

        :param level: Nesting level for JSON (None for max level)
        :type level: int | None

        .. Docstring generated by Gemini 2.5 Flash, modified by Gemini 2.5 Flash
        """

        if parent is None and level >= 0:
            self._parent = VariableContext(level=-1)
        else:
            self._parent = parent

        self._children: list[VariableContext] = []
        self._global_constraints = []

        self._var_type_constraints = {}

        if not self.is_root:
            self._json_var = JsonDatatype(level=level, prefix=prefix)

            self._variables_by_type_mapping = {
                PredicateType.String: self._json_var.get_str(),
                PredicateType.Integer: self._json_var.get_int(),
                PredicateType.Real: self._json_var.get_real(),
                PredicateType.Boolean: self._json_var.get_bool(),
                PredicateType.Object: self._json_var.get_object(),
                PredicateType.Array: self._json_var.get_array(),
                PredicateType.Null: None,
                PredicateType.Any: None,
                PredicateType.Undefined: None,
            }

            self._type_expressions_by_type_mapping = {
                PredicateType.String: self._json_var.is_str(),
                PredicateType.Integer: self._json_var.is_int(),
                PredicateType.Real: self._json_var.is_real(),
                PredicateType.Boolean: self._json_var.is_bool(),
                PredicateType.Object: self._json_var.is_object(),
                PredicateType.Array: self._json_var.is_array(),
                PredicateType.Null: self._json_var.is_null(),
                PredicateType.Undefined: self._json_var.is_undefined(),
            }

    @property
    def json_type_variable(self) -> JsonDatatype:
        """Get JSON datatype variable.

        :return: JSON datatype instance
        :rtype: JsonDatatype

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_var

    def create_child_context(self, prefix: str = 'var') -> 'VariableContext':
        """Create nested variable context with reduced level.

        :return: New child context
        :rtype: VariableContext

        .. Docstring generated by Gemini 2.5 Flash, modified by Gemini 2.5 Flash
        """
        if self.is_root:
            new_child_context = VariableContext(level=0, prefix=prefix, parent=self)
        else:
            new_child_context = VariableContext(level=self.json_type_variable.level + 1, prefix=prefix, parent=self)
        self._children.append(new_child_context)
        return new_child_context

    def create_sibling_context(self, prefix: str = 'var') -> 'VariableContext':
        return self._parent.create_child_context(prefix=prefix)

    @property
    def parent(self):
        return self._parent

    @property
    def root_parent(self):
        if self._parent is None:
            return self
        else:
            return self._parent.root_parent


class EvaluateValueMixin(BaseVariableContext):
    def __init__(self, level=0, prefix: str = 'var', parent=None) -> None:
        super().__init__(level=level, prefix=prefix, parent=parent)
        self._key_vars = []

    def register_key_var(self, key_var):
        self._key_vars.append(key_var)

    def _get_all_possible_keys(self, solver):
        results = [solver.model().eval(key_var, model_completion=True).as_string() for key_var in self._key_vars]
        for child in self._children:
            results += child._get_all_possible_keys(solver)
        return results

    def _guess_type(self, solver, var):
        for level in reversed(range(100)):
            try:
                json_var = JsonDatatype.from_var(solver.model().eval(var, model_completion=True), level=level)
                solver.model().eval(
                    json_var.is_object(),
                    model_completion=True,
                )
            except z3.Z3Exception:
                pass
            else:
                fake_context = self.__class__()
                fake_context._json_var = json_var
                return fake_context.evaluate_value(solver)

    def _calculate_var_values(self, solver: z3.Solver):
        results = {}
        for child in self._children:
            results.update(child._calculate_var_values(solver))

        raw_val = solver.model().eval(self._json_var.z3_variable, model_completion=True).ast.value

        if solver.model().eval(self._json_var.is_int(), model_completion=True):
            results[raw_val] = solver.model().eval(self._json_var.get_int(), model_completion=True).as_long()
        if solver.model().eval(self._json_var.is_str(), model_completion=True):
            results[raw_val] = solver.model().eval(self._json_var.get_str(), model_completion=True).as_string()
        if solver.model().eval(self._json_var.is_real(), model_completion=True):
            results[raw_val] = solver.model().eval(self._json_var.get_real(), model_completion=True).as_decimal(10)
        if solver.model().eval(self._json_var.is_bool(), model_completion=True):
            results[raw_val] = solver.model().eval(self._json_var.get_bool(), model_completion=True)
        if solver.model().eval(self._json_var.is_object(), model_completion=True):
            sub_result = {}
            for key in self._get_all_possible_keys(solver):
                if key:
                    var_id = solver.model().eval(z3.Select(self._json_var.get_object(), z3.StringVal(key))).ast.value
                    if var_id not in results.keys():
                        guessed_type = self._guess_type(
                            solver=solver,
                            var=solver.model().eval(
                                z3.Select(self._json_var.get_object(), z3.StringVal(key)),
                                model_completion=True,
                            ),
                        )
                        if guessed_type is not _Undefined:
                            sub_result[key] = guessed_type
                    elif results[var_id] is not _Undefined:
                        sub_result[key] = results[var_id]
                else:
                    break
            results[raw_val] = sub_result
        if solver.model().eval(self._json_var.is_array(), model_completion=True):
            sub_result = []
            array_len = solver.model().eval(z3.Length(self._json_var.get_array()), model_completion=True).as_long()
            for i in range(array_len):
                var_id = solver.model().eval(self._json_var.get_array()[i]).ast.value
                if var_id not in results.keys():
                    sub_result.append(
                        self._guess_type(
                            solver=solver, var=solver.model().eval(self._json_var.get_array()[i], model_completion=True)
                        )
                    )
                else:
                    sub_result.append(results[var_id])
            results[raw_val] = sub_result
        if solver.model().eval(self._json_var.is_null(), model_completion=True):
            results[raw_val] = None
        if solver.model().eval(self._json_var.is_undefined(), model_completion=True):
            results[raw_val] = _Undefined

        return results

    def evaluate_value(self, solver: z3.Solver):
        calculated_values = self._calculate_var_values(solver)
        var_id = solver.model().eval(self._json_var.z3_variable, model_completion=True).ast.value
        return calculated_values.get(var_id, _Undefined)  # known issue in some cases


class HandleUnboundedLengthMixin(BaseVariableContext):
    def __init__(self, level=0, prefix: str = 'var', parent=None) -> None:
        super().__init__(level=level, prefix=prefix, parent=parent)
        if self.is_root:
            self._limitations = None

    def get_limitations(self) -> PredicateLimitations:
        if self.root_parent._limitations is None:
            return PredicateLimitations.unknown()
        else:
            return self.root_parent._limitations.get_for_level(self.json_type_variable.level)

    def set_limitations(self, limitations: PredicateLimitations):
        if self.root_parent._limitations:
            self.root_parent._limitations.push(limitations)
        else:
            self.root_parent._limitations = limitations


class VariableContext(HandleUnboundedLengthMixin, EvaluateValueMixin, BaseVariableContext):
    """Context manager for Z3 variables and constraints.

    Manages variable types, constraints, and nested contexts for predicate evaluation.

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    def __del__(self):
        for child in self._children:
            del child
        self._children.clear()

    def push_to_global_constraints(self, expr: z3.ExprRef | bool) -> None:
        """Add constraint to global context.

        :param expr: Z3 expression or boolean to add
        :type expr: z3.ExprRef | bool

        .. Docstring created by Gemini 2.5 Flash
        """
        constraint_expression = expr
        self._global_constraints.append(constraint_expression)

    def get_variable(self, predicate_type: PredicateType):
        """Get variable cast to specified type with type constraint.

        :param predicate_type: Target predicate type
        :type predicate_type: PredicateType
        :return: Z3 variable of specified type
        :rtype: z3.ExprRef
        :raises NotImplementedError: For unsupported predicate types

        .. Docstring created by Gemini 2.5 Flash
        """
        if predicate_type not in self._var_type_constraints.keys():
            self._var_type_constraints[predicate_type] = self._generate_type_expression(predicate_type)

        if predicate_type in self._variables_by_type_mapping.keys():
            z3_variable = self._variables_by_type_mapping[predicate_type]
            return z3_variable
        raise NotImplementedError(f'get_variable for predicate type {predicate_type} not implemented yet')

    def _generate_type_expression(self, predicate_type: PredicateType) -> z3.BoolRef:
        """Generate type constraint expression.

        :param predicate_type: Target predicate type
        :type predicate_type: PredicateType
        :return: Z3 boolean type constraint
        :rtype: z3.BoolRef

        .. Docstring created by Gemini 2.5 Flash
        """
        type_expressions = [
            current_type_expr
            if current_type == predicate_type or predicate_type is PredicateType.Any
            else z3.Not(current_type_expr)
            for current_type, current_type_expr in self._type_expressions_by_type_mapping.items()
        ]
        if predicate_type is PredicateType.Any:
            combined_type_expression = z3.Or(type_expressions)
        else:
            combined_type_expression = z3.And(type_expressions)
        return combined_type_expression

    def pop_from_global_constraints(self) -> None:
        variable_type_expressions = list(self._var_type_constraints.values())
        if not variable_type_expressions:
            type_union_expression = z3.BoolVal(True)
        else:
            type_union_expression = z3.PbEq([(v, 1) for v in variable_type_expressions], 1)
            # type_union_expression = variable_type_expressions[0]
            # for current_type_expression in variable_type_expressions[1:]:
            #     type_union_expression = z3.Xor(type_union_expression, current_type_expression)

        nested_context_constraints = [child.pop_from_global_constraints() for child in self._children]

        self._var_type_constraints.clear()
        return z3.And(
            type_union_expression,
            *self._global_constraints,
            *nested_context_constraints,
        )

    def to_global_constraints(self) -> z3.BoolRef:
        """Combine all global constraints into single expression.

        :return: Combined Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring created by Gemini 2.5 Flash
        """

        variable_type_expressions = list(self._var_type_constraints.values())
        if not variable_type_expressions:
            type_union_expression = z3.BoolVal(True)
        else:
            type_union_expression = z3.PbEq([(v, 1) for v in variable_type_expressions], 1)
            # type_union_expression = variable_type_expressions[0]
            # for current_type_expression in variable_type_expressions[1:]:
            #     type_union_expression = z3.Xor(type_union_expression, current_type_expression)

        nested_context_constraints = [child.to_global_constraints() for child in self._children]

        return z3.And(
            type_union_expression,
            *self._global_constraints,
            *nested_context_constraints,
        )
