from abc import ABC, abstractmethod
from uuid import UUID, uuid4

import z3
from pydantic import Field
from typing_extensions import TypeVar

from core.bases.base_schema import BaseSchema
from core.predicates.consts import DEFAULT_SOLVER_TIMEOUT, PredicateType
from core.predicates.helpers import value_to_predicate
from core.predicates.variable_context import VariableContext

PredicateTypeVar = TypeVar('PredicateTypeVar', bound='BasePredicate')


t_Predicate = TypeVar('t_Predicate', bound='BasePredicate')


class BasePredicate(BaseSchema, ABC):
    """Abstract base class for all predicate types.

    :ivar internal_id: Unique identifier for predicate
    :vartype internal_id: UUID

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    internal_id: UUID = Field(default_factory=uuid4, exclude=True)

    def __invert__(self):
        return _DefaultInvertedPredicate(predicate=self)

    def __hash__(self):
        """Generate hash from internal ID.

        :return: Hash value
        :rtype: int

        .. Docstring generated by Gemini 2.5 Flash
        """
        return hash(self.internal_id)

    def __repr__(self):
        data = self.model_dump(mode='json', exclude={'internal_id', 'type_of'})
        data_repr = ', '.join([f'{k}={v}' for k, v in data.items()])
        return f'{self.__class__.__name__}({data_repr})'

    @abstractmethod
    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        """Convert predicate to Z3 expression (abstract).

        :param ctx: Variable context
        :type ctx: VariableContext
        :return: Z3 logical expression
        :rtype: z3.ExprRef

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        ...

    @property
    @abstractmethod
    def predicate_types(self) -> set[PredicateType]:
        """Get supported predicate types (abstract).

        :return: Set of supported types
        :rtype: set[PredicateType]

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        ...

    def _solver_iter(self):
        params = []
        for set_timeout in [5, 10, 600]:
            for set_tactic in [
                'qfauflia',
                'simplify',
                'propagate-values',
                None,
                'smt',
                'solve-eqs',
                'tseitin-cnf',
                'ctx-solver-simplify',
            ]:
                params.append(dict(tactic=set_tactic, timeout=set_timeout))

        for param in params:
            if param['tactic'] is None:
                z3_solver = z3.Solver()
            else:
                z3_solver = z3.Tactic(param['tactic']).solver()
            z3_solver.set("timeout", param['timeout'] * 1000)

            print(f'Using tactic {param["tactic"]} with timeout {param["timeout"]}')
            yield z3_solver, param

        z3_solver = z3.Solver()
        z3_solver.set("timeout", DEFAULT_SOLVER_TIMEOUT * 1000)
        # z3_solver.set("max_memory", 1024)

        try:
            yield z3_solver, dict(tactic='smt', timeout=DEFAULT_SOLVER_TIMEOUT)
        finally:
            z3_solver.reset()

    def is_subset_of(self, other: PredicateTypeVar) -> bool:
        """Check if predicate is subset of another.

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if subset, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024), modified by Gemini 2.5 Flash
        """

        for z3_solver, param in self._solver_iter():
            ctx = VariableContext()

            z3_solver.add(self.to_z3(ctx))
            z3_solver.add((~other).to_z3(ctx))
            z3_solver.add(ctx.to_global_constraints())

            check_result = z3_solver.check()

            if check_result == z3.sat:
                print(ctx.evaluate_value(z3_solver))

            if check_result != z3.unknown:
                break

        assert check_result != z3.unknown
        return check_result in [z3.unsat, z3.unknown]

    def is_superset_of(self, other: PredicateTypeVar) -> bool:
        """Check if predicate is superset of another.

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if superset, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024), modified by Gemini 2.5 Flash
        """

        for z3_solver, param in self._solver_iter():
            ctx = VariableContext()

            z3_solver.add(other.to_z3(ctx))
            z3_solver.add((~self).to_z3(ctx))
            z3_solver.add(ctx.to_global_constraints())

            check_result = z3_solver.check()

            if check_result == z3.sat:
                print(ctx.evaluate_value(z3_solver))

            if check_result != z3.unknown:
                break

        assert check_result != z3.unknown
        return check_result in [z3.unsat, z3.unknown]

    def is_intersected_with(self, other: PredicateTypeVar) -> bool:
        """Check if predicates intersect (have common solutions).

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if intersect, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024), modified by Gemini 2.5 Flash
        """

        for z3_solver, param in self._solver_iter():
            ctx = VariableContext()

            z3_solver.add(self.to_z3(ctx))
            z3_solver.add(other.to_z3(ctx))
            z3_solver.add(ctx.to_global_constraints())

            check_result = z3_solver.check()

            if check_result == z3.sat:
                print(ctx.evaluate_value(z3_solver))

            if check_result != z3.unknown:
                break

        assert check_result != z3.unknown
        return check_result == z3.sat

    # def is_matched(self, value) -> bool:
    #     value_as_predicate = value_to_predicate(value)
    #
    #     for z3_solver, param in self._solver_iter():
    #         self_context = VariableContext()
    #         value_context = VariableContext()
    #
    #         z3_solver.add(self.to_z3(self_context))
    #         z3_solver.add(value_as_predicate.to_z3(value_context))
    #         z3_solver.add(self_context.to_global_constraints())
    #         z3_solver.add(value_context.to_global_constraints())
    #         z3_solver.add(self_context.json_type_variable.z3_variable == value_context.json_type_variable.z3_variable)
    #
    #         check_result = z3_solver.check()
    #         if check_result != z3.unknown:
    #             break
    #
    #     assert check_result != z3.unknown
    #     return check_result == z3.sat

    def is_matched(self, value) -> bool:
        value_as_predicate = value_to_predicate(value)

        check_result = z3.unknown

        for z3_solver, param in self._solver_iter():
            ctx = VariableContext()

            z3_solver.add(self.to_z3(ctx))
            z3_solver.add(value_as_predicate.to_z3(ctx))
            z3_solver.add(ctx.to_global_constraints())
            check_result = z3_solver.check()

            if check_result != z3.unknown:
                break

        assert check_result != z3.unknown
        return check_result == z3.sat

    def is_equivalent_to(self, other):
        """Check if predicates are equivalent.

        :param other: Predicate to compare
        :type other: BasePredicate
        :return: True if equivalent, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        return self.is_subset_of(other) and self.is_superset_of(other) and self.is_intersected_with(other)


class _DefaultInvertedPredicate(BasePredicate):
    predicate: t_Predicate

    def __invert__(self):
        return self.predicate

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        return z3.Not(self.predicate.to_z3(ctx))

    @property
    def predicate_types(self) -> set[PredicateType]:
        return self.predicate.predicate_types


class BaseScalarPredicate(BasePredicate, ABC):
    """Base class for scalar (single-type) predicates.

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    @property
    def predicate_type(self) -> PredicateType:
        """Get primary predicate type.

        :return: Primary predicate type
        :rtype: PredicateType

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        return list(self.predicate_types)[0]


class BaseCollectionPredicate(BasePredicate, ABC):
    """Base class for collection predicates (arrays/objects).

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    pass


class BaseLogicalPredicate(BaseScalarPredicate, ABC):
    """Base class for logical operation predicates (AND/OR/NOT).

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    pass
