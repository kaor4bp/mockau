import gc
from abc import ABC, abstractmethod
from functools import cached_property
from typing import Generator
from uuid import UUID, uuid4

import yaml
import z3
from pydantic import ConfigDict, Field, PrivateAttr, model_serializer, model_validator
from typing_extensions import TypeVar

from core.bases.base_schema import BaseSchema
from core.predicates.consts import DEFAULT_SOLVER_TIMEOUT, PredicateType
from core.predicates.context.main_context import MainContext
from core.predicates.context.predicate_limitations import PredicateLimitations
from core.predicates.context.result_context import ResultContext
from core.predicates.context.variable_context import VariableContext
from core.predicates.helpers import (
    deserialize_json_predicate_format,
    py_value_to_predicate,
    serialize_to_json_predicate_format,
)

_t_Predicate = TypeVar('_t_Predicate', bound='BasePredicate')


class BasePredicate(BaseSchema, ABC):
    """Abstract base class for all predicate types.

    .. Generated by Claude Sonnet 4 (Anthropic)
    """

    @abstractmethod
    def compile_predicate(self):
        """Compile predicate to executable form.

        :return: Compiled predicate
        :rtype: BasePredicate

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        pass


class BaseMetaPredicate(BasePredicate, ABC):
    """Base class for meta predicates that can be serialized to DSL formats.

    .. Generated by Claude Sonnet 4 (Anthropic)
    """

    def to_json_dsl(self) -> str:
        """Convert predicate to JSON DSL format.

        :return: JSON DSL representation
        :rtype: str

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return self.model_dump_json(indent=2, exclude_none=True, by_alias=True)

    def to_yaml_dsl(self):
        return yaml.safe_dump(self.model_dump(mode='json', by_alias=True))

    def compile_predicate(self):
        """Compile meta predicate to ObjectContainsSubset.

        :return: Compiled predicate
        :rtype: ObjectContainsSubset

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        from core.predicates import ObjectContainsSubset

        result = {}
        for field_name in self.model_fields_set:
            field_value = getattr(self, field_name)
            if isinstance(field_value, BaseMetaPredicate):
                field_value = field_value.compile_predicate()
            if isinstance(field_value, list):
                field_value = [
                    item.compile_predicate() if isinstance(item, BaseMetaPredicate) else item for item in field_value
                ]
            if isinstance(field_value, dict):
                temp_field_value = {}
                for k, v in field_value.items():
                    if isinstance(k, BaseMetaPredicate):
                        k = k.compile_predicate()
                    if isinstance(v, BaseMetaPredicate):
                        v = v.compile_predicate()
                    temp_field_value[k] = v
                field_value = temp_field_value
            result[field_name] = field_value

        return ObjectContainsSubset(value=result)


_t_ExecutablePredicate = TypeVar('_t_ExecutablePredicate', bound='BaseExecutablePredicate')


class BaseExecutablePredicate(BaseMetaPredicate, ABC):
    """Abstract base class for all executable predicate types.

    :ivar var: User variable name for linking predicates
    :vartype var: str | None
    :ivar _internal_id: Unique identifier for predicate instance
    :vartype _internal_id: UUID

    .. Generated by Claude Sonnet 4 (Anthropic)
    """

    model_config = ConfigDict(populate_by_name=True, alias_generator=lambda x: f'${x}')

    var: str | None = Field(default=None)
    _internal_id: UUID = PrivateAttr(default_factory=uuid4)

    @model_serializer(when_used='json')
    def json_type_of_serializer(self) -> dict:
        """Serialize predicate to JSON format.

        :return: JSON representation
        :rtype: dict

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        result = self.model_dump(by_alias=True, mode='python')
        return serialize_to_json_predicate_format(result)

    @model_validator(mode='before')
    @classmethod
    def json_type_of_deserializer(cls, data):
        """Deserialize predicate from JSON format.

        :param data: JSON data
        :type data: dict
        :return: Deserialized data
        :rtype: dict

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return deserialize_json_predicate_format(data)

    def compile_predicate(self):
        """Return self as already executable.

        :return: Self
        :rtype: BaseExecutablePredicate

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return self

    @abstractmethod
    def __invert__(self):
        """Create inverted (NOT) predicate.

        :return: Inverted predicate
        :rtype: BaseExecutablePredicate

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        pass

    @abstractmethod
    def get_all_predicates(self) -> Generator['_t_ExecutablePredicate', None, None]:
        pass

    @property
    def is_verify_allowed(self):
        for predicate in self.get_all_predicates():
            if predicate.var is not None:
                return False
        return True

    @abstractmethod
    def verify(self, value):
        """Verify value against predicate (abstract).

        :param value: Value to verify
        :type value: Any
        :return: True if value matches predicate
        :rtype: bool

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        pass

    def __hash__(self):
        """Generate hash from internal ID.

        :return: Hash value
        :rtype: int

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return hash(self._internal_id)

    def __repr__(self):
        """String representation of predicate.

        :return: String representation
        :rtype: str

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        data = self.model_dump(mode='json', exclude={'_internal_id', 'type_of', 'x_minow_type'})
        data_repr = ', '.join([f'{k}={v}' for k, v in data.items()])
        return f'{self.__class__.__name__}({data_repr})'

    def calculate_limitations(self) -> PredicateLimitations:
        """Calculate predicate limitations for Z3 solver.

        :return: Predicate limitations
        :rtype: PredicateLimitations

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return PredicateLimitations()

    def normalize_to_canonical_form(self):
        """Normalize predicate to canonical form.

        :return: Normalized predicate
        :rtype: BaseExecutablePredicate

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return self

    def to_json_dsl(self):
        """Convert to JSON DSL format.

        :return: JSON DSL string
        :rtype: str

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return self.normalize_to_canonical_form().model_dump_json(by_alias=True)

    def is_equal_to(self, other):
        """Check if predicates are structurally equal.

        :param other: Other predicate
        :type other: BaseExecutablePredicate
        :return: True if equal
        :rtype: bool

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return self.to_json_dsl() == other.to_json_dsl()

    @abstractmethod
    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        """Convert predicate to Z3 expression (abstract).

        :param ctx: Variable context
        :type ctx: VariableContext
        :return: Z3 logical expression
        :rtype: z3.ExprRef

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        ...

    @property
    @abstractmethod
    def predicate_types(self) -> set[PredicateType]:
        """Get supported predicate types (abstract).

        :return: Set of supported types
        :rtype: set[PredicateType]

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        ...

    def _get_anti_hang_solver(self, max_nesting_level):
        """Get anti-hang solver with short timeout.

        :param max_nesting_level: Maximum nesting level
        :type max_nesting_level: int
        :return: Generator of (context, solver) pairs
        :rtype: Generator[tuple[MainContext, z3.Solver], None, None]

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        main_context = MainContext(max_nesting_level=max_nesting_level)
        solver = z3.Solver(ctx=main_context.z3_context)
        solver.set("timeout", 5 * 1000)

        try:
            print('Using anti hang solver')
            yield main_context, solver
        except z3.Z3Exception as e:
            print(f'Anti hang exception: {e}')
        finally:
            del solver
            del main_context

    def _solver_iter(self, max_nesting_level: int):
        """Iterate through different Z3 solver configurations.

        :param max_nesting_level: Maximum nesting level
        :type max_nesting_level: int
        :return: Generator of (context, solver) pairs
        :rtype: Generator[tuple[MainContext, z3.Solver], None, None]

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        max_nesting_level += 2

        for timeout in [DEFAULT_SOLVER_TIMEOUT]:
            for tactic in [
                'qfauflia',
                'simplify',
                'propagate-values',
                'smt',
                None,
                'solve-eqs',
                'tseitin-cnf',
                'ctx-solver-simplify',
            ]:
                main_context = MainContext(max_nesting_level=max_nesting_level)

                if tactic is None:
                    solver = z3.Solver(ctx=main_context.z3_context)
                else:
                    solver = z3.Tactic(tactic, ctx=main_context.z3_context).solver()
                solver.set("timeout", timeout * 1000)
                solver.set("max_memory", 4096)

                try:
                    print(f'Using solver {tactic} with timeout {timeout}')
                    yield main_context, solver
                except z3.Z3Exception as e:
                    print(f'Solver with tactic "{tactic}" exception: {e}')
                finally:
                    del solver
                    del main_context
                    gc.collect()

                yield from self._get_anti_hang_solver(max_nesting_level)

    def is_consistent(self, result_ctx: ResultContext | None = None) -> bool:
        """Check if predicate is logically consistent (satisfiable).

        :return: True if predicate can be satisfied
        :rtype: bool

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        check_result = z3.unknown

        limitations = self.calculate_limitations()
        for main_context, solver in self._solver_iter(limitations.get_max_level()):
            variable_context = VariableContext(main_context=main_context)
            main_context.set_limitations(limitations)

            solver.add(self.to_z3(variable_context))
            solver.add(variable_context.root_parent.pop_from_global_constraints())

            check_result = solver.check()

            if result_ctx:
                result_ctx.calculate(solver, main_context, variable_context)

            del variable_context
            if check_result != z3.unknown:
                return check_result == z3.sat

        assert check_result != z3.unknown
        return False

    def is_subset_of(self, other: _t_Predicate, result_ctx: ResultContext | None = None) -> bool:
        """Check if this predicate is subset of another.

        :param other: Predicate to compare against
        :type other: BaseExecutablePredicate
        :return: True if this is subset of other
        :rtype: bool

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        from core.predicates import NotPredicate

        if not self.is_intersected_with(other, result_ctx=result_ctx):
            return False

        check_result = z3.unknown
        limitations = self.calculate_limitations()
        limitations.push(NotPredicate(predicate=other).calculate_limitations())

        for main_context, solver in self._solver_iter(limitations.get_max_level()):
            variable_context = VariableContext(main_context=main_context)
            main_context.set_limitations(limitations)

            solver.add(self.to_z3(variable_context))
            solver.add(NotPredicate(predicate=other).to_z3(variable_context))
            solver.add(variable_context.root_parent.pop_from_global_constraints())

            check_result = solver.check()

            if result_ctx and check_result == z3.sat:
                result_ctx.reset()

            del variable_context
            if check_result != z3.unknown:
                return check_result in [z3.unsat, z3.unknown]

        assert check_result != z3.unknown
        return False

    def is_superset_of(self, other: _t_Predicate, result_ctx: ResultContext | None = None) -> bool:
        """Check if this predicate is superset of another.

        :param other: Predicate to compare against
        :type other: BaseExecutablePredicate
        :return: True if this is superset of other
        :rtype: bool

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        from core.predicates import NotPredicate

        if not self.is_intersected_with(other, result_ctx=result_ctx):
            return False

        check_result = z3.unknown
        limitations = (~self).calculate_limitations()
        limitations.push(other.calculate_limitations())

        for main_context, solver in self._solver_iter(limitations.get_max_level()):
            variable_context = VariableContext(main_context=main_context)
            main_context.set_limitations(limitations)

            solver.add(other.to_z3(variable_context))
            solver.add(NotPredicate(predicate=self).to_z3(variable_context))
            solver.add(variable_context.root_parent.pop_from_global_constraints())

            check_result = solver.check()

            if result_ctx and check_result == z3.sat:
                result_ctx.reset()

            del variable_context
            if check_result != z3.unknown:
                return check_result in [z3.unsat, z3.unknown]

        assert check_result != z3.unknown
        return False

    def is_intersected_with(self, other: _t_Predicate, result_ctx: ResultContext | None = None) -> bool:
        """Check if predicates intersect (have common solutions).

        :param other: Predicate to compare against
        :type other: BaseExecutablePredicate
        :return: True if predicates intersect
        :rtype: bool

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        check_result = z3.unknown
        limitations = self.calculate_limitations()
        limitations.push(other.calculate_limitations())

        for main_context, solver in self._solver_iter(limitations.get_max_level()):
            variable_context = VariableContext(main_context=main_context)
            main_context.set_limitations(limitations)

            solver.add(self.to_z3(variable_context))
            solver.add(other.to_z3(variable_context))
            solver.add(variable_context.root_parent.pop_from_global_constraints())
            check_result = solver.check()

            if result_ctx:
                result_ctx.calculate(solver, main_context, variable_context)

            del variable_context
            if check_result != z3.unknown:
                return check_result == z3.sat

        assert check_result != z3.unknown
        return False

    def is_matched(self, value, result_ctx: ResultContext | None = None) -> bool:
        """Check if value matches this predicate.

        :param value: Value to check
        :type value: Any
        :return: True if value matches predicate
        :rtype: bool

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        if self.is_verify_allowed:
            print(f'verify {value}')
            return self.verify(value)
        else:
            other_predicate = py_value_to_predicate(value)
            print(f'search intersection with {other_predicate}')
            return self.is_intersected_with(other_predicate, result_ctx=result_ctx)

    def is_equivalent_to(self, other, result_ctx: ResultContext | None = None):
        """Check if predicates are logically equivalent.

        :param other: Predicate to compare against
        :type other: BaseExecutablePredicate
        :return: True if predicates are equivalent
        :rtype: bool

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        # Fast path: check structural equality first
        if self.is_equal_to(other) and self.is_verify_allowed:
            return True

        # Logical equivalence: both subset and superset
        return self.is_subset_of(other, result_ctx=result_ctx) and self.is_superset_of(other, result_ctx=result_ctx)


class BaseCompoundPredicate(BaseExecutablePredicate, ABC):
    var: str | None = Field(default=None)

    @property
    @abstractmethod
    def compiled_value(self):
        pass

    def __invert__(self):
        return ~self.compiled_value

    def verify(self, value):
        self.compiled_value.verify(value)

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        return self.compiled_value.to_z3(ctx)

    @property
    def predicate_types(self) -> set[PredicateType]:
        return self.compiled_value.predicate_types

    def get_all_predicates(self):
        yield from self.compiled_value.get_all_predicates()


class BaseScalarPredicate(BaseExecutablePredicate, ABC):
    """Base class for scalar (single-value) predicates.

    .. Generated by Claude Sonnet 4 (Anthropic)
    """

    @property
    def predicate_type(self) -> PredicateType:
        """Get primary predicate type.

        :return: Primary predicate type
        :rtype: PredicateType

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        return list(self.predicate_types)[0]


class BaseCollectionPredicate(BaseExecutablePredicate, ABC):
    """Base class for collection predicates (arrays/objects).

    .. Generated by Claude Sonnet 4 (Anthropic)
    """

    @abstractmethod
    @cached_property
    def compiled_value(self):
        """Get compiled value for collection predicate.

        :return: Compiled value
        :rtype: Any

        .. Generated by Claude Sonnet 4 (Anthropic)
        """
        pass


class BaseLogicalPredicate(BaseScalarPredicate, ABC):
    """Base class for logical operation predicates (AND/OR/NOT).

    .. Generated by Claude Sonnet 4 (Anthropic)
    """

    pass


_t_SpecifiedType = TypeVar('_t_SpecifiedType')


class ParityPredicateMixin(BaseExecutablePredicate, ABC):
    """Mixin for predicates that support parity (positive/negative) operations.

    .. Generated by Claude Sonnet 4 (Anthropic)
    """

    _parity: bool = PrivateAttr(default=True)
