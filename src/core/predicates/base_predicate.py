from abc import ABC, abstractmethod
from uuid import UUID, uuid4

import z3
from pydantic import Field
from typing_extensions import TypeVar

from core.bases.base_schema import BaseSchema
from core.predicates.consts import DEFAULT_SOLVER_TIMEOUT, PredicateType
from core.predicates.variable_context import VariableContext

PredicateTypeVar = TypeVar('PredicateTypeVar', bound='BasePredicate')


t_Predicate = TypeVar('t_Predicate', bound='BasePredicate')

_DEFAULT_SOLVER = z3.Solver()
_DEFAULT_SOLVER.set("timeout", DEFAULT_SOLVER_TIMEOUT * 1000)


class BasePredicate(BaseSchema, ABC):
    """Abstract base class for all predicate types.

    :ivar internal_id: Unique identifier for predicate
    :vartype internal_id: UUID

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    internal_id: UUID = Field(default_factory=uuid4, exclude=True)

    def __invert__(self):
        return _DefaultInvertedPredicate(predicate=self)

    @abstractmethod
    def verify(self, value):
        pass

    def __hash__(self):
        """Generate hash from internal ID.

        :return: Hash value
        :rtype: int

        .. Docstring generated by Gemini 2.5 Flash
        """
        return hash(self.internal_id)

    def __repr__(self):
        data = self.model_dump(mode='json', exclude={'internal_id', 'type_of'})
        data_repr = ', '.join([f'{k}={v}' for k, v in data.items()])
        return f'{self.__class__.__name__}({data_repr})'

    def get_max_nesting_level(self):
        return 1

    @abstractmethod
    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        """Convert predicate to Z3 expression (abstract).

        :param ctx: Variable context
        :type ctx: VariableContext
        :return: Z3 logical expression
        :rtype: z3.ExprRef

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        ...

    @property
    @abstractmethod
    def predicate_types(self) -> set[PredicateType]:
        """Get supported predicate types (abstract).

        :return: Set of supported types
        :rtype: set[PredicateType]

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        ...

    def _get_anti_hang_solver(self):
        z3_solver = z3.Solver()
        z3_solver.set("timeout", 5 * 1000)
        z3_solver.push()
        z3_solver.set("max_memory", 256)

        try:
            print('Using anti hang solver')
            yield z3_solver
        except z3.Z3Exception as e:
            print(f'Anti hang exception: {e}')
        finally:
            z3_solver.reset()
            del z3_solver

    def _solver_iter(self):
        _DEFAULT_SOLVER.push()
        try:
            print('Using default solver')
            yield _DEFAULT_SOLVER
        finally:
            _DEFAULT_SOLVER.reset()

        yield from self._get_anti_hang_solver()

        for set_tactic in [
            'qfauflia',
            'simplify',
            'propagate-values',
            None,
            'smt',
            'solve-eqs',
            'tseitin-cnf',
            'ctx-solver-simplify',
        ]:
            for set_timeout in [DEFAULT_SOLVER_TIMEOUT]:
                if set_tactic is None:
                    solver = z3.Solver()
                else:
                    solver = z3.Tactic(set_tactic).solver()
                solver.set("timeout", set_timeout * 1000)

                solver.push()
                try:
                    print(f'Using solver {set_tactic} with timeout {set_timeout}')
                    yield solver
                finally:
                    solver.reset()
                    del solver

                yield from self._get_anti_hang_solver()

    def is_consistent(self) -> bool:
        check_result = z3.unknown

        for z3_solver in self._solver_iter():
            ctx = VariableContext()
            ctx.set_max_nesting_level(self.get_max_nesting_level())

            z3_solver.add(self.to_z3(ctx))
            z3_solver.add(ctx.to_global_constraints())

            check_result = z3_solver.check()

            # if check_result == z3.sat:
            #     val = ctx.evaluate_value(z3_solver)
            #     print(val)
            #     # assert self.verify(val)

            del ctx
            if check_result != z3.unknown:
                break

        assert check_result != z3.unknown
        return check_result == z3.sat

    def is_subset_of(self, other: PredicateTypeVar) -> bool:
        """Check if predicate is subset of another.

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if subset, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash
        """

        if not self.is_intersected_with(other):
            return False

        check_result = z3.unknown

        for z3_solver in self._solver_iter():
            ctx = VariableContext()
            ctx.set_max_nesting_level(max([(~other).get_max_nesting_level(), self.get_max_nesting_level()]))

            z3_solver.add(self.to_z3(ctx))
            z3_solver.add((~other).to_z3(ctx))
            z3_solver.add(ctx.to_global_constraints())

            check_result = z3_solver.check()

            # if check_result == z3.sat:
            #     val = ctx.evaluate_value(z3_solver)
            #     print(val)
            #     # assert self.verify(val)
            #     # assert (~other).verify(val)

            del ctx
            if check_result != z3.unknown:
                break

        assert check_result != z3.unknown
        return check_result in [z3.unsat, z3.unknown]

    def is_superset_of(self, other: PredicateTypeVar) -> bool:
        """Check if predicate is superset of another.

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if superset, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash
        """

        if not self.is_intersected_with(other):
            return False

        check_result = z3.unknown

        for z3_solver in self._solver_iter():
            ctx = VariableContext()
            ctx.set_max_nesting_level(max([other.get_max_nesting_level(), (~self).get_max_nesting_level()]))

            z3_solver.add(other.to_z3(ctx))
            z3_solver.add((~self).to_z3(ctx))
            z3_solver.add(ctx.to_global_constraints())

            check_result = z3_solver.check()

            # if check_result == z3.sat:
            #     val = ctx.evaluate_value(z3_solver)
            #     print(val)
            #     # assert (~self).verify(val)
            #     # assert other.verify(val)

            del ctx
            if check_result != z3.unknown:
                break

        assert check_result != z3.unknown
        return check_result in [z3.unsat, z3.unknown]

    def is_intersected_with(self, other: PredicateTypeVar) -> bool:
        """Check if predicates intersect (have common solutions).

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if intersect, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash
        """

        check_result = z3.unknown

        for z3_solver in self._solver_iter():
            ctx = VariableContext()
            ctx.set_max_nesting_level(max([other.get_max_nesting_level(), self.get_max_nesting_level()]))

            z3_solver.add(self.to_z3(ctx))
            z3_solver.add(other.to_z3(ctx))
            z3_solver.add(ctx.to_global_constraints())

            check_result = z3_solver.check()

            # if check_result == z3.sat:
            #     val = ctx.evaluate_value(z3_solver)
            #     print(val)
            #     # assert self.verify(val)
            #     # assert other.verify(val)

            del ctx

            if check_result != z3.unknown:
                break

        assert check_result != z3.unknown
        return check_result == z3.sat

    def is_matched(self, value) -> bool:
        return self.verify(value)

    # def is_matched(self, value) -> bool:
    #     value_as_predicate = value_to_predicate(value)
    #
    #     check_result = z3.unknown
    #
    #     for z3_solver in self._solver_iter():
    #         ctx = VariableContext()
    #
    #         z3_solver.add(self.to_z3(ctx))
    #         z3_solver.add(value_as_predicate.to_z3(ctx))
    #         z3_solver.add(ctx.to_global_constraints())
    #         check_result = z3_solver.check()
    #
    #         if check_result != z3.unknown:
    #             break
    #
    #     assert check_result != z3.unknown
    #     result = check_result == z3.sat
    #     assert result == self.verify(value)
    #     return result

    def is_equivalent_to(self, other):
        """Check if predicates are equivalent.

        :param other: Predicate to compare
        :type other: BasePredicate
        :return: True if equivalent, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        # if not self.is_intersected_with(other):
        #     return False
        return self.is_subset_of(other) and self.is_superset_of(other)


class _DefaultInvertedPredicate(BasePredicate):
    predicate: t_Predicate

    def __invert__(self):
        return self.predicate

    def verify(self, value):
        return not self.predicate.verify(value)

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        return z3.Not(self.predicate.to_z3(ctx))

    @property
    def predicate_types(self) -> set[PredicateType]:
        return self.predicate.predicate_types


class BaseScalarPredicate(BasePredicate, ABC):
    """Base class for scalar (single-type) predicates.

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    @property
    def predicate_type(self) -> PredicateType:
        """Get primary predicate type.

        :return: Primary predicate type
        :rtype: PredicateType

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        return list(self.predicate_types)[0]


class BaseCollectionPredicate(BasePredicate, ABC):
    """Base class for collection predicates (arrays/objects).

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    pass


class BaseLogicalPredicate(BaseScalarPredicate, ABC):
    """Base class for logical operation predicates (AND/OR/NOT).

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    pass
