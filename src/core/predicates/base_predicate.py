from abc import ABC, abstractmethod
from enum import Enum
from uuid import UUID, uuid4

import z3
from pydantic import Field
from typing_extensions import TypeVar

from core.bases.base_schema import BaseSchema
from core.predicates.helpers import value_to_predicate

PredicateTypeVar = TypeVar('PredicateTypeVar', bound='BasePredicate')
DEFAULT_SOLVER_TIMEOUT = 100000

t_Predicate = TypeVar('t_Predicate', bound='BasePredicate')


class PredicateType(Enum):
    """Enumeration representing data types for predicates.

    :cvar Boolean: Boolean type (true/false)
    :cvar Integer: Integer number type
    :cvar Real: Real number type
    :cvar String: String type
    :cvar Object: JSON object type
    :cvar Array: Array type
    :cvar Null: Null type
    :cvar Any: Any type

    .. Docstring generated by Gemini 2.5 Flash
    """

    Boolean = 'Boolean'
    Integer = 'Integer'
    Real = 'Real'
    String = 'String'
    Object = 'Object'
    Array = 'Array'
    Null = 'Null'
    Any = 'Any'


class JsonDatatype:
    """Z3 Datatype for representing JSON-like structures with nested support.

    :ivar _JSON_TYPES: Cache for created JSON types by level
    :ivar MAX_NESTING_LEVEL: Maximum allowed nesting level (default: 100)

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    _JSON_TYPES = {}
    MAX_NESTING_LEVEL = 100

    def __init__(self, level: int | None = None) -> None:
        """Initialize JSON Datatype with specified nesting level.

        :param level: Nesting level for JSON structure (None for max level)
        :type level: int | None

        .. Docstring generated by Gemini 2.5 Flash, modified by Gemini 2.5 Flash
        """
        if not self._JSON_TYPES:
            self._build_json_type(level=self.MAX_NESTING_LEVEL)
        if level is None:
            current_level = max(self._JSON_TYPES.keys())
        else:
            current_level = level
        self._level = current_level
        self._json_type = self._JSON_TYPES[self._level]
        variable_id = uuid4()
        self._var_id = variable_id
        self._var = z3.Const(f'json_var_{self._var_id}', self._json_type)

    @property
    def level(self) -> int:
        """Get current nesting level.

        :return: Current nesting level
        :rtype: int

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._level

    @property
    def z3_variable(self) -> z3.DatatypeRef:
        """Get Z3 variable reference.

        :return: Z3 datatype variable
        :rtype: z3.DatatypeRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._var

    @classmethod
    def _build_json_type(cls, level: int = -1):
        """Build and cache Z3 Datatype for JSON representation.

        :param level: Nesting level for JSON type
        :type level: int
        :return: Constructed Z3 Datatype
        :rtype: z3.DatatypeRef

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024), modified by Gemini 2.5 Flash
        """
        if cls._JSON_TYPES.get(level):
            return cls._JSON_TYPES[level]

        json_datatype = z3.Datatype(f'JsonType_{level}')
        json_datatype.declare('int', ('get_int', z3.IntSort()))
        json_datatype.declare('bool', ('get_bool', z3.BoolSort()))
        json_datatype.declare('str', ('get_str', z3.StringSort()))
        json_datatype.declare('real', ('get_real', z3.RealSort()))

        if level > 0:
            nested_json_datatype = cls._build_json_type(level - 1)
            nested_json_array_sort = z3.ArraySort(z3.StringSort(), nested_json_datatype)
            json_datatype.declare(
                'object',
                ('get_object', nested_json_array_sort),
                ('get_object_keys_quantity', z3.IntSort()),
                ('get_object_keys', z3.SetSort(z3.StringSort())),
            )

        json_datatype = json_datatype.create()
        cls._JSON_TYPES[level] = json_datatype
        return json_datatype

    def get_str(self) -> z3.SeqRef:
        """Get string value from JSON datatype.

        :return: Z3 string reference
        :rtype: z3.SeqRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.get_str(self._var)

    def get_real(self) -> z3.ArithRef:
        """Get real number value from JSON datatype.

        :return: Z3 real number reference
        :rtype: z3.ArithRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.get_real(self._var)

    def get_int(self) -> z3.ArithRef:
        """Get integer value from JSON datatype.

        :return: Z3 integer reference
        :rtype: z3.ArithRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.get_int(self._var)

    def get_bool(self) -> z3.BoolRef:
        """Get boolean value from JSON datatype.

        :return: Z3 boolean reference
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.get_bool(self._var)

    def get_object(self) -> z3.DatatypeRef:
        """Get object value from JSON datatype.

        :return: Z3 object reference
        :rtype: z3.DatatypeRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.get_object(self._var)

    def get_object_keys_quantity(self) -> z3.ArithRef:
        """Get count of object keys.

        :return: Z3 integer reference for key count
        :rtype: z3.ArithRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.get_object_keys_quantity(self._var)

    def get_object_keys(self) -> z3.ArrayRef:
        """Get object keys as Z3 array.

        :return: Z3 array reference for keys
        :rtype: z3.ArrayRef

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        return self._json_type.get_object_keys(self._var)

    def is_str(self):
        """Check if value is string type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.is_str(self._var)

    def is_real(self):
        """Check if value is real number type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.is_real(self._var)

    def is_int(self):
        """Check if value is integer type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.is_int(self._var)

    def is_bool(self):
        """Check if value is boolean type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.is_bool(self._var)

    def is_object(self):
        """Check if value is object type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.is_object(self._var)


class VariableContext:
    """Context manager for Z3 variables and constraints.

    Manages variable types, constraints, and nested contexts for predicate evaluation.

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    def __init__(self, level: int | None = None) -> None:
        """Initialize variable context.

        :param level: Nesting level for JSON (None for max level)
        :type level: int | None

        .. Docstring generated by Gemini 2.5 Flash, modified by Gemini 2.5 Flash
        """
        self._children = []
        self._var_type_constraints = {}
        self._global_constraints = []
        self._json_var = JsonDatatype(level=level)
        self._variables_by_type_mapping = {
            PredicateType.String: self._json_var.get_str(),
            PredicateType.Integer: self._json_var.get_int(),
            PredicateType.Real: self._json_var.get_real(),
            PredicateType.Boolean: self._json_var.get_bool(),
            PredicateType.Object: self._json_var.get_object(),
        }
        self._type_expressions_by_type_mapping = {
            PredicateType.String: self._json_var.is_str(),
            PredicateType.Integer: self._json_var.is_int(),
            PredicateType.Real: self._json_var.is_real(),
            PredicateType.Boolean: self._json_var.is_bool(),
            PredicateType.Object: self._json_var.is_object(),
        }

    @property
    def json_type_variable(self) -> JsonDatatype:
        """Get JSON datatype variable.

        :return: JSON datatype instance
        :rtype: JsonDatatype

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_var

    def create_child_context(self) -> 'VariableContext':
        """Create nested variable context with reduced level.

        :return: New child context
        :rtype: VariableContext

        .. Docstring generated by Gemini 2.5 Flash, modified by Gemini 2.5 Flash
        """
        new_child_context = VariableContext(level=self._json_var.level - 1)
        self._children.append(new_child_context)
        return new_child_context

    def push_to_global_constraints(self, expr: z3.ExprRef | bool) -> None:
        """Add constraint to global context.

        :param expr: Z3 expression or boolean to add
        :type expr: z3.ExprRef | bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024), modified by Gemini 2.5 Flash
        """
        constraint_expression = expr
        self._global_constraints.append(constraint_expression)

    def get_variable(self, predicate_type: PredicateType):
        """Get variable cast to specified type with type constraint.

        :param predicate_type: Target predicate type
        :type predicate_type: PredicateType
        :return: Z3 variable of specified type
        :rtype: z3.ExprRef
        :raises NotImplementedError: For unsupported predicate types

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024), modified by Gemini 2.5 Flash
        """
        if predicate_type not in self._var_type_constraints:
            self._var_type_constraints[predicate_type] = self._generate_type_expression(predicate_type)

        if predicate_type in self._variables_by_type_mapping.keys():
            z3_variable = self._variables_by_type_mapping[predicate_type]
            return z3_variable
        raise NotImplementedError(f'get_variable for predicate type {predicate_type} not implemented yet')

    def _generate_type_expression(self, predicate_type: PredicateType) -> z3.BoolRef:
        """Generate type constraint expression.

        :param predicate_type: Target predicate type
        :type predicate_type: PredicateType
        :return: Z3 boolean type constraint
        :rtype: z3.BoolRef

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024), modified by Gemini 2.5 Flash
        """
        type_expressions = [
            current_type_expr if current_type == predicate_type else z3.Not(current_type_expr)
            for current_type, current_type_expr in self._type_expressions_by_type_mapping.items()
        ]
        combined_type_expression = z3.And(type_expressions)
        return combined_type_expression

    def to_global_constraints(self) -> z3.BoolRef:
        """Combine all constraints into single expression.

        :return: Combined Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024), modified by Gemini 2.5 Flash
        """
        variable_type_expressions = list(self._var_type_constraints.values())
        if not variable_type_expressions:
            type_union_expression = z3.BoolVal(True)
        else:
            type_union_expression = variable_type_expressions[0]
            for current_type_expression in variable_type_expressions[1:]:
                type_union_expression = z3.Xor(type_union_expression, current_type_expression)

        nested_context_constraints = [child.to_global_constraints() for child in self._children]
        return z3.simplify(z3.And(type_union_expression, *self._global_constraints, *nested_context_constraints))


class BasePredicate(BaseSchema, ABC):
    """Abstract base class for all predicate types.

    :ivar internal_id: Unique identifier for predicate
    :vartype internal_id: UUID

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    internal_id: UUID = Field(default_factory=uuid4, exclude=True)

    def __hash__(self):
        """Generate hash from internal ID.

        :return: Hash value
        :rtype: int

        .. Docstring generated by Gemini 2.5 Flash
        """
        return hash(self.internal_id)

    @abstractmethod
    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        """Convert predicate to Z3 expression (abstract).

        :param ctx: Variable context
        :type ctx: VariableContext
        :return: Z3 logical expression
        :rtype: z3.ExprRef

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        ...

    @property
    @abstractmethod
    def predicate_types(self) -> set[PredicateType]:
        """Get supported predicate types (abstract).

        :return: Set of supported types
        :rtype: set[PredicateType]

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        ...

    def _setup_solver(self) -> z3.Solver:
        """Configure new Z3 solver with timeout.

        :return: Configured Z3 solver
        :rtype: z3.Solver

        .. Docstring generated by Gemini 2.5 Flash, modified by Gemini 2.5 Flash
        """
        z3_solver = z3.Solver()
        z3_solver.set("timeout", DEFAULT_SOLVER_TIMEOUT)
        return z3_solver

    def is_subset_of(self, other: PredicateTypeVar) -> bool:
        """Check if predicate is subset of another.

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if subset, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024), modified by Gemini 2.5 Flash
        """
        z3_solver = self._setup_solver()
        variable_context = VariableContext()
        z3_solver.add(z3.And(self.to_z3(variable_context), z3.Not(other.to_z3(variable_context))))
        z3_solver.add(variable_context.to_global_constraints())
        check_result = z3_solver.check()
        assert check_result != z3.unknown
        return check_result in [z3.unsat, z3.unknown]

    def is_superset_of(self, other: PredicateTypeVar) -> bool:
        """Check if predicate is superset of another.

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if superset, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024), modified by Gemini 2.5 Flash
        """
        z3_solver = self._setup_solver()
        variable_context = VariableContext()

        z3_solver.add(other.to_z3(variable_context))
        z3_solver.add(z3.Not(self.to_z3(variable_context)))
        z3_solver.add(variable_context.to_global_constraints())

        check_result = z3_solver.check()
        assert check_result != z3.unknown
        return check_result in [z3.unsat, z3.unknown]

    def is_intersected_with(self, other: PredicateTypeVar) -> bool:
        """Check if predicates intersect (have common solutions).

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if intersect, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024), modified by Gemini 2.5 Flash
        """
        z3_solver = self._setup_solver()
        variable_context = VariableContext()

        z3_solver.add(z3.And(self.to_z3(variable_context), other.to_z3(variable_context)))
        z3_solver.add(variable_context.to_global_constraints())

        check_result = z3_solver.check()
        assert check_result != z3.unknown
        return check_result == z3.sat

    def is_matched(self, value) -> bool:
        """Check if predicate matches given value.

        :param value: Value to test
        :type value: Any
        :return: True if matches, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024), modified by Gemini 2.5 Flash
        """
        value_as_predicate = value_to_predicate(value)
        z3_solver = self._setup_solver()
        self_context = VariableContext()
        value_context = VariableContext()

        z3_solver.add(self.to_z3(self_context))
        z3_solver.add(value_as_predicate.to_z3(value_context))
        z3_solver.add(self_context.to_global_constraints())
        z3_solver.add(value_context.to_global_constraints())
        z3_solver.add(self_context.json_type_variable.z3_variable == value_context.json_type_variable.z3_variable)

        check_result = z3_solver.check()
        assert check_result != z3.unknown
        return check_result == z3.sat

    def is_equivalent_to(self, other):
        """Check if predicates are equivalent.

        :param other: Predicate to compare
        :type other: BasePredicate
        :return: True if equivalent, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        return self.is_subset_of(other) and self.is_superset_of(other)


class BaseScalarPredicate(BasePredicate, ABC):
    """Base class for scalar (single-type) predicates.

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    @property
    def predicate_type(self) -> PredicateType:
        """Get primary predicate type.

        :return: Primary predicate type
        :rtype: PredicateType

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        return list(self.predicate_types)[0]


class BaseCollectionPredicate(BasePredicate, ABC):
    """Base class for collection predicates (arrays/objects).

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    pass


class BaseLogicalPredicate(BaseScalarPredicate, ABC):
    """Base class for logical operation predicates (AND/OR/NOT).

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    pass
