import gc
from abc import ABC, abstractmethod
from functools import cached_property
from typing import Any
from uuid import UUID, uuid4

import z3
from pydantic import ConfigDict, PrivateAttr, model_serializer, model_validator
from typing_extensions import TypeVar

from core.bases.base_schema import BaseSchema
from core.predicates.consts import DEFAULT_SOLVER_TIMEOUT, PredicateType
from core.predicates.context.main_context import MainContext
from core.predicates.context.predicate_limitations import PredicateLimitations
from core.predicates.context.variable_context import VariableContext
from core.predicates.helpers import deserialize_json_predicate_format, serialize_to_json_predicate_format

_t_Predicate = TypeVar('_t_Predicate', bound='BasePredicate')


class BasePredicate(BaseSchema, ABC):
    """Abstract base class for all predicate types.

    :ivar _internal_id: Unique identifier for predicate
    :vartype internal_id: UUID

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    model_config = ConfigDict(populate_by_name=True, alias_generator=lambda x: f'${x}')

    _internal_id: UUID = PrivateAttr(default_factory=uuid4)

    @model_serializer(when_used='json')
    def json_type_of_serializer(self) -> dict:
        result = self.model_dump(by_alias=True, mode='python')
        return serialize_to_json_predicate_format(result)
        # if isinstance(self, BaseCompositePredicate):
        #     return result
        # else:
        #     if '$type_of' in result:
        #         type_of = result.pop('$type_of')
        #     else:
        #         type_of = 'unknown'
        #     return {type_of: result}

    @model_validator(mode='before')
    @classmethod
    def json_type_of_deserializer(cls, data):
        return deserialize_json_predicate_format(data)

    def compile_predicate(self):
        return self

    def __invert__(self):
        return _DefaultInvertedPredicate(predicate=self)

    def get_z3_context(self):
        global _CURRENT_Z3_CONTEXT
        if _CURRENT_Z3_CONTEXT is None:
            _CURRENT_Z3_CONTEXT = z3.Context()
        return _CURRENT_Z3_CONTEXT

    @abstractmethod
    def verify(self, value):
        pass

    def __hash__(self):
        """Generate hash from internal ID.

        :return: Hash value
        :rtype: int

        .. Docstring generated by Gemini 2.5 Flash
        """
        return hash(self._internal_id)

    def __repr__(self):
        data = self.model_dump(mode='json', exclude={'_internal_id', 'type_of', 'x_mockau_type'})
        data_repr = ', '.join([f'{k}={v}' for k, v in data.items()])
        return f'{self.__class__.__name__}({data_repr})'

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations()

    def normalize(self):
        return self

    def is_equal_to(self, other):
        p1 = self.normalize()
        p2 = other.normalize()
        x1 = p1.model_dump_json(by_alias=True)
        x2 = p2.model_dump_json(by_alias=True)
        return x1 == x2

    @abstractmethod
    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        """Convert predicate to Z3 expression (abstract).

        :param ctx: Variable context
        :type ctx: VariableContext
        :return: Z3 logical expression
        :rtype: z3.ExprRef

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        ...

    @property
    @abstractmethod
    def predicate_types(self) -> set[PredicateType]:
        """Get supported predicate types (abstract).

        :return: Set of supported types
        :rtype: set[PredicateType]

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        ...

    def _get_anti_hang_solver(
        self,
        max_nesting_level,
    ):
        main_ctx = MainContext(max_nesting_level=max_nesting_level)
        z3_solver = z3.Solver(ctx=main_ctx.z3_context)
        z3_solver.set("timeout", 5 * 1000)

        try:
            print('Using anti hang solver')
            yield main_ctx, z3_solver
        except z3.Z3Exception as e:
            print(f'Anti hang exception: {e}')
        finally:
            del z3_solver
            del main_ctx

    def _solver_iter(self, max_nesting_level: int):
        max_nesting_level += 2

        for set_timeout in [DEFAULT_SOLVER_TIMEOUT]:
            for set_tactic in [
                'qfauflia',
                'simplify',
                'propagate-values',
                'smt',
                None,
                'solve-eqs',
                'tseitin-cnf',
                'ctx-solver-simplify',
            ]:
                main_ctx = MainContext(max_nesting_level=max_nesting_level)

                if set_tactic is None:
                    solver = z3.Solver(ctx=main_ctx.z3_context)
                else:
                    solver = z3.Tactic(set_tactic, ctx=main_ctx.z3_context).solver()
                solver.set("timeout", set_timeout * 1000)
                solver.set("max_memory", 4096)

                try:
                    print(f'Using solver {set_tactic} with timeout {set_timeout}')
                    yield main_ctx, solver
                except z3.Z3Exception as e:
                    print(f'Solver with tactic "{set_tactic}" exception: {e}')
                finally:
                    del solver
                    del main_ctx
                    gc.collect()

                yield from self._get_anti_hang_solver(max_nesting_level)

    def is_consistent(self) -> bool:
        check_result = z3.unknown

        limitations = self.calculate_limitations()
        for main_context, z3_solver in self._solver_iter(limitations.get_max_level()):
            ctx = VariableContext(main_context=main_context)
            main_context.set_limitations(limitations)

            z3_solver.add(self.to_z3(ctx))
            z3_solver.add(ctx.pop_from_global_constraints())

            check_result = z3_solver.check()

            # if check_result == z3.sat:
            #     val = ctx.evaluate_value(z3_solver)
            #     print(val)
            #     # assert self.verify(val)

            del ctx
            if check_result != z3.unknown:
                return check_result == z3.sat

        assert check_result != z3.unknown
        return False

    def is_subset_of(self, other: _t_Predicate) -> bool:
        """Check if predicate is subset of another.

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if subset, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash
        """
        from core.predicates import GenericNotPredicate

        if not self.is_intersected_with(other):
            return False

        check_result = z3.unknown

        limitations = self.calculate_limitations()
        limitations.push(GenericNotPredicate[Any](predicate=other).calculate_limitations())
        for main_context, z3_solver in self._solver_iter(limitations.get_max_level()):
            ctx = VariableContext(main_context=main_context)
            main_context.set_limitations(limitations)

            z3_solver.add(self.to_z3(ctx))
            z3_solver.add(GenericNotPredicate[Any](predicate=other).to_z3(ctx))
            z3_solver.add(ctx.pop_from_global_constraints())

            check_result = z3_solver.check()
            # if check_result == z3.sat:
            #     val = ctx.evaluate_value(z3_solver)
            #     print(val)
            #     # assert self.verify(val)
            #     # assert (~other).verify(val)

            del ctx
            if check_result != z3.unknown:
                return check_result in [z3.unsat, z3.unknown]

        assert check_result != z3.unknown
        return False

    def is_superset_of(self, other: _t_Predicate) -> bool:
        """Check if predicate is superset of another.

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if superset, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash
        """
        from core.predicates import GenericNotPredicate

        if not self.is_intersected_with(other):
            return False

        check_result = z3.unknown

        limitation = (~self).calculate_limitations()
        limitation.push(other.calculate_limitations())

        for main_context, z3_solver in self._solver_iter(limitation.get_max_level()):
            ctx = VariableContext(main_context=main_context)

            main_context.set_limitations(limitation)

            z3_solver.add(other.to_z3(ctx))
            z3_solver.add(GenericNotPredicate[Any](predicate=self).to_z3(ctx))
            z3_solver.add(ctx.pop_from_global_constraints())

            check_result = z3_solver.check()

            # if check_result == z3.sat:
            #     val = ctx.evaluate_value(z3_solver)
            #     print(val)
            #     # assert (~self).verify(val)
            #     # assert other.verify(val)

            del ctx
            if check_result != z3.unknown:
                return check_result in [z3.unsat, z3.unknown]

        assert check_result != z3.unknown
        return False

    def is_intersected_with(self, other: _t_Predicate) -> bool:
        """Check if predicates intersect (have common solutions).

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if intersect, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash
        """

        check_result = z3.unknown

        limitations = self.calculate_limitations()
        limitations.push(other.calculate_limitations())
        for main_context, z3_solver in self._solver_iter(limitations.get_max_level()):
            ctx = VariableContext(main_context=main_context)
            main_context.set_limitations(limitations)

            z3_solver.add(self.to_z3(ctx))
            z3_solver.add(other.to_z3(ctx))
            z3_solver.add(ctx.pop_from_global_constraints())
            check_result = z3_solver.check()

            # if check_result == z3.sat:
            #     val = ctx.evaluate_value(z3_solver)
            #     print(val)
            #     # assert self.verify(val)
            #     # assert other.verify(val)

            del ctx

            if check_result != z3.unknown:
                return check_result == z3.sat

        assert check_result != z3.unknown
        return False

    def is_matched(self, value) -> bool:
        return self.verify(value)

    # def is_matched(self, value) -> bool:
    #     value_as_predicate = value_to_predicate(value)
    #
    #     check_result = z3.unknown
    #
    #     for z3_solver in self._solver_iter():
    #         ctx = VariableContext()
    #         ctx.set_limitations(self.calculate_limitations().push(value_as_predicate.calculate_limitations()))
    #
    #         z3_solver.add(self.to_z3(ctx))
    #         z3_solver.add(value_as_predicate.to_z3(ctx))
    #         z3_solver.add(ctx.to_global_constraints())
    #         check_result = z3_solver.check()
    #
    #         if check_result != z3.unknown:
    #             break
    #
    #     assert check_result != z3.unknown
    #     result = check_result == z3.sat
    #     # assert result == self.verify(value)
    #     return result

    def is_equivalent_to(self, other):
        """Check if predicates are equivalent.

        :param other: Predicate to compare
        :type other: BasePredicate
        :return: True if equivalent, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        # if not self.is_intersected_with(other):
        #     return False
        # if self.is_equal_to(other):
        #     return True

        return self.is_subset_of(other) and self.is_superset_of(other)


class _DefaultInvertedPredicate(BasePredicate):
    predicate: _t_Predicate

    def __invert__(self):
        return self.predicate

    def verify(self, value):
        return not self.predicate.verify(value)

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        return z3.Not(self.predicate.to_z3(ctx), ctx=ctx.z3_context)

    @property
    def predicate_types(self) -> set[PredicateType]:
        return self.predicate.predicate_types


class BaseScalarPredicate(BasePredicate, ABC):
    """Base class for scalar (single-type) predicates.

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    @property
    def predicate_type(self) -> PredicateType:
        """Get primary predicate type.

        :return: Primary predicate type
        :rtype: PredicateType

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        return list(self.predicate_types)[0]


class BaseCollectionPredicate(BasePredicate, ABC):
    """Base class for collection predicates (arrays/objects).

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    @abstractmethod
    @cached_property
    def compiled_value(self):
        pass


class BaseLogicalPredicate(BaseScalarPredicate, ABC):
    """Base class for logical operation predicates (AND/OR/NOT).

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    pass


_t_SpecifiedType = TypeVar('_t_SpecifiedType')


class ParityPredicateMixin(BasePredicate, ABC):
    _parity: bool = PrivateAttr(default=True)
