from abc import ABC, abstractmethod
from enum import Enum
from uuid import UUID, uuid4

import z3
from pydantic import Field
from typing_extensions import TypeVar

from core.bases.base_schema import BaseSchema
from core.predicates.helpers import value_to_predicate

PredicateTypeVar = TypeVar('PredicateTypeVar', bound='BasePredicate')
DEFAULT_SOLVER_TIMEOUT = 100000


class PredicateType(Enum):
    """Enumeration representing data types for predicates.

    :cvar Boolean: Boolean type (true/false)
    :cvar Integer: Integer number type
    :cvar Real: Real number type
    :cvar String: String type
    :cvar Object: JSON object type
    :cvar Array: Array type
    :cvar Null: Null type
    :cvar Any: Any type

    .. Docstring generated by Gemini 2.5 Flash
    """

    Boolean = 'Boolean'
    Integer = 'Integer'
    Real = 'Real'
    String = 'String'
    Object = 'Object'
    Array = 'Array'
    Null = 'Null'
    Any = 'Any'


class JsonDatatype:
    """Z3 Datatype for representing JSON-like structures with nested support.

    :ivar _JSON_TYPES: Cache for created JSON types by level
    :ivar MAX_NESTING_LEVEL: Maximum allowed nesting level (default: 100)

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    _JSON_TYPES = {}
    MAX_NESTING_LEVEL = 100

    def __init__(self, level: int | None) -> None:
        """Initialize JSON Datatype with specified nesting level.

        :param level: Nesting level for JSON structure (None for max level)
        :type level: int | None

        .. Docstring generated by Gemini 2.5 Flash
        """
        if not self._JSON_TYPES:
            self._build_json_type(level=self.MAX_NESTING_LEVEL)
        if level is None:
            level = max(self._JSON_TYPES.keys())
        self._level = level
        self._json_type = self._JSON_TYPES[self._level]
        self._var_id = uuid4()
        self._var = z3.Const(f'json_var_{self._var_id}', self._json_type)

    @property
    def level(self) -> int:
        """Get current nesting level.

        :return: Current nesting level
        :rtype: int

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._level

    @property
    def z3_variable(self) -> z3.DatatypeRef:
        """Get Z3 variable reference.

        :return: Z3 datatype variable
        :rtype: z3.DatatypeRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._var

    @classmethod
    def _build_json_type(cls, level: int = -1):
        """Build and cache Z3 Datatype for JSON representation.

        :param level: Nesting level for JSON type
        :type level: int
        :return: Constructed Z3 Datatype
        :rtype: z3.DatatypeRef

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        if cls._JSON_TYPES.get(level):
            return cls._JSON_TYPES[level]

        JsonType = z3.Datatype(f'JsonType_{level}')
        JsonType.declare('int', ('get_int', z3.IntSort()))
        JsonType.declare('bool', ('get_bool', z3.BoolSort()))
        JsonType.declare('str', ('get_str', z3.StringSort()))
        JsonType.declare('real', ('get_real', z3.RealSort()))

        if level > 0:
            NestedJsonType = cls._build_json_type(level - 1)
            NestedJsonArraySort = z3.ArraySort(z3.StringSort(), NestedJsonType)
            JsonType.declare(
                'object',
                ('get_object', NestedJsonArraySort),
                ('get_object_keys_quantity', z3.IntSort()),
                ('get_object_keys', z3.SetSort(z3.StringSort())),
            )

        JsonType = JsonType.create()
        cls._JSON_TYPES[level] = JsonType
        return JsonType

    def get_str(self) -> z3.SeqRef:
        """Get string value from JSON datatype.

        :return: Z3 string reference
        :rtype: z3.SeqRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.get_str(self._var)

    def get_real(self) -> z3.ArithRef:
        """Get real number value from JSON datatype.

        :return: Z3 real number reference
        :rtype: z3.ArithRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.get_real(self._var)

    def get_int(self) -> z3.ArithRef:
        """Get integer value from JSON datatype.

        :return: Z3 integer reference
        :rtype: z3.ArithRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.get_int(self._var)

    def get_bool(self) -> z3.BoolRef:
        """Get boolean value from JSON datatype.

        :return: Z3 boolean reference
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.get_bool(self._var)

    def get_object(self) -> z3.DatatypeRef:
        """Get object value from JSON datatype.

        :return: Z3 object reference
        :rtype: z3.DatatypeRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.get_object(self._var)

    def get_object_keys_quantity(self) -> z3.ArithRef:
        """Get count of object keys.

        :return: Z3 integer reference for key count
        :rtype: z3.ArithRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.get_object_keys_quantity(self._var)

    def get_object_keys(self) -> z3.ArrayRef:
        """Get object keys as Z3 array.

        :return: Z3 array reference for keys
        :rtype: z3.ArrayRef

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        return self._json_type.get_object_keys(self._var)

    def is_str(self):
        """Check if value is string type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.is_str(self._var)

    def is_real(self):
        """Check if value is real number type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.is_real(self._var)

    def is_int(self):
        """Check if value is integer type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.is_int(self._var)

    def is_bool(self):
        """Check if value is boolean type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.is_bool(self._var)

    def is_object(self):
        """Check if value is object type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_type.is_object(self._var)


class VariableContext:
    """Context manager for Z3 variables and constraints.

    Manages variable types, constraints, and nested contexts for predicate evaluation.

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    def __init__(self, level: int | None = None) -> None:
        """Initialize variable context.

        :param level: Nesting level for JSON (None for max level)
        :type level: int | None

        .. Docstring generated by Gemini 2.5 Flash
        """
        self._children = []
        self._var_type_constraints = {}
        self._global_constraints = []
        self._json_var = JsonDatatype(level=level)
        self._variables_by_type_mapping = {
            PredicateType.String: self._json_var.get_str(),
            PredicateType.Integer: self._json_var.get_int(),
            PredicateType.Real: self._json_var.get_real(),
            PredicateType.Boolean: self._json_var.get_bool(),
            PredicateType.Object: self._json_var.get_object(),
        }
        self._type_expressions_by_type_mapping = {
            PredicateType.String: self._json_var.is_str(),
            PredicateType.Integer: self._json_var.is_int(),
            PredicateType.Real: self._json_var.is_real(),
            PredicateType.Boolean: self._json_var.is_bool(),
            PredicateType.Object: self._json_var.is_object(),
        }

    @property
    def json_type_variable(self) -> JsonDatatype:
        """Get JSON datatype variable.

        :return: JSON datatype instance
        :rtype: JsonDatatype

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._json_var

    def create_child_context(self) -> 'VariableContext':
        """Create nested variable context with reduced level.

        :return: New child context
        :rtype: VariableContext

        .. Docstring generated by Gemini 2.5 Flash
        """
        child_context = VariableContext(level=self._json_var.level - 1)
        self._children.append(child_context)
        return child_context

    def push_to_global_constraints(self, expr: z3.ExprRef | bool) -> None:
        """Add constraint to global context.

        :param expr: Z3 expression or boolean to add
        :type expr: z3.ExprRef | bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        self._global_constraints.append(expr)

    def get_variable(self, predicate_type: PredicateType):
        """Get variable cast to specified type with type constraint.

        :param predicate_type: Target predicate type
        :type predicate_type: PredicateType
        :return: Z3 variable of specified type
        :rtype: z3.ExprRef
        :raises NotImplementedError: For unsupported predicate types

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        if predicate_type not in self._var_type_constraints:
            self._var_type_constraints[predicate_type] = self._generate_type_expression(predicate_type)

        if predicate_type in self._variables_by_type_mapping.keys():
            return self._variables_by_type_mapping[predicate_type]
        raise NotImplementedError(f'get_variable for predicate type {predicate_type} not implemented yet')

    def _generate_type_expression(self, predicate_type: PredicateType) -> z3.BoolRef:
        """Generate type constraint expression.

        :param predicate_type: Target predicate type
        :type predicate_type: PredicateType
        :return: Z3 boolean type constraint
        :rtype: z3.BoolRef

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        type_exprs = [
            type_expr if type_pt == predicate_type else z3.Not(type_expr)
            for type_pt, type_expr in self._type_expressions_by_type_mapping.items()
        ]
        return z3.And(type_exprs)

    def to_global_constraints(self) -> z3.BoolRef:
        """Combine all constraints into single expression.

        :return: Combined Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        type_expressions = list(self._var_type_constraints.values())
        if not type_expressions:
            type_one_of_expr = z3.BoolVal(True)
        else:
            type_one_of_expr = type_expressions[0]
            for type_expr in type_expressions[1:]:
                type_one_of_expr = z3.Xor(type_one_of_expr, type_expr)

        child_constraints = [child.to_global_constraints() for child in self._children]
        return z3.simplify(z3.And(type_one_of_expr, *self._global_constraints, *child_constraints))


class BasePredicate(BaseSchema, ABC):
    """Abstract base class for all predicate types.

    :ivar internal_id: Unique identifier for predicate
    :vartype internal_id: UUID

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    internal_id: UUID = Field(default_factory=uuid4, exclude=True)

    def __hash__(self):
        """Generate hash from internal ID.

        :return: Hash value
        :rtype: int

        .. Docstring generated by Gemini 2.5 Flash
        """
        return hash(self.internal_id)

    @abstractmethod
    def to_z3(self, var: VariableContext) -> z3.ExprRef:
        """Convert predicate to Z3 expression (abstract).

        :param var: Variable context
        :type var: VariableContext
        :return: Z3 logical expression
        :rtype: z3.ExprRef

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        ...

    @property
    @abstractmethod
    def predicate_types(self) -> set[PredicateType]:
        """Get supported predicate types (abstract).

        :return: Set of supported types
        :rtype: set[PredicateType]

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        ...

    def _setup_solver(self) -> z3.Solver:
        """Configure new Z3 solver with timeout.

        :return: Configured Z3 solver
        :rtype: z3.Solver

        .. Docstring generated by Gemini 2.5 Flash
        """
        solver = z3.Solver()
        solver.set("timeout", DEFAULT_SOLVER_TIMEOUT)
        return solver

    def is_subset_of(self, other: PredicateTypeVar) -> bool:
        """Check if predicate is subset of another.

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if subset, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        solver = self._setup_solver()
        ctx = VariableContext()
        solver.add(z3.And(self.to_z3(ctx), z3.Not(other.to_z3(ctx))))
        solver.add(ctx.to_global_constraints())
        result = solver.check()
        assert result != z3.unknown
        return result in [z3.unsat, z3.unknown]

    def is_superset_of(self, other: PredicateTypeVar) -> bool:
        """Check if predicate is superset of another.

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if superset, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        solver = self._setup_solver()
        ctx = VariableContext()
        solver.add(other.to_z3(ctx))
        solver.add(z3.Not(self.to_z3(ctx)))
        solver.add(ctx.to_global_constraints())
        result = solver.check()
        assert result != z3.unknown
        return result in [z3.unsat, z3.unknown]

    def is_intersected_with(self, other: PredicateTypeVar) -> bool:
        """Check if predicates intersect (have common solutions).

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if intersect, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        solver = self._setup_solver()
        ctx = VariableContext()
        solver.add(other.to_z3(ctx))
        solver.add(self.to_z3(ctx))
        solver.add(ctx.to_global_constraints())
        result = solver.check()
        assert result != z3.unknown
        return result == z3.sat

    def is_matched(self, value) -> bool:
        """Check if predicate matches given value.

        :param value: Value to test
        :type value: Any
        :return: True if matches, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        other = value_to_predicate(value)
        solver = self._setup_solver()
        ctx_1 = VariableContext()
        ctx_2 = VariableContext()
        solver.add(self.to_z3(ctx_1))
        solver.add(other.to_z3(ctx_2))
        solver.add(ctx_1.to_global_constraints())
        solver.add(ctx_2.to_global_constraints())
        solver.add(ctx_1.json_type_variable.z3_variable == ctx_2.json_type_variable.z3_variable)
        result = solver.check()
        assert result != z3.unknown
        return result == z3.sat

    def is_equivalent_to(self, other):
        """Check if predicates are equivalent.

        :param other: Predicate to compare
        :type other: BasePredicate
        :return: True if equivalent, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        return self.is_subset_of(other) and self.is_superset_of(other)


class BaseScalarPredicate(BasePredicate, ABC):
    """Base class for scalar (single-type) predicates.

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    @property
    def predicate_type(self) -> PredicateType:
        """Get primary predicate type.

        :return: Primary predicate type
        :rtype: PredicateType

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        return list(self.predicate_types)[0]


class BaseCollectionPredicate(BasePredicate, ABC):
    """Base class for collection predicates (arrays/objects).

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    pass


class BaseLogicalPredicate(BaseScalarPredicate, ABC):
    """Base class for logical operation predicates (AND/OR/NOT).

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    pass
