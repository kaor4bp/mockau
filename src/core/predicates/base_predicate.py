from abc import ABC, abstractmethod
from uuid import UUID, uuid4

import z3
from pydantic import Field
from typing_extensions import TypeVar

from core.bases.base_schema import BaseSchema
from core.predicates.consts import DEFAULT_SOLVER_TIMEOUT, PredicateType
from core.predicates.context.main_context import MainContext
from core.predicates.context.variable_context import PredicateLimitations, VariableContext

PredicateTypeVar = TypeVar('PredicateTypeVar', bound='BasePredicate')


t_Predicate = TypeVar('t_Predicate', bound='BasePredicate')

_DEFAULT_SOLVER = z3.Solver()
_DEFAULT_SOLVER.set("timeout", DEFAULT_SOLVER_TIMEOUT * 1000)
_CURRENT_Z3_CONTEXT = None


class BasePredicate(BaseSchema, ABC):
    """Abstract base class for all predicate types.

    :ivar internal_id: Unique identifier for predicate
    :vartype internal_id: UUID

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    internal_id: UUID = Field(default_factory=uuid4, exclude=True)

    def __invert__(self):
        return _DefaultInvertedPredicate(predicate=self)

    def get_nested_predicates(self):
        return [self]

    def get_z3_context(self):
        global _CURRENT_Z3_CONTEXT
        if _CURRENT_Z3_CONTEXT is None:
            _CURRENT_Z3_CONTEXT = z3.Context()
        return _CURRENT_Z3_CONTEXT

    @abstractmethod
    def verify(self, value):
        pass

    def __hash__(self):
        """Generate hash from internal ID.

        :return: Hash value
        :rtype: int

        .. Docstring generated by Gemini 2.5 Flash
        """
        return hash(self.internal_id)

    def __repr__(self):
        data = self.model_dump(mode='json', exclude={'internal_id', 'type_of'})
        data_repr = ', '.join([f'{k}={v}' for k, v in data.items()])
        return f'{self.__class__.__name__}({data_repr})'

    def calculate_limitations(self) -> PredicateLimitations:
        return PredicateLimitations()

    @abstractmethod
    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        """Convert predicate to Z3 expression (abstract).

        :param ctx: Variable context
        :type ctx: VariableContext
        :return: Z3 logical expression
        :rtype: z3.ExprRef

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        ...

    @property
    @abstractmethod
    def predicate_types(self) -> set[PredicateType]:
        """Get supported predicate types (abstract).

        :return: Set of supported types
        :rtype: set[PredicateType]

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        ...

    def _get_anti_hang_solver(self, max_nesting_level):
        main_ctx = MainContext(max_nesting_level=max_nesting_level)
        z3_solver = z3.Solver(ctx=main_ctx.z3_context)
        z3_solver.set("timeout", 5 * 1000)

        try:
            print('Using anti hang solver')
            yield main_ctx, z3_solver
        except z3.Z3Exception as e:
            print(f'Anti hang exception: {e}')
        finally:
            del z3_solver
            del main_ctx

    def _solver_iter(self, max_nesting_level=100):
        # _DEFAULT_SOLVER.reset()
        # _DEFAULT_SOLVER.push()
        # try:
        #     print('Using default solver')
        #     yield _DEFAULT_SOLVER
        # finally:
        #     _DEFAULT_SOLVER.pop()

        # yield from self._get_anti_hang_solver()

        print(max_nesting_level)
        max_nesting_level = 100

        for set_timeout in [DEFAULT_SOLVER_TIMEOUT]:
            for set_tactic in [
                None,
                'qfauflia',
                'simplify',
                'propagate-values',
                'smt',
                'solve-eqs',
                'tseitin-cnf',
                'ctx-solver-simplify',
            ]:
                main_ctx = MainContext(max_nesting_level=max_nesting_level)
                if set_tactic is None:
                    solver = z3.Solver(ctx=main_ctx.z3_context)
                else:
                    solver = z3.Tactic(set_tactic, ctx=main_ctx.z3_context).solver()
                solver.set("timeout", set_timeout * 1000)

                try:
                    print(f'Using solver {set_tactic} with timeout {set_timeout}')
                    yield main_ctx, solver
                finally:
                    del solver
                    del main_ctx

                yield from self._get_anti_hang_solver(max_nesting_level)

    def is_consistent(self) -> bool:
        check_result = z3.unknown

        limitations = self.calculate_limitations()
        for main_context, z3_solver in self._solver_iter(limitations.get_max_level()):
            ctx = VariableContext(main_context=main_context)
            main_context.set_limitations(limitations)

            z3_solver.add(self.to_z3(ctx))
            z3_solver.add(ctx.pop_from_global_constraints())

            check_result = z3_solver.check()

            # if check_result == z3.sat:
            #     val = ctx.evaluate_value(z3_solver)
            #     print(val)
            #     # assert self.verify(val)

            del ctx
            if check_result != z3.unknown:
                break

        assert check_result != z3.unknown
        return check_result == z3.sat

    def is_subset_of(self, other: PredicateTypeVar) -> bool:
        """Check if predicate is subset of another.

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if subset, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash
        """
        from core.predicates.logical.logical_predicates import NotPredicate

        if not self.is_intersected_with(other):
            return False

        check_result = z3.unknown

        limitations = self.calculate_limitations()
        limitations.push((~other).calculate_limitations())
        for main_context, z3_solver in self._solver_iter(limitations.get_max_level()):
            ctx = VariableContext(main_context=main_context)
            main_context.set_limitations(limitations)

            z3_solver.add(self.to_z3(ctx))
            z3_solver.add(NotPredicate(predicate=other, preserve_type=False).to_z3(ctx))
            z3_solver.add(ctx.pop_from_global_constraints())

            check_result = z3_solver.check()

            # if check_result == z3.sat:
            #     val = ctx.evaluate_value(z3_solver)
            #     print(val)
            #     # assert self.verify(val)
            #     # assert (~other).verify(val)

            del ctx
            if check_result != z3.unknown:
                break

        assert check_result != z3.unknown
        return check_result in [z3.unsat, z3.unknown]

    def is_superset_of(self, other: PredicateTypeVar) -> bool:
        """Check if predicate is superset of another.

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if superset, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash
        """
        from core.predicates.logical.logical_predicates import NotPredicate

        if not self.is_intersected_with(other):
            return False

        check_result = z3.unknown

        for main_context, z3_solver in self._solver_iter():
            ctx = VariableContext(main_context=main_context)

            limitation = (~self).calculate_limitations()
            limitation.push(other.calculate_limitations())
            main_context.set_limitations(limitation)

            z3_solver.add(other.to_z3(ctx))
            z3_solver.add(NotPredicate(predicate=self, preserve_type=False).to_z3(ctx))
            z3_solver.add(ctx.pop_from_global_constraints())

            check_result = z3_solver.check()

            # if check_result == z3.sat:
            #     val = ctx.evaluate_value(z3_solver)
            #     print(val)
            #     # assert (~self).verify(val)
            #     # assert other.verify(val)

            del ctx
            if check_result != z3.unknown:
                break

        assert check_result != z3.unknown
        return check_result in [z3.unsat, z3.unknown]

    def is_intersected_with(self, other: PredicateTypeVar) -> bool:
        """Check if predicates intersect (have common solutions).

        :param other: Predicate to compare
        :type other: PredicateTypeVar
        :return: True if intersect, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash
        """

        check_result = z3.unknown

        limitations = self.calculate_limitations()
        limitations.push(other.calculate_limitations())
        for main_context, z3_solver in self._solver_iter(limitations.get_max_level()):
            ctx = VariableContext(main_context=main_context)
            main_context.set_limitations(limitations)

            limitation = self.calculate_limitations()
            limitation.push(other.calculate_limitations())
            main_context.set_limitations(limitation)

            z3_solver.add(self.to_z3(ctx))
            z3_solver.add(other.to_z3(ctx))
            z3_solver.add(ctx.pop_from_global_constraints())

            check_result = z3_solver.check()

            # if check_result == z3.sat:
            #     val = ctx.evaluate_value(z3_solver)
            #     print(val)
            #     # assert self.verify(val)
            #     # assert other.verify(val)

            del ctx

            if check_result != z3.unknown:
                break

        assert check_result != z3.unknown
        return check_result == z3.sat

    def is_matched(self, value) -> bool:
        return self.verify(value)

    # def is_matched(self, value) -> bool:
    #     value_as_predicate = value_to_predicate(value)
    #
    #     check_result = z3.unknown
    #
    #     for z3_solver in self._solver_iter():
    #         ctx = VariableContext()
    #         ctx.set_limitations(self.calculate_limitations().push(value_as_predicate.calculate_limitations()))
    #
    #         z3_solver.add(self.to_z3(ctx))
    #         z3_solver.add(value_as_predicate.to_z3(ctx))
    #         z3_solver.add(ctx.to_global_constraints())
    #         check_result = z3_solver.check()
    #
    #         if check_result != z3.unknown:
    #             break
    #
    #     assert check_result != z3.unknown
    #     result = check_result == z3.sat
    #     # assert result == self.verify(value)
    #     return result

    def is_equivalent_to(self, other):
        """Check if predicates are equivalent.

        :param other: Predicate to compare
        :type other: BasePredicate
        :return: True if equivalent, False otherwise
        :rtype: bool

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        # if not self.is_intersected_with(other):
        #     return False
        return self.is_subset_of(other) and self.is_superset_of(other)


class _DefaultInvertedPredicate(BasePredicate):
    predicate: t_Predicate

    def __invert__(self):
        return self.predicate

    def verify(self, value):
        return not self.predicate.verify(value)

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        return z3.Not(self.predicate.to_z3(ctx), ctx=ctx.z3_context)

    @property
    def predicate_types(self) -> set[PredicateType]:
        return self.predicate.predicate_types


class BaseScalarPredicate(BasePredicate, ABC):
    """Base class for scalar (single-type) predicates.

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    @property
    def predicate_type(self) -> PredicateType:
        """Get primary predicate type.

        :return: Primary predicate type
        :rtype: PredicateType

        .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
        """
        return list(self.predicate_types)[0]


class BaseCollectionPredicate(BasePredicate, ABC):
    """Base class for collection predicates (arrays/objects).

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    @abstractmethod
    def get_nested_predicates(self):
        pass


class BaseLogicalPredicate(BaseScalarPredicate, ABC):
    """Base class for logical operation predicates (AND/OR/NOT).

    .. Docstring created by Gemini 2.5 Flash, modified by DeepSeek-V3 (2024)
    """

    pass
