import z3

from core.predicates.consts import PredicateType


class JsonDatatypeWrapper:
    def __init__(self, var, datatype, z3_context) -> None:
        self._var = var
        self._datatype = datatype
        self._z3_context = z3_context

        self._type_expressions_by_type_mapping = {
            PredicateType.String: self.is_str(),
            PredicateType.Integer: self.is_int(),
            PredicateType.Real: self.is_real(),
            PredicateType.Boolean: self.is_bool(),
            PredicateType.Object: self.is_object(),
            PredicateType.Array: self.is_array(),
            PredicateType.Null: self.is_null(),
            PredicateType.Undefined: self.is_undefined(),
        }
        self._variables_by_type_mapping = {
            PredicateType.String: self.get_str(),
            PredicateType.Integer: self.get_int(),
            PredicateType.Real: self.get_real(),
            PredicateType.Boolean: self.get_bool(),
            PredicateType.Object: self.get_object(),
            PredicateType.Array: self.get_array(),
            PredicateType.Null: None,
            PredicateType.Any: None,
            PredicateType.Undefined: None,
        }

    def is_expression_by_type(self, predicate_type: PredicateType):
        return self._type_expressions_by_type_mapping[predicate_type]

    def get_expression_by_type(self, predicate_type: PredicateType):
        return self._variables_by_type_mapping[predicate_type]

    def build_type_expression(self, predicate_type: PredicateType) -> z3.BoolRef:
        type_expressions = [
            current_type_expr
            if current_type == predicate_type or predicate_type is PredicateType.Any
            else z3.Not(current_type_expr, ctx=self._z3_context)
            for current_type, current_type_expr in self._type_expressions_by_type_mapping.items()
        ]
        if predicate_type is PredicateType.Any:
            type_expressions.append(z3.BoolVal(False, ctx=self._z3_context))
            combined_type_expression = z3.Or(type_expressions)
        else:
            type_expressions.append(z3.BoolVal(True, ctx=self._z3_context))
            combined_type_expression = z3.And(type_expressions)
        return combined_type_expression

    @property
    def z3_variable(self) -> z3.DatatypeRef:
        """Get Z3 variable reference.

        :return: Z3 datatype variable
        :rtype: z3.DatatypeRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._var

    # Type checkers
    def is_bool(self):
        """Check if value is boolean type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.is_bool(self._var)

    def is_int(self):
        """Check if value is integer type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.is_int(self._var)

    def is_real(self):
        """Check if value is real number type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.is_real(self._var)

    def is_str(self):
        """Check if value is string type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.is_str(self._var)

    def is_array(self) -> z3.ArrayRef:
        return self._datatype.is_array(self._var)

    def is_object(self):
        """Check if value is object type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.is_object(self._var)

    def is_null(self) -> z3.ArrayRef:
        return self._datatype.is_null(self._var)

    def is_undefined(self):
        return self._datatype.is_undefined(self._var)

    # Value getters
    def get_bool(self) -> z3.BoolRef:
        """Get boolean value from JSON datatype.

        :return: Z3 boolean reference
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.get_bool(self._var)

    def get_int(self) -> z3.ArithRef:
        """Get integer value from JSON datatype.

        :return: Z3 integer reference
        :rtype: z3.ArithRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.get_int(self._var)

    def get_real(self) -> z3.ArithRef:
        """Get real number value from JSON datatype.

        :return: Z3 real number reference
        :rtype: z3.ArithRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.get_real(self._var)

    def get_str(self) -> z3.SeqRef:
        """Get string value from JSON datatype.

        :return: Z3 string reference
        :rtype: z3.SeqRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.get_str(self._var)

    def get_array(self) -> z3.ArrayRef:
        return self._datatype.get_array(self._var)

    def get_object(self) -> z3.DatatypeRef:
        """Get object value from JSON datatype.

        :return: Z3 object reference
        :rtype: z3.DatatypeRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.get_object(self._var)


def build_json_datatype(z3_context: z3.Context, level: int, max_nesting_level: int):
    result = {}

    json_datatype = z3.Datatype(f'JsonType_{level}', ctx=z3_context)
    json_datatype.declare('int', ('get_int', z3.IntSort(ctx=z3_context)))
    json_datatype.declare('bool', ('get_bool', z3.BoolSort(ctx=z3_context)))
    json_datatype.declare('str', ('get_str', z3.StringSort(ctx=z3_context)))
    json_datatype.declare('real', ('get_real', z3.RealSort(ctx=z3_context)))
    json_datatype.declare('null')
    json_datatype.declare('undefined')

    if level < max_nesting_level:
        result.update(
            build_json_datatype(
                z3_context=z3_context,
                level=level + 1,
                max_nesting_level=max_nesting_level,
            )
        )
        nested_json_datatype = result[level + 1]
        json_datatype.declare(
            'object',
            ('get_object', z3.ArraySort(z3.StringSort(ctx=z3_context), nested_json_datatype)),
        )
        json_datatype.declare(
            'array',
            ('get_array', z3.SeqSort(nested_json_datatype)),
        )

    json_datatype_sort = json_datatype.create()
    result[level] = json_datatype_sort
    return result
