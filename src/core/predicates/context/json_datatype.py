import z3

from core.predicates.consts import PredicateType


class JsonDatatypeWrapper:
    def __init__(self, var, datatype, z3_context) -> None:
        self._var = var
        self._datatype = datatype
        self._z3_context = z3_context

    def equal_to(self, other: 'JsonDatatypeWrapper'):
        return z3.And(
            z3.Implies(
                self.is_str(),
                self.get_str() == other.get_str(),
            ),
            z3.Implies(
                self.is_int(),
                self.get_int() == other.get_int(),
            ),
            z3.Implies(
                self.is_real(),
                self.get_real() == other.get_real(),
            ),
            z3.Implies(
                self.is_bool(),
                self.get_bool() == other.get_bool(),
            ),
            z3.Implies(
                self.is_object(),
                self.get_object() == other.get_object(),
            ),
            z3.Implies(
                self.is_array(),
                self.get_array() == other.get_array(),
            ),
            self.is_null() == other.is_null(),
            self.is_undefined() == other.is_undefined(),
        )

    def is_expression_by_type(self, predicate_type: PredicateType):
        if predicate_type == PredicateType.String:
            return self.is_str()
        if predicate_type == PredicateType.Integer:
            return self.is_int()
        if predicate_type == PredicateType.Real:
            return self.is_real()
        if predicate_type == PredicateType.Boolean:
            return self.is_bool()
        if predicate_type == PredicateType.Object:
            return self.is_object()
        if predicate_type == PredicateType.Array:
            return self.is_array()
        if predicate_type == PredicateType.Null:
            return self.is_null()
        if predicate_type == PredicateType.Any:
            return z3.BoolVal(True, ctx=self._z3_context)
            # return z3.Or(
            #     self.is_str(),
            #     self.is_int(),
            #     self.is_real(),
            #     self.is_bool(),
            #     self.is_object(),
            #     self.is_array(),
            #     self.is_null(),
            # )
        if predicate_type == PredicateType.Undefined:
            return self.is_undefined()
        raise ValueError(f"Unknown predicate type: {predicate_type}")

    def get_expression_by_type(self, predicate_type: PredicateType):
        if predicate_type == PredicateType.String:
            return self.get_str()
        if predicate_type == PredicateType.Integer:
            return self.get_int()
        if predicate_type == PredicateType.Real:
            return self.get_real()
        if predicate_type == PredicateType.Boolean:
            return self.get_bool()
        if predicate_type == PredicateType.Object:
            return self.get_object()
        if predicate_type == PredicateType.Array:
            return self.get_array()
        if predicate_type == PredicateType.Null:
            return None
        if predicate_type == PredicateType.Any:
            return None
        if predicate_type == PredicateType.Undefined:
            return None
        raise ValueError(f"Unknown predicate type: {predicate_type}")

    @property
    def z3_variable(self) -> z3.DatatypeRef:
        """Get Z3 variable reference.

        :return: Z3 datatype variable
        :rtype: z3.DatatypeRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._var

    # Type checkers
    def is_bool(self):
        """Check if value is boolean type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.is_bool(self._var)

    def is_int(self):
        """Check if value is integer type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.is_int(self._var)

    def is_real(self):
        """Check if value is real number type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.is_real(self._var)

    def is_str(self):
        """Check if value is string type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.is_str(self._var)

    def is_array(self) -> z3.ArrayRef:
        return self._datatype.is_array(self._var)

    def is_object(self):
        """Check if value is object type.

        :return: Z3 boolean expression
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.is_object(self._var)

    def is_null(self) -> z3.ArrayRef:
        return self._datatype.is_null(self._var)

    def is_undefined(self):
        return self._datatype.is_undefined(self._var)

    # Value getters
    def get_bool(self) -> z3.BoolRef:
        """Get boolean value from JSON datatype.

        :return: Z3 boolean reference
        :rtype: z3.BoolRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.get_bool(self._var)

    def get_int(self) -> z3.ArithRef:
        """Get integer value from JSON datatype.

        :return: Z3 integer reference
        :rtype: z3.ArithRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.get_int(self._var)

    def get_real(self) -> z3.ArithRef:
        """Get real number value from JSON datatype.

        :return: Z3 real number reference
        :rtype: z3.ArithRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.get_real(self._var)

    def get_str(self) -> z3.SeqRef:
        """Get string value from JSON datatype.

        :return: Z3 string reference
        :rtype: z3.SeqRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.get_str(self._var)

    def get_array(self) -> z3.ArrayRef:
        return self._datatype.get_array(self._var)

    def get_object(self) -> z3.DatatypeRef:
        """Get object value from JSON datatype.

        :return: Z3 object reference
        :rtype: z3.DatatypeRef

        .. Docstring generated by Gemini 2.5 Flash
        """
        return self._datatype.get_object(self._var)


def build_json_datatype(z3_context: z3.Context, level: int, max_nesting_level: int):
    result = {}

    json_datatype = z3.Datatype(f'JsonType_{level}', ctx=z3_context)
    json_datatype.declare('int', ('get_int', z3.IntSort(ctx=z3_context)))
    json_datatype.declare('bool', ('get_bool', z3.BoolSort(ctx=z3_context)))
    json_datatype.declare('str', ('get_str', z3.StringSort(ctx=z3_context)))
    json_datatype.declare('real', ('get_real', z3.RealSort(ctx=z3_context)))
    json_datatype.declare('null')
    json_datatype.declare('undefined')

    if level < max_nesting_level:
        result.update(
            build_json_datatype(
                z3_context=z3_context,
                level=level + 1,
                max_nesting_level=max_nesting_level,
            )
        )
        nested_json_datatype = result[level + 1]
        json_datatype.declare(
            'object',
            ('get_object', z3.ArraySort(z3.StringSort(ctx=z3_context), nested_json_datatype)),
        )
        json_datatype.declare(
            'array',
            ('get_array', z3.SeqSort(nested_json_datatype)),
        )

    json_datatype_sort = json_datatype.create()
    result[level] = json_datatype_sort
    return result
