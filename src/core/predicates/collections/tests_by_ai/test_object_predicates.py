# Generated by Gemini AI 2.5 Pro
import pytest

from core.predicates.collections.object_predicates import ObjectContainsSubset, ObjectEqualTo
from core.predicates.logical.logical_predicates import AndPredicate, AnyPredicate, NotPredicate, OrPredicate
from core.predicates.scalars import (
    IntegerEqualTo,
    IntegerGreaterOrEqualThan,
    IntegerGreaterThan,
    IntegerLessOrEqualThan,
    IntegerLessThan,
    NumberEqualTo,
    StringContains,
    StringEqualTo,
    StringPattern,
)
from utils.formatters import get_params_argv

# Rebuild Pydantic models
NotPredicate.model_rebuild()
AndPredicate.model_rebuild()
OrPredicate.model_rebuild()
ObjectEqualTo.model_rebuild()
ObjectContainsSubset.model_rebuild()

NOT_INTERSECTIONS = {
    'obj_eq_lol_kek_vs_obj_eq_lol_kek_hello_world': [  # Different key sets for ObjectEqualTo
        ObjectEqualTo(value={'lol': 'kek'}),
        ObjectEqualTo(value={'lol': 'kek', 'hello': 'world'}),
    ],
    'nested_dict_different_structures_eq': [
        ObjectEqualTo(
            value={
                StringContains(value='llo'): {'lol': 'kek'},  # e.g. {"hello": {"lol": "kek"}}
            }
        ),
        ObjectEqualTo(
            value={
                StringContains(value='hello'): ObjectEqualTo(
                    value={'lol': StringContains(value='cheburek'), 'new_key': 1}
                ),
                # e.g. {"hello": {"lol": "cheburek", "new_key": 1}}
            }
        ),  # If "hello" matches both, inner dicts are different.
    ],
    'obj_eq_key_a_val_1_vs_obj_eq_key_b_val_1': [ObjectEqualTo(value={'a': 1}), ObjectEqualTo(value={'b': 1})],
    'obj_eq_val_predicate_mismatch': [
        ObjectEqualTo(value={'data': IntegerGreaterThan(value=5)}),
        ObjectEqualTo(value={'data': IntegerLessThan(value=0)}),
    ],
}

INTERSECTIONS = {
    'obj_eq_lol_kek_self_intersect': [ObjectEqualTo(value={'lol': 'kek'}), ObjectEqualTo(value={'lol': 'kek'})],
    'nested_dict_predicate_key_intersect': [  # Key "hello" can match StringContains('llo') and StringContains('hello')
        ObjectEqualTo(
            value={
                StringContains(value='llo'): {'lol': 'kek'},  # Matches e.g. {"hello": {"lol": "kek"}}
            }
        ),
        ObjectEqualTo(
            value={
                StringContains(value='hello'): ObjectEqualTo(value={'lol': StringContains(value='kek')}),
                # Matches e.g. {"hello": {"lol": "superkek"}}
            }
        ),  # Intersects if an object like {"hello": {"lol": "kek"}} exists
    ],
    'obj_eq_val_predicate_intersect': [
        ObjectEqualTo(value={'count': IntegerGreaterThan(value=4)}),  # count > 4
        ObjectEqualTo(value={'count': IntegerLessThan(value=10)}),  # count < 10
        # Intersects for count in (4, 10)
    ],
    'concurrent_predicate_keys_intersect_1': [  # Original test
        ObjectEqualTo(
            value={
                StringContains(value='ello'): IntegerGreaterThan(value=4),  # key "hello", value > 4
                StringContains(value='ell'): IntegerGreaterThan(value=1),  # key "hello", value > 1
            }
        ),
        ObjectEqualTo(
            value={  # Test against concrete keys
                'hello': IntegerGreaterThan(value=5),  # e.g. hello: 6 (satisfies >4, >1, >5)
                'hello_world': IntegerLessThan(value=3),  # e.g. hello_world: 2
            }
        ),  # Intersects if e.g. obj = {'hello': 6, 'hello_world': 2}
    ],
    'obj_contains_subset_intersect': [
        ObjectContainsSubset(value={'a': 1, 'b': StringContains(value='x')}),
        ObjectContainsSubset(value={'b': StringEqualTo(value='xyz'), 'c': 3}),
        # Intersects if e.g. {'a': 1, 'b': 'xyz', 'c': 3, 'd': 4}
    ],
    'and_predicate_intersect': [  # Original test
        AndPredicate(
            predicates=[
                ObjectEqualTo(value={'lol': StringContains(value='hello')}),
                ObjectEqualTo(value={'lol': StringContains(value='world')}),
            ]
        ),  # This means lol must contain "hello" AND "world"
        ObjectEqualTo(value={'lol': 'hello world'}),  # This is one such value
    ],
    'not_predicate_intersect_example': [  # Original test
        NotPredicate(predicate=ObjectContainsSubset(value={'admin': StringEqualTo(value='true')})),  # Not admin user
        ObjectEqualTo(value={'department': StringEqualTo(value='sales')}),  # User in sales
        # Intersects if a sales user is not an admin
    ],
    'any_predicate_value_intersects': [
        ObjectEqualTo(value={'key': AnyPredicate()}),
        ObjectEqualTo(value={'key': IntegerEqualTo(value=5)}),
    ],
}

EQUIVALENTS = {
    'obj_eq_simple_self_equivalent': [ObjectEqualTo(value={'lol': 'kek'}), ObjectEqualTo(value={'lol': 'kek'})],
    'obj_eq_val_str_contains_equiv_str_pattern': [
        ObjectEqualTo(value={'text': StringContains(value='hello')}),
        ObjectEqualTo(value={'text': StringPattern(pattern='.*hello.*')}),
    ],
    'obj_eq_val_int_eq_1_equiv_logical_int': [
        ObjectEqualTo(value={'num': IntegerEqualTo(value=1)}),
        AndPredicate(
            predicates=[
                ObjectEqualTo(value={'num': NotPredicate(predicate=IntegerGreaterThan(value=1))}),
                ObjectEqualTo(value={'num': NotPredicate(predicate=IntegerLessThan(value=1))}),
            ]
        ),
    ],
    'obj_eq_val_int_ge_1_equiv_logical_int': [
        ObjectEqualTo(value={'num': IntegerGreaterOrEqualThan(value=1)}),
        OrPredicate(
            predicates=[
                ObjectEqualTo(value={'num': IntegerGreaterThan(value=1)}),
                ObjectEqualTo(value={'num': IntegerEqualTo(value=1)}),
            ]
        ),
    ],
    'obj_eq_nested_val_int_ge_1_equiv_logical_int': [
        ObjectEqualTo(value={'data': {'count': IntegerGreaterOrEqualThan(value=1)}}),
        OrPredicate(
            predicates=[
                ObjectEqualTo(value={'data': {'count': IntegerGreaterThan(value=1)}}),
                ObjectEqualTo(value={'data': {'count': IntegerEqualTo(value=1)}}),
            ]
        ),
    ],
    'obj_eq_val_range_1_lt_x_lt_5_equiv_logical_int_range': [  # Name from original
        AndPredicate(  # Object with 'field' > 1 AND 'field' < 5
            predicates=[
                ObjectEqualTo(value={'field': IntegerGreaterThan(value=1)}),
                ObjectEqualTo(value={'field': IntegerLessThan(value=5)}),
            ]
        ),
        AndPredicate(  # Object with 'field' >=1 AND 'field' <=5 AND 'field' != 1 AND 'field' != 5
            predicates=[
                ObjectEqualTo(value={'field': IntegerGreaterOrEqualThan(value=1)}),
                ObjectEqualTo(value={'field': IntegerLessOrEqualThan(value=5)}),
                ObjectEqualTo(value={'field': NotPredicate(predicate=IntegerEqualTo(value=1))}),
                ObjectEqualTo(value={'field': NotPredicate(predicate=IntegerEqualTo(value=5))}),
            ]
        ),
    ],
    'empty_obj_eq_empty_obj': [ObjectEqualTo(value={}), ObjectEqualTo(value={})],
    'obj_contains_subset_empty_equiv_empty': [ObjectContainsSubset(value={}), ObjectContainsSubset(value={})],
}

SUPERSETS = {
    'obj_contains_subset_more_keys_supset_fewer_keys': [
        ObjectContainsSubset(value={'lol': 'kek'}),  # Superset: requires {'lol':'kek'} to be present
        ObjectContainsSubset(value={'lol': 'kek', 'hello': 'world'}),  # Subset: requires {'lol':'kek', 'hello':'world'}
    ],
    'obj_contains_subset_supset_obj_eq': [
        ObjectContainsSubset(value={'lol': 'kek'}),  # Superset: allows other keys
        ObjectEqualTo(value={'lol': 'kek'}),  # Subset: requires *only* this key-value
    ],
    'obj_eq_val_str_contains_supset_obj_eq_val_str_eq': [
        ObjectEqualTo(value={'text': StringContains(value='value')}),  # Superset: text contains 'value'
        ObjectEqualTo(value={'text': StringEqualTo(value='exact value')}),  # Subset: text is 'exact value'
    ],
    'any_obj_supset_specific_obj_eq': [
        AnyPredicate(),  # Represents matching any object
        ObjectEqualTo(value={'a': 1}),
    ],
    'obj_contains_subset_A_supset_obj_contains_subset_A_and_B': [
        ObjectContainsSubset(value={'key1': 'val1'}),
        ObjectContainsSubset(value={'key1': 'val1', 'key2': 'val2'}),
    ],
    'obj_eq_any_value_supset_obj_eq_specific_value': [
        ObjectEqualTo(value={'field': AnyPredicate()}),
        ObjectEqualTo(value={'field': IntegerEqualTo(value=10)}),
    ],
}


class TestObjectIsNotIntersectedWith:  # For cases that should explicitly not intersect
    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_not_intersections_are_not_intersected(self, p1, p2):
        assert not p1.is_intersected_with(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_not_intersections_are_symmetrical_not_intersected(self, p1, p2):
        assert not p2.is_intersected_with(p1)


class TestObjectIsSubsetOf:
    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_one_equivalent_is_subset_of_another(self, p1, p2):
        # For the AnyPredicate special case in EQUIVALENTS:
        if p1 == ObjectContainsSubset(value={}) and p2 == AnyPredicate():
            # ObjectContainsSubset({}) is a subset of AnyPredicate() (matches all dicts vs matches all)
            # but AnyPredicate() is not necessarily a subset of ObjectContainsSubset({})
            # This specific equivalence needs careful thought for subset relationship.
            # Let's assume AnyPredicate is broader or equal.
            assert p1.is_subset_of(p2)
            # The reverse, p2.is_subset_of(p1), might be false if AnyPredicate can match non-dicts.
            return
        assert p1.is_subset_of(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_subset_is_subset_of_superset(self, p1, p2):  # p2 is subset, p1 is superset
        assert p2.is_subset_of(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_superset_is_not_subset_of_subset(self, p1, p2):  # p1 is superset, p2 is subset
        if not p1.is_equivalent_to(p2):  # Unless they are equivalent (e.g. AnyPredicate)
            assert not p1.is_subset_of(p2)
        else:
            assert p1.is_subset_of(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_subset_of_equivalents_is_symmetric(self, p1, p2):
        if p1 == ObjectContainsSubset(value={}) and p2 == AnyPredicate():
            assert p1.is_subset_of(p2)  # ObjectContainsSubset({}) is subset of Any
            # AnyPredicate is not subset of ObjectContainsSubset({}) if Any can match non-dicts
            if isinstance(AnyPredicate().is_matched("string"), bool):  # Crude check if Any can match non-dict
                assert not p2.is_subset_of(p1)
            else:  # If Any only works for dicts in this context
                assert p2.is_subset_of(p1)

            return
        assert p2.is_subset_of(p1)


class TestObjectIsSupersetOf:
    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_superset_is_superset_of_subset(self, p1, p2):  # p1 is superset, p2 is subset
        assert p1.is_superset_of(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_subset_is_not_superset_of_superset(self, p1, p2):  # p2 is subset, p1 is superset
        if not p2.is_equivalent_to(p1):
            assert not p2.is_superset_of(p1)
        else:
            assert p2.is_superset_of(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_one_equivalent_is_superset_of_another(self, p1, p2):
        if p2 == ObjectContainsSubset(value={}) and p1 == AnyPredicate():
            assert p1.is_superset_of(p2)  # Any is superset of ObjectContainsSubset({})
            return
        assert p1.is_superset_of(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_superset_of_equivalents_is_symmetric(self, p1, p2):
        if p1 == ObjectContainsSubset(value={}) and p2 == AnyPredicate():
            assert p1.is_superset_of(p2)
            # Check if AnyPredicate (p2) is superset of ObjectContainsSubset({}) (p1)
            assert p2.is_superset_of(p1)  # If Any can match non-dicts, this holds.
            return
        assert p2.is_superset_of(p1)


class TestObjectIsIntersectedWith:
    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(INTERSECTIONS))
    def test_intersections_are_intersected(self, p1, p2):
        assert p1.is_intersected_with(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(INTERSECTIONS))
    def test_intersections_are_symmetrical_intersected(self, p1, p2):
        assert p2.is_intersected_with(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_intersected(self, p1, p2):
        assert p1.is_intersected_with(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_symmetrically_intersected(self, p1, p2):
        assert p2.is_intersected_with(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_superset_and_subset_are_intersected(self, p1, p2):
        assert p2.is_intersected_with(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_subset_and_superset_are_symmetrically_intersectable(self, p1, p2):
        assert p1.is_intersected_with(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_not_intersections_are_not_intersected_explicit(self, p1, p2):  # Renamed to avoid clash
        assert not p1.is_intersected_with(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_not_intersections_are_symmetrical_not_intersected_explicit(self, p1, p2):  # Renamed
        assert not p2.is_intersected_with(p1)


# TestObjectIsEquivalentTo is missing from original, adding it.
class TestObjectIsEquivalentTo:
    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_equivalent(self, p1, p2):
        assert p1.is_equivalent_to(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(EQUIVALENTS))
    def test_equivalents_are_symmetrically_equivalent(self, p1, p2):
        assert p2.is_equivalent_to(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_subset_is_not_equivalent_to_superset(self, p1, p2):
        if p1.is_equivalent_to(p2):
            return  # Handles AnyPredicate cases
        assert not p2.is_equivalent_to(p1)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(SUPERSETS))
    def test_superset_is_not_equivalent_to_subset(self, p1, p2):
        if p1.is_equivalent_to(p2):
            return
        assert not p1.is_equivalent_to(p2)

    @pytest.mark.parametrize(['p1', 'p2'], **get_params_argv(NOT_INTERSECTIONS))
    def test_non_intersecting_are_not_equivalent(self, p1, p2):
        assert not p1.is_equivalent_to(p2)


MATCHED = {
    'simple_dict_eq': [ObjectEqualTo(value={'lol': 'kek'}), {'lol': 'kek'}],
    'nested_dict_eq': [
        ObjectEqualTo(value={'hello': {'lol': 'kek'}}),
        {'hello': {'lol': 'kek'}},
    ],
    'with_scalar_predicates_eq': [
        ObjectEqualTo(value={'key1': StringContains(value='ello'), 'key2': IntegerGreaterThan(value=10)}),
        {'key1': 'hello world', 'key2': 15},
    ],
    'with_nested_predicates_eq': [
        ObjectEqualTo(value={'key1': ObjectEqualTo(value={'nested': 'value'}), 'key2': IntegerGreaterThan(value=10)}),
        {'key1': {'nested': 'value'}, 'key2': 15},
    ],
    'subset_matching_simple': [ObjectContainsSubset(value={'key1': 'value1'}), {'key1': 'value1', 'key2': 'value2'}],
    'nested_subset_matching': [
        ObjectContainsSubset(value={'level1': ObjectContainsSubset(value={'level2': 'value'})}),
        {'level1': {'level2': 'value', 'extra': 'data'}, 'other': 'info'},
    ],
    'and_predicate_obj_subset': [  # From original
        AndPredicate(
            predicates=[ObjectContainsSubset(value={'key1': 'value1'}), ObjectContainsSubset(value={'key2': 'value2'})]
        ),
        {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'},
    ],
    'or_predicate_obj_eq': [  # From original
        OrPredicate(predicates=[ObjectEqualTo(value={'key1': 'wrong'}), ObjectEqualTo(value={'key1': 'correct'})]),
        {'key1': 'correct'},
    ],
    'obj_eq_empty_dict': [ObjectEqualTo(value={}), {}],
    'obj_contains_subset_empty_dict': [ObjectContainsSubset(value={}), {'any': 'object'}],
    'obj_contains_subset_empty_dict_on_empty_dict': [ObjectContainsSubset(value={}), {}],
    'key_is_predicate_match': [
        ObjectEqualTo(value={StringPattern(pattern="^key\\d$"): IntegerEqualTo(value=10)}),
        {'key1': 10},
    ],
    'any_predicate_as_value_matches': [
        ObjectEqualTo(value={'name': 'test', 'data': AnyPredicate()}),
        {'name': 'test', 'data': 12345},
    ],
    'any_predicate_as_value_matches_nested': [
        ObjectEqualTo(value={'name': 'test', 'data': AnyPredicate()}),
        {'name': 'test', 'data': {'nested_any': True}},
    ],
    'object_eq_with_number_predicate': [ObjectEqualTo(value={'val': NumberEqualTo(value=3.14)}), {'val': 3.14}],
}

NOT_MATCHED = {
    'simple_dict_eq_val_mismatch': [ObjectEqualTo(value={'lol': 'kek'}), {'lol': 'wrong'}],
    'simple_dict_eq_key_mismatch': [ObjectEqualTo(value={'lol': 'kek'}), {'different_lol': 'kek'}],
    'simple_dict_eq_extra_key_in_value': [ObjectEqualTo(value={'lol': 'kek'}), {'lol': 'kek', 'extra': 'fail'}],
    'simple_dict_eq_missing_key_in_value': [ObjectEqualTo(value={'lol': 'kek', 'needed': 'val'}), {'lol': 'kek'}],
    'nested_dict_eq_val_mismatch': [
        ObjectEqualTo(value={'hello': {'lol': 'kek'}}),
        {'hello': {'lol': 'wrong'}},
    ],
    'with_scalar_predicates_eq_val_mismatch': [
        ObjectEqualTo(value={'key1': StringContains(value='ello'), 'key2': IntegerGreaterThan(value=10)}),
        {'key1': 'hello world', 'key2': 5},  # key2 fails
    ],
    'with_scalar_predicates_eq_key_mismatch': [
        ObjectEqualTo(value={'key1': StringContains(value='ello')}),
        {'key_other': 'hello world'},
    ],
    'with_nested_predicates_eq_val_mismatch': [
        ObjectEqualTo(value={'key1': ObjectEqualTo(value={'nested': 'value'}), 'key2': IntegerGreaterThan(value=10)}),
        {'key1': {'nested': 'wrong'}, 'key2': 15},  # nested value wrong
    ],
    'subset_not_matching_key_missing': [ObjectContainsSubset(value={'key1': 'value1'}), {'key2': 'value2'}],
    'subset_not_matching_val_mismatch': [ObjectContainsSubset(value={'key1': IntegerEqualTo(value=1)}), {'key1': 2}],
    'nested_subset_not_matching_key_missing': [
        ObjectContainsSubset(value={'level1': ObjectContainsSubset(value={'level2': 'value'})}),
        {'level1': {'wrong_level2': 'data'}, 'other': 'info'},
    ],
    'and_predicate_one_fails': [  # From original
        AndPredicate(
            predicates=[ObjectContainsSubset(value={'key1': 'value1'}), ObjectContainsSubset(value={'key2': 'value2'})]
        ),
        {'key1': 'value1', 'key2': 'wrong_value'},
    ],
    'or_predicate_both_fail': [  # From original
        OrPredicate(predicates=[ObjectEqualTo(value={'key1': 'wrong1'}), ObjectEqualTo(value={'key1': 'wrong2'})]),
        {'key1': 'also_wrong_value'},
    ],
    'obj_eq_empty_vs_non_empty': [ObjectEqualTo(value={}), {'not': 'empty'}],
    'obj_contains_subset_non_empty_vs_empty': [ObjectContainsSubset(value={'key': 'val'}), {}],
    'key_is_predicate_no_match': [
        ObjectEqualTo(value={StringPattern(pattern="^key\\d$"): IntegerEqualTo(value=10)}),
        {'keys': 10},  # key "keys" does not match pattern
    ],
    'key_is_predicate_val_mismatch_moved': [  # Moved from MATCHED as it's a non-match
        ObjectEqualTo(value={StringContains(value="id"): IntegerEqualTo(value=1)}),
        {'user_id': 2},
    ],
    # 'not_a_dict_input_for_eq': [ObjectEqualTo(value={'a': 1}), "string input"],
    # 'not_a_dict_input_for_subset': [ObjectContainsSubset(value={'a': 1}), [1, 2, 3]],
    'any_predicate_as_value_mismatch_other_key': [
        ObjectEqualTo(value={'name': 'test', 'data': AnyPredicate()}),
        {'name': 'mismatch', 'data': 12345},
    ],
}


class TestObjectIsMatched:
    @pytest.mark.parametrize(['predicate', 'value'], **get_params_argv(MATCHED))
    def test_matched_values_are_matched(self, predicate, value):
        assert predicate.is_matched(value)

    @pytest.mark.parametrize(['predicate', 'value'], **get_params_argv(NOT_MATCHED))
    def test_not_matched_values_are_not_matched(self, predicate, value):
        assert not predicate.is_matched(value)
