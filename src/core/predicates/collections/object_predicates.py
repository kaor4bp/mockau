from typing import Literal, Self
from uuid import uuid4

import z3
from pydantic import model_validator

from core.predicates.base_predicate import (
    BaseCollectionPredicate,
    BasePredicate,
    PredicateType,
    VariableContext,
    t_Predicate,
)
from core.predicates.helpers import value_to_predicate


class BaseObjectPredicate(BaseCollectionPredicate):
    """Base class for object predicates handling JSON-like structures.

    :ivar value: Dictionary representing the object structure with key-value predicates
    :vartype value: dict[BasePredicate, BasePredicate]

    .. Docstring generated by DeepSeek-V3
    """

    value: dict

    @model_validator(mode='after')
    def handle_nested_objects(self) -> Self:
        """Convert raw values in the object to proper predicates.

        Automatically converts non-predicate keys and values to their predicate equivalents.
        Called automatically by Pydantic during model validation.

        :return: Self with converted predicates
        :rtype: Self

        .. Docstring generated by DeepSeek-V3, modified by Gemini 2.5 Flash
        """
        for key_item, value_item in list(self.value.items()):
            if not isinstance(key_item, BasePredicate):
                new_key_predicate = value_to_predicate(key_item)
                self.value[new_key_predicate] = self.value.pop(key_item)
                key_item = new_key_predicate
            if not isinstance(value_item, BasePredicate):
                self.value[key_item] = value_to_predicate(value_item)
        return self

    @property
    def predicate_types(self) -> set[PredicateType]:
        """Get supported predicate types for this class.

        :return: Set containing only Object type
        :rtype: set[PredicateType]

        .. Docstring generated by DeepSeek-V3
        """
        return {PredicateType.Object}


class ObjectEqualTo(BaseObjectPredicate):
    type_of: Literal['ObjectEqualTo'] = 'ObjectEqualTo'

    def __invert__(self):
        return ObjectNotEqualTo(value=self.value)

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)

        child_ctx = ctx.create_child_context()
        child_ctx.get_variable(PredicateType.Undefined)
        my_arr = z3.K(z3.StringSort(), child_ctx.json_type_variable.z3_variable)

        constraints = []

        for key_pred, value_pred in self.value.items():
            key_context = ctx.create_child_context()
            value_context = ctx.create_child_context()
            constraints.append(key_pred.to_z3(key_context))
            constraints.append(value_pred.to_z3(value_context))

            key_var = key_context.get_variable(PredicateType.String)
            my_arr = z3.Store(my_arr, key_var, value_context.json_type_variable.z3_variable)

        constraints.append(z3_object_variable == my_arr)
        constraints.append(ctx.json_type_variable.is_object())

        return z3.And(*constraints)


class ObjectNotEqualTo(BaseObjectPredicate):
    type_of: Literal['ObjectEqualTo'] = 'ObjectEqualTo'

    def __invert__(self):
        return ObjectEqualTo(value=self.value)

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        all_keys_set = z3.EmptySet(z3.StringSort())

        constraints = []
        or_constraints = []

        for key_pred, value_pred in self.value.items():
            key_context = ctx.create_child_context()
            value_context = ctx.create_child_context()
            constraints.append(key_pred.to_z3(key_context))
            constraints.append((~value_pred).to_z3(value_context))

            key_var = key_context.get_variable(PredicateType.String)
            or_constraints.append(z3_object_variable[key_var] == value_context.json_type_variable.z3_variable)
            all_keys_set = z3.SetAdd(all_keys_set, key_var)

        j = z3.String(f'j_{uuid4()}')
        child_ctx = ctx.create_child_context()
        child_ctx.get_variable(PredicateType.Undefined)
        or_constraints.append(
            z3.ForAll(
                j,
                z3.Implies(
                    z3.Not(z3.IsMember(j, all_keys_set)),
                    z3_object_variable[j] != child_ctx.json_type_variable.z3_variable,
                ),
            )
        )
        constraints.append(ctx.json_type_variable.is_object())

        return z3.And(*constraints, z3.Or(*or_constraints))


class ObjectContainsSubset(BaseObjectPredicate):
    type_of: Literal['ObjectContainsSubset'] = 'ObjectContainsSubset'

    def __invert__(self):
        return ObjectNotContainsSubset(value=self.value)

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        constraints = []

        for key_pred, value_pred in self.value.items():
            key_context = ctx.create_child_context()
            value_context = ctx.create_child_context()
            constraints.append(key_pred.to_z3(key_context))
            constraints.append(value_pred.to_z3(value_context))

            key_var = key_context.get_variable(PredicateType.String)
            constraints.append(value_context.json_type_variable.z3_variable == z3_object_variable[key_var])

        constraints.append(ctx.json_type_variable.is_object())

        return z3.And(*constraints)


class ObjectNotContainsSubset(BaseObjectPredicate):
    type_of: Literal['ObjectContainsSubset'] = 'ObjectContainsSubset'

    def __invert__(self):
        return ObjectContainsSubset(value=self.value)

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        constraints = []

        child_ctx = ctx.create_child_context()
        child_ctx.get_variable(PredicateType.Undefined)
        undefined_var = child_ctx.json_type_variable.z3_variable
        or_constraints = []

        for key_pred, value_pred in self.value.items():
            key_context = ctx.create_child_context()
            value_context = ctx.create_child_context()
            constraints.append(key_pred.to_z3(key_context))
            constraints.append((~value_pred).to_z3(value_context))

            key_var = key_context.get_variable(PredicateType.String)
            or_constraints += [
                z3_object_variable[key_var] == value_context.json_type_variable.z3_variable,
                z3_object_variable[key_var] == undefined_var,
            ]

        constraints.append(ctx.json_type_variable.is_object())

        return z3.And(*constraints, z3.Or(*or_constraints))


class ObjectHasValue(BaseCollectionPredicate):
    type_of: Literal['ObjectHasValue'] = 'ObjectHasValue'
    predicate: t_Predicate | str | int | bool | None

    def __invert__(self):
        return ObjectHasNoValue(predicate=self.predicate)

    @property
    def predicate_types(self) -> set[PredicateType]:
        return {PredicateType.Object}

    @model_validator(mode='after')
    def handle_predicate(self) -> Self:
        if not isinstance(self.predicate, BasePredicate):
            self.predicate = value_to_predicate(self.predicate)
        return self

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        constraints = []

        child_ctx = ctx.create_child_context()
        constraints.append(self.predicate.to_z3(child_ctx))
        key_var = z3.String(f'key_{uuid4()}')
        constraints.append(z3_object_variable[key_var] == child_ctx.json_type_variable.z3_variable)
        constraints.append(ctx.json_type_variable.is_object())

        return z3.And(*constraints)


class ObjectHasNoValue(BaseCollectionPredicate):
    type_of: Literal['ObjectHasValue'] = 'ObjectHasValue'
    predicate: t_Predicate | str | int | bool | None

    def __invert__(self):
        return ObjectHasValue(predicate=self.predicate)

    @property
    def predicate_types(self) -> set[PredicateType]:
        return {PredicateType.Object}

    @model_validator(mode='after')
    def handle_predicate(self) -> Self:
        if not isinstance(self.predicate, BasePredicate):
            self.predicate = value_to_predicate(self.predicate)
        return self

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        constraints = []
        or_constraints = []

        child_ctx = ctx.create_child_context()
        constraints.append((~self.predicate).to_z3(child_ctx))

        j = z3.String(f'j_{uuid4()}')
        or_constraints.append(
            z3.ForAll(
                j,
                z3_object_variable[j] == child_ctx.json_type_variable.z3_variable,
            )
        )
        constraints.append(ctx.json_type_variable.is_object())

        return z3.And(*constraints, z3.Or(*or_constraints))
