from abc import ABC
from functools import cached_property
from typing import TYPE_CHECKING, Literal, Union
from uuid import uuid4

import z3
from pydantic import BaseModel, ConfigDict, Field

from core.predicates.base_predicate import BaseCollectionPredicate, PredicateType, VariableContext
from core.predicates.context.predicate_limitations import PredicateLimitations
from core.predicates.helpers import py_value_to_predicate
from utils.kuhn_matching_algorithm import KuhnMatchingAlgorithm

if TYPE_CHECKING:
    from core.predicates import t_DefaultPredicateType, t_Predicate


class DynamicKeyMatch(BaseModel):
    model_config = ConfigDict(populate_by_name=True, alias_generator=lambda x: f'${x}')

    key: Union[
        't_Predicate',
        str,
    ]
    value: 't_DefaultPredicateType'


class BaseObjectPredicate(
    BaseCollectionPredicate,
    ABC,
):
    """Base class for object predicates handling JSON-like structures.

    :ivar value: Dictionary representing the object structure with key-value predicates
    :vartype value: dict[BasePredicate, BasePredicate]

    .. Docstring generated by DeepSeek-V3
    """

    value: dict[str, 't_DefaultPredicateType'] = Field(default_factory=dict)
    dynamic_matches: list[DynamicKeyMatch] = Field(default_factory=list)

    def get_all_predicates(self):
        yield self
        for key_pred, val_pred in self.compiled_value.items():
            yield from key_pred.get_all_predicates()
            yield from val_pred.get_all_predicates()

    @cached_property
    def compiled_value(self):
        result = {}
        for key, value in self.value.items():
            result[py_value_to_predicate(key)] = py_value_to_predicate(value)

        for dynamic_match in self.dynamic_matches:
            result[dynamic_match.key] = py_value_to_predicate(dynamic_match.value)
        return result

    @property
    def predicate_types(self) -> set[PredicateType]:
        """Get supported predicate types for this class.

        :return: Set containing only Object type
        :rtype: set[PredicateType]

        .. Docstring generated by DeepSeek-V3
        """
        return {PredicateType.Object}

    def calculate_limitations(self) -> PredicateLimitations:
        limitation = PredicateLimitations(
            level_gte=0,
            level_lte=0,
        )

        for item in self.compiled_value.keys():
            limitation.push(item.calculate_limitations().increment_level())
        for item in self.compiled_value.values():
            limitation.push(item.calculate_limitations().increment_level())

        return limitation


class ObjectEqualTo(
    BaseObjectPredicate,
):
    type_of: Literal['$-mockau-object-equal-to'] = '$-mockau-object-equal-to'

    def compile_predicate(self):
        from core.predicates import DynamicKeyMatch, ObjectEqualTo

        return ObjectEqualTo(
            dynamic_matches=[
                DynamicKeyMatch(key=k.compile_predicate(), value=v.compile_predicate())
                for k, v in self.compiled_value.items()
            ]
        )

    def verify(self, value: dict):
        if not isinstance(value, dict):
            return False

        graph = {}

        for pred_k, pred_v in self.compiled_value.items():
            graph[pred_k] = []
            for k, v in value.items():
                if pred_k.verify(k) and pred_v.verify(v):
                    graph[pred_k].append(pred_v)
                    break

        best_candidate = KuhnMatchingAlgorithm(graph).find_max_matching()
        return len(best_candidate.keys()) == len(self.compiled_value.keys()) == len(value.keys())

    def __invert__(self):
        return ObjectNotEqualTo(value=self.value, dynamic_matches=self.dynamic_matches, var=self.var)

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        ctx.set_as_user_variable(self.var)

        child_ctx = ctx.create_child_context()
        child_ctx.get_variable(PredicateType.Undefined)
        my_arr = z3.K(z3.StringSort(ctx=ctx.z3_context), child_ctx.json_type_variable.z3_variable)

        existing_key_vars = []
        key_constraints = []

        constraints = [child_ctx.pop_from_global_constraints()]

        for key_pred, value_pred in self.compiled_value.items():
            key_context = ctx.create_child_context()
            value_context = ctx.create_child_context()

            constraints += [
                key_pred.to_z3(key_context),
                value_pred.to_z3(value_context),
                key_context.pop_from_global_constraints(),
                value_context.pop_from_global_constraints(),
            ]

            key_var = key_context.get_variable(PredicateType.String)

            my_arr = z3.Store(my_arr, key_var, value_context.json_type_variable.z3_variable)
            ctx.register_key_var(key_var)

            for v in existing_key_vars:
                key_constraints.append(key_var != v)
            existing_key_vars.append(key_var)

            del key_context
            del value_context

        constraints += [
            z3_object_variable == my_arr,
            ctx.json_type_variable.is_object(),
        ]
        return z3.And(*constraints, *key_constraints, z3.BoolVal(True, ctx=ctx.z3_context))


class ObjectNotEqualTo(
    BaseObjectPredicate,
):
    type_of: Literal['$-mockau-object-not-equal-to'] = '$-mockau-object-not-equal-to'

    def compile_predicate(self):
        from core.predicates import DynamicKeyMatch, ObjectNotEqualTo

        return ObjectNotEqualTo(
            dynamic_matches=[
                DynamicKeyMatch(key=k.compile_predicate(), value=v.compile_predicate())
                for k, v in self.compiled_value.items()
            ]
        )

    def verify(self, value: dict):
        if not isinstance(value, dict):
            return False

        graph = {}

        for pred_k, pred_v in self.compiled_value.items():
            graph[pred_k] = []
            for k, v in value.items():
                if pred_k.verify(k) and pred_v.verify(v):
                    graph[pred_k].append(pred_v)
                    break

        best_candidate = KuhnMatchingAlgorithm(graph).find_max_matching()
        return len(best_candidate.keys()) != len(self.compiled_value.keys()) and len(best_candidate.keys()) != len(
            value.keys()
        )

    def __invert__(self):
        return ObjectEqualTo(value=self.value, dynamic_matches=self.dynamic_matches, var=self.var)

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        from core.predicates import NotPredicate

        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        ctx.set_as_user_variable(self.var)
        all_keys_set = z3.EmptySet(z3.StringSort(ctx=ctx.z3_context))
        existing_key_vars = []

        constraints = []
        or_constraints = [z3.BoolVal(False, ctx=ctx.z3_context)]

        for key_pred, value_pred in self.compiled_value.items():
            key_context = ctx.create_child_context()
            value_context = ctx.create_child_context()

            constraints += [
                key_pred.to_z3(key_context),
                NotPredicate(predicate=value_pred).to_z3(value_context),
                key_context.pop_from_global_constraints(),
                value_context.pop_from_global_constraints(),
            ]

            key_var = key_context.get_variable(PredicateType.String)
            or_constraints.append(z3_object_variable[key_var] == value_context.json_type_variable.z3_variable)

            all_keys_set = z3.SetAdd(all_keys_set, key_var)
            ctx.register_key_var(key_var)

            for v in existing_key_vars:
                constraints.append(key_var != v)
            existing_key_vars.append(key_var)

            del key_context
            del value_context

        j = z3.String(f'j_{uuid4()}', ctx=ctx.z3_context)
        child_ctx = ctx.create_child_context()
        child_ctx.get_variable(PredicateType.Undefined)
        or_constraints.append(
            z3.And(
                z3.Not(z3.IsMember(j, all_keys_set), ctx=ctx.z3_context),
                z3_object_variable[j] != child_ctx.json_type_variable.z3_variable,
            )
        )
        or_constraints.append(
            z3.ForAll(
                [j],
                z3.Implies(
                    z3.Not(z3.IsMember(j, all_keys_set)),
                    z3_object_variable[j] != child_ctx.json_type_variable.z3_variable,
                ),
            )
        )
        constraints += [
            ctx.json_type_variable.is_object(),
            child_ctx.pop_from_global_constraints(),
        ]

        del child_ctx

        return z3.And(*constraints, z3.Or(*or_constraints))


class ObjectContainsSubset(
    BaseObjectPredicate,
):
    type_of: Literal['$-mockau-object-contains'] = '$-mockau-object-contains'

    def compile_predicate(self):
        from core.predicates import DynamicKeyMatch, ObjectContainsSubset

        return ObjectContainsSubset(
            dynamic_matches=[
                DynamicKeyMatch(key=k.compile_predicate(), value=v.compile_predicate())
                for k, v in self.compiled_value.items()
            ]
        )

    def verify(self, value: dict):
        if not isinstance(value, dict):
            return False

        graph = {}

        for pred_k, pred_v in self.compiled_value.items():
            graph[pred_k] = []
            for k, v in value.items():
                if pred_k.verify(k) and pred_v.verify(v):
                    graph[pred_k].append(pred_v)
                    break

        best_candidate = KuhnMatchingAlgorithm(graph).find_max_matching()
        return len(best_candidate.keys()) >= len(self.compiled_value.keys())

    def __invert__(self):
        return ObjectNotContainsSubset(value=self.value, dynamic_matches=self.dynamic_matches, var=self.var)

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        ctx.set_as_user_variable(self.var)
        constraints = []
        existing_key_vars = []

        for key_pred, value_pred in self.compiled_value.items():
            key_context = ctx.create_child_context()
            value_context = ctx.create_child_context()

            constraints += [
                key_pred.to_z3(key_context),
                value_pred.to_z3(value_context),
                key_context.pop_from_global_constraints(),
                value_context.pop_from_global_constraints(),
            ]

            key_var = key_context.get_variable(PredicateType.String)

            constraints.append(z3_object_variable[key_var] == value_context.json_type_variable.z3_variable)
            ctx.register_key_var(key_var)

            for v in existing_key_vars:
                constraints.append(key_var != v)
            existing_key_vars.append(key_var)

            del key_context
            del value_context

        constraints.append(ctx.json_type_variable.is_object())

        return z3.And(*constraints, z3.BoolVal(True, ctx=ctx.z3_context))


class ObjectNotContainsSubset(
    BaseObjectPredicate,
):
    type_of: Literal['$-mockau-object-not-contains'] = '$-mockau-object-not-contains'

    def compile_predicate(self):
        from core.predicates import DynamicKeyMatch, ObjectNotContainsSubset

        return ObjectNotContainsSubset(
            dynamic_matches=[
                DynamicKeyMatch(key=k.compile_predicate(), value=v.compile_predicate())
                for k, v in self.compiled_value.items()
            ]
        )

    def verify(self, value: dict):
        if not isinstance(value, dict):
            return False

        graph = {}

        for pred_k, pred_v in self.compiled_value.items():
            graph[pred_k] = []
            for k, v in value.items():
                if pred_k.verify(k) and pred_v.verify(v):
                    graph[pred_k].append(pred_v)
                    break

        best_candidate = KuhnMatchingAlgorithm(graph).find_max_matching()
        return len(best_candidate.keys()) < len(self.compiled_value.keys())

    def __invert__(self):
        return ObjectContainsSubset(value=self.compiled_value, var=self.var)

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        from core.predicates import NotPredicate

        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        ctx.set_as_user_variable(self.var)
        constraints = []
        existing_key_vars = []

        child_ctx = ctx.create_child_context()
        child_ctx.get_variable(PredicateType.Undefined)
        undefined_var = child_ctx.json_type_variable.z3_variable
        or_constraints = [z3.BoolVal(False, ctx=ctx.z3_context)]

        for key_pred, value_pred in self.compiled_value.items():
            key_context = ctx.create_child_context()
            value_context = ctx.create_child_context()

            constraints += [
                key_pred.to_z3(key_context),
                NotPredicate(predicate=value_pred).to_z3(value_context),
                key_context.pop_from_global_constraints(),
                value_context.pop_from_global_constraints(),
            ]

            key_var = key_context.get_variable(PredicateType.String)

            or_constraints += [
                z3_object_variable[key_var] == value_context.json_type_variable.z3_variable,
                z3_object_variable[key_var] == undefined_var,
            ]
            ctx.register_key_var(key_var)
            for v in existing_key_vars:
                constraints.append(key_var != v)
            existing_key_vars.append(key_var)

            del key_context
            del value_context

        constraints.append(ctx.json_type_variable.is_object())
        return z3.And(*constraints, z3.Or(*or_constraints))


class ObjectHasValue(
    BaseCollectionPredicate,
):
    type_of: Literal['$-mockau-object-has-value'] = '$-mockau-object-has-value'
    predicate: 't_DefaultPredicateType'

    def get_all_predicates(self):
        yield self
        yield from self.compiled_value.get_all_predicates()

    def compile_predicate(self):
        from core.predicates import ObjectHasValue

        return ObjectHasValue(
            predicate=self.compiled_value.compile_predicate(),
        )

    @cached_property
    def compiled_value(self):
        return py_value_to_predicate(self.predicate)

    def verify(self, value: dict):
        if not isinstance(value, dict):
            return False

        for v in value.values():
            if self.compiled_value.verify(v):
                return True
        return False

    def __invert__(self):
        return ObjectHasNoValue(predicate=self.predicate, var=self.var)

    @property
    def predicate_types(self) -> set[PredicateType]:
        return {PredicateType.Object}

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        ctx.set_as_user_variable(self.var)
        constraints = []

        child_ctx = ctx.create_child_context()
        constraints.append(self.compiled_value.to_z3(child_ctx))
        key_var = z3.String(f'key_{uuid4()}', ctx=ctx.z3_context)

        constraints.append(z3_object_variable[key_var] == child_ctx.json_type_variable.z3_variable)
        constraints.append(ctx.json_type_variable.is_object())
        ctx.register_key_var(key_var)

        return z3.And(*constraints, z3.BoolVal(True, ctx=ctx.z3_context))

    def calculate_limitations(self) -> PredicateLimitations:
        limitation = PredicateLimitations(
            level_gte=0,
            level_lte=0,
        )

        limitation.push(self.predicate.calculate_limitations().increment_level())
        return limitation


class ObjectHasNoValue(
    BaseCollectionPredicate,
):
    type_of: Literal['$-mockau-object-has-no-value'] = '$-mockau-object-has-no-value'
    predicate: 't_DefaultPredicateType'

    def get_all_predicates(self):
        yield self
        yield from self.compiled_value.get_all_predicates()

    def compile_predicate(self):
        from core.predicates import ObjectHasNoValue

        return ObjectHasNoValue(
            predicate=self.compiled_value.compile_predicate(),
        )

    @cached_property
    def compiled_value(self):
        return py_value_to_predicate(self.predicate)

    def verify(self, value: dict):
        if not isinstance(value, dict):
            return False

        for v in value.values():
            if self.compiled_value.verify(v):
                return False
        return True

    def __invert__(self):
        return ObjectHasValue(predicate=self.predicate, var=self.var)

    @property
    def predicate_types(self) -> set[PredicateType]:
        return {PredicateType.Object}

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        from core.predicates import NotPredicate

        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        ctx.set_as_user_variable(self.var)
        constraints = []
        or_constraints = [z3.BoolVal(False, ctx=ctx.z3_context)]

        child_ctx = ctx.create_child_context()
        constraints.append(NotPredicate(predicate=self.compiled_value).to_z3(child_ctx))

        j = z3.String(f'j_{uuid4()}', ctx=ctx.z3_context)
        or_constraints.append(
            z3.ForAll(
                j,
                z3_object_variable[j] == child_ctx.json_type_variable.z3_variable,
            )
        )
        constraints.append(ctx.json_type_variable.is_object())

        return z3.And(*constraints, z3.Or(*or_constraints))

    def calculate_limitations(self) -> PredicateLimitations:
        limitation = PredicateLimitations(
            level_gte=0,
            level_lte=0,
        )

        limitation.push(self.predicate.calculate_limitations().increment_level())
        return limitation
