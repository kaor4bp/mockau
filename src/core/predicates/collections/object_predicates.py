from typing import Literal, Self
from uuid import uuid4

import z3
from pydantic import model_validator

from core.predicates.base_predicate import (
    BaseCollectionPredicate,
    BasePredicate,
    PredicateType,
    VariableContext,
    t_Predicate,
)
from core.predicates.context.predicate_limitations import PredicateLimitations
from core.predicates.helpers import value_to_predicate
from core.predicates.logical.logical_predicates import NotPredicate
from utils.kuhn_matching_algorithm import KuhnMatchingAlgorithm

_DEFAULT_NESTED_PREDICATES_EXTRA_NESTING = 2


class BaseObjectPredicate(BaseCollectionPredicate):
    """Base class for object predicates handling JSON-like structures.

    :ivar value: Dictionary representing the object structure with key-value predicates
    :vartype value: dict[BasePredicate, BasePredicate]

    .. Docstring generated by DeepSeek-V3
    """

    value: dict

    def get_nested_predicates(self):
        results = [self]
        for item in self.value.values():
            results += item.get_nested_predicates()
        return results

    @model_validator(mode='after')
    def handle_nested_objects(self) -> Self:
        """Convert raw values in the object to proper predicates.

        Automatically converts non-predicate keys and values to their predicate equivalents.
        Called automatically by Pydantic during model validation.

        :return: Self with converted predicates
        :rtype: Self

        .. Docstring generated by DeepSeek-V3, modified by Gemini 2.5 Flash
        """
        for key_item, value_item in list(self.value.items()):
            if not isinstance(key_item, BasePredicate):
                new_key_predicate = value_to_predicate(key_item)
                self.value[new_key_predicate] = self.value.pop(key_item)
                key_item = new_key_predicate
            if not isinstance(value_item, BasePredicate):
                self.value[key_item] = value_to_predicate(value_item)
        return self

    @property
    def predicate_types(self) -> set[PredicateType]:
        """Get supported predicate types for this class.

        :return: Set containing only Object type
        :rtype: set[PredicateType]

        .. Docstring generated by DeepSeek-V3
        """
        return {PredicateType.Object}

    def calculate_limitations(self) -> PredicateLimitations:
        limitation = PredicateLimitations(
            level_gte=0,
            level_lte=0,
        )

        for item in self.value.keys():
            limitation.push(item.calculate_limitations().increment_level())
        for item in self.value.values():
            limitation.push(item.calculate_limitations().increment_level())

        limitation.max_nesting_level += 1
        return limitation


class ObjectEqualTo(BaseObjectPredicate):
    type_of: Literal['ObjectEqualTo'] = 'ObjectEqualTo'

    def verify(self, value: dict):
        if not isinstance(value, dict):
            return False

        graph = {}

        for pred_k, pred_v in self.value.items():
            graph[pred_k] = []
            for k, v in value.items():
                if pred_k.verify(k) and pred_v.verify(v):
                    graph[pred_k].append(pred_v)
                    break

        best_candidate = KuhnMatchingAlgorithm(graph).find_max_matching()
        return len(best_candidate.keys()) == len(self.value.keys()) == len(value.keys())

    def __invert__(self):
        return ObjectNotEqualTo(value=self.value)

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)

        child_ctx = ctx.create_child_context()
        child_ctx.get_variable(PredicateType.Undefined)
        my_arr = z3.K(z3.StringSort(ctx=ctx.z3_context), child_ctx.json_type_variable.z3_variable)

        existing_key_vars = []
        key_constraints = []

        constraints = [child_ctx.pop_from_global_constraints()]

        for key_pred, value_pred in self.value.items():
            key_context = ctx.create_child_context()
            value_context = ctx.create_child_context()

            constraints += [
                key_pred.to_z3(key_context),
                value_pred.to_z3(value_context),
                key_context.pop_from_global_constraints(),
                value_context.pop_from_global_constraints(),
            ]

            key_var = key_context.get_variable(PredicateType.String)
            my_arr = z3.Store(my_arr, key_var, value_context.json_type_variable.z3_variable)
            ctx.register_key_var(key_var)

            for v in existing_key_vars:
                key_constraints.append(key_var != v)
            existing_key_vars.append(key_var)

            del key_context
            del value_context

        constraints += [
            z3_object_variable == my_arr,
            ctx.json_type_variable.is_object(),
        ]

        return z3.And(*constraints, *key_constraints, z3.BoolVal(True, ctx=ctx.z3_context))


class ObjectNotEqualTo(BaseObjectPredicate):
    type_of: Literal['ObjectEqualTo'] = 'ObjectEqualTo'

    def get_nested_predicates(self):
        results = [self]
        for item in self.value.values():
            results += NotPredicate(predicate=item, preserve_type=False).get_nested_predicates()
        return results

    def verify(self, value: dict):
        if not isinstance(value, dict):
            return False

        graph = {}

        for pred_k, pred_v in self.value.items():
            graph[pred_k] = []
            for k, v in value.items():
                if pred_k.verify(k) and pred_v.verify(v):
                    graph[pred_k].append(pred_v)
                    break

        best_candidate = KuhnMatchingAlgorithm(graph).find_max_matching()
        return len(best_candidate.keys()) != len(self.value.keys()) and len(best_candidate.keys()) != len(value.keys())

    def __invert__(self):
        return ObjectEqualTo(value=self.value)

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        all_keys_set = z3.EmptySet(z3.StringSort(ctx=ctx.z3_context))
        existing_key_vars = []

        constraints = []
        or_constraints = [z3.BoolVal(False, ctx=ctx.z3_context)]

        for key_pred, value_pred in self.value.items():
            key_context = ctx.create_child_context()
            value_context = ctx.create_child_context()

            constraints += [
                key_pred.to_z3(key_context),
                NotPredicate(predicate=value_pred, preserve_type=False).to_z3(value_context),
                key_context.pop_from_global_constraints(),
                value_context.pop_from_global_constraints(),
            ]

            key_var = key_context.get_variable(PredicateType.String)
            or_constraints.append(z3_object_variable[key_var] == value_context.json_type_variable.z3_variable)

            all_keys_set = z3.SetAdd(all_keys_set, key_var)
            ctx.register_key_var(key_var)

            for v in existing_key_vars:
                constraints.append(key_var != v)
            existing_key_vars.append(key_var)

            del key_context
            del value_context

        j = z3.String(f'j_{uuid4()}', ctx=ctx.z3_context)
        child_ctx = ctx.create_child_context()
        child_ctx.get_variable(PredicateType.Undefined)
        or_constraints.append(
            z3.And(
                z3.Not(z3.IsMember(j, all_keys_set), ctx=ctx.z3_context),
                z3_object_variable[j] != child_ctx.json_type_variable.z3_variable,
            )
        )
        # or_constraints.append(
        #     z3.ForAll(
        #         j,
        #         z3.Implies(
        #             z3.Not(z3.IsMember(j, all_keys_set)),
        #             z3_object_variable[j] != child_ctx.json_type_variable.z3_variable,
        #         ),
        #     )
        # )
        constraints += [
            ctx.json_type_variable.is_object(),
            child_ctx.pop_from_global_constraints(),
        ]

        del child_ctx

        return z3.And(*constraints, z3.Or(*or_constraints))


class ObjectContainsSubset(BaseObjectPredicate):
    type_of: Literal['ObjectContainsSubset'] = 'ObjectContainsSubset'

    def verify(self, value: dict):
        if not isinstance(value, dict):
            return False

        graph = {}

        for pred_k, pred_v in self.value.items():
            graph[pred_k] = []
            for k, v in value.items():
                if pred_k.verify(k) and pred_v.verify(v):
                    graph[pred_k].append(pred_v)
                    break

        best_candidate = KuhnMatchingAlgorithm(graph).find_max_matching()
        return len(best_candidate.keys()) >= len(self.value.keys())

    def __invert__(self):
        return ObjectNotContainsSubset(value=self.value)

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        constraints = []
        existing_key_vars = []

        for key_pred, value_pred in self.value.items():
            key_context = ctx.create_child_context()
            value_context = ctx.create_child_context()

            constraints += [
                key_pred.to_z3(key_context),
                value_pred.to_z3(value_context),
                key_context.pop_from_global_constraints(),
                value_context.pop_from_global_constraints(),
            ]

            key_var = key_context.get_variable(PredicateType.String)
            constraints.append(value_context.json_type_variable.z3_variable == z3_object_variable[key_var])
            ctx.register_key_var(key_var)

            for v in existing_key_vars:
                constraints.append(key_var != v)
            existing_key_vars.append(key_var)

            del key_context
            del value_context

        constraints.append(ctx.json_type_variable.is_object())

        return z3.And(*constraints, z3.BoolVal(True, ctx=ctx.z3_context))


class ObjectNotContainsSubset(BaseObjectPredicate):
    type_of: Literal['ObjectContainsSubset'] = 'ObjectContainsSubset'

    def verify(self, value: dict):
        if not isinstance(value, dict):
            return False

        graph = {}

        for pred_k, pred_v in self.value.items():
            graph[pred_k] = []
            for k, v in value.items():
                if pred_k.verify(k) and pred_v.verify(v):
                    graph[pred_k].append(pred_v)
                    break

        best_candidate = KuhnMatchingAlgorithm(graph).find_max_matching()
        return len(best_candidate.keys()) < len(self.value.keys())

    def __invert__(self):
        return ObjectContainsSubset(value=self.value)

    def get_nested_predicates(self):
        results = [self]
        for item in self.value.values():
            results += NotPredicate(predicate=item, preserve_type=False).get_nested_predicates()
        return results

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        constraints = []
        existing_key_vars = []

        child_ctx = ctx.create_child_context()
        child_ctx.get_variable(PredicateType.Undefined)
        undefined_var = child_ctx.json_type_variable.z3_variable
        or_constraints = [z3.BoolVal(False, ctx=ctx.z3_context)]

        for key_pred, value_pred in self.value.items():
            key_context = ctx.create_child_context()
            value_context = ctx.create_child_context()

            constraints += [
                key_pred.to_z3(key_context),
                NotPredicate(predicate=value_pred, preserve_type=False).to_z3(value_context),
                key_context.pop_from_global_constraints(),
                value_context.pop_from_global_constraints(),
            ]

            key_var = key_context.get_variable(PredicateType.String)
            or_constraints += [
                z3_object_variable[key_var] == value_context.json_type_variable.z3_variable,
                z3_object_variable[key_var] == undefined_var,
            ]
            ctx.register_key_var(key_var)
            for v in existing_key_vars:
                constraints.append(key_var != v)
            existing_key_vars.append(key_var)

            del key_context
            del value_context

        constraints.append(ctx.json_type_variable.is_object())

        return z3.And(*constraints, z3.Or(*or_constraints))


class ObjectHasValue(BaseCollectionPredicate):
    type_of: Literal['ObjectHasValue'] = 'ObjectHasValue'
    predicate: t_Predicate | str | int | bool | None

    def get_nested_predicates(self):
        return [self, *self.predicate.get_nested_predicates()]

    def verify(self, value: dict):
        if not isinstance(value, dict):
            return False

        for v in value.values():
            if self.predicate.verify(v):
                return True
        return False

    def __invert__(self):
        return ObjectHasNoValue(predicate=self.predicate)

    @property
    def predicate_types(self) -> set[PredicateType]:
        return {PredicateType.Object}

    @model_validator(mode='after')
    def handle_predicate(self) -> Self:
        if not isinstance(self.predicate, BasePredicate):
            self.predicate = value_to_predicate(self.predicate)
        return self

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        constraints = []

        child_ctx = ctx.create_child_context()
        constraints.append(self.predicate.to_z3(child_ctx))
        key_var = z3.String(f'key_{uuid4()}', ctx=ctx.z3_context)
        constraints.append(z3_object_variable[key_var] == child_ctx.json_type_variable.z3_variable)
        constraints.append(ctx.json_type_variable.is_object())
        ctx.register_key_var(key_var)

        return z3.And(*constraints, z3.BoolVal(True, ctx=ctx.z3_context))

    def calculate_limitations(self) -> PredicateLimitations:
        limitation = PredicateLimitations(
            level_gte=0,
            level_lte=0,
        )

        limitation.push(self.predicate.calculate_limitations().increment_level())
        limitation.max_nesting_level += 1
        return limitation


class ObjectHasNoValue(BaseCollectionPredicate):
    type_of: Literal['ObjectHasValue'] = 'ObjectHasValue'
    predicate: t_Predicate | str | int | bool | None

    def get_nested_predicates(self):
        return [self] + [NotPredicate(predicate=p, preserve_type=False) for p in self.predicate.get_nested_predicates()]

    def verify(self, value: dict):
        if not isinstance(value, dict):
            return False

        for v in value.values():
            if self.predicate.verify(v):
                return False
        return True

    def __invert__(self):
        return ObjectHasValue(predicate=self.predicate)

    @property
    def predicate_types(self) -> set[PredicateType]:
        return {PredicateType.Object}

    @model_validator(mode='after')
    def handle_predicate(self) -> Self:
        if not isinstance(self.predicate, BasePredicate):
            self.predicate = value_to_predicate(self.predicate)
        return self

    def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
        z3_object_variable = ctx.get_variable(predicate_type=PredicateType.Object)
        constraints = []
        or_constraints = [z3.BoolVal(False, ctx=ctx.z3_context)]

        child_ctx = ctx.create_child_context()
        constraints.append(NotPredicate(predicate=self.predicate, preserve_type=False).to_z3(child_ctx))

        j = z3.String(f'j_{uuid4()}', ctx=ctx.z3_context)
        or_constraints.append(
            z3.ForAll(
                j,
                z3_object_variable[j] == child_ctx.json_type_variable.z3_variable,
            )
        )
        constraints.append(ctx.json_type_variable.is_object())

        return z3.And(*constraints, z3.Or(*or_constraints))

    def calculate_limitations(self) -> PredicateLimitations:
        limitation = PredicateLimitations(
            level_gte=0,
            level_lte=0,
        )

        limitation.push(self.predicate.calculate_limitations().increment_level())

        limitation.max_nesting_level += 1
        return limitation


# class NestedObjectEqualTo(BaseObjectPredicate):
#     type_of: Literal['NestedObjectEqualTo'] = 'NestedObjectEqualTo'
#     max_depth: int = 10
#
#     def verify(self, value: dict):
#         if not isinstance(value, dict):
#             return False
#
#         for k, v in value.items():
#             if isinstance(v, dict):
#                 if ObjectEqualTo(value=self.value).verify(v):
#                     return True
#                 elif self.verify(v):
#                     return True
#             if isinstance(v, list):
#                 for item in v:
#                     if isinstance(item, dict) and self.verify(item):
#                         return True
#         return False
#
#     def __invert__(self):
#         return NestedObjectNotEqualTo(value=self.value, max_depth=self.max_depth)
#
#     @property
#     def predicate_types(self) -> set[PredicateType]:
#         return {PredicateType.Array, PredicateType.Object}
#
#     def calculate_limitations(self) -> PredicateLimitations:
#         limitation = PredicateLimitations(
#             level_gte=0,
#             level_lte=None,
#         )
#
#         for item in self.value.keys():
#             limitation.push(item.calculate_limitations().increment_level(reset_level_lte=True))
#         for item in self.value.values():
#             limitation.push(item.calculate_limitations().increment_level(reset_level_lte=True))
#
#         limitation.max_nesting_level += _DEFAULT_NESTED_PREDICATES_EXTRA_NESTING
#         return limitation
#
#     def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
#         main_predicate = ObjectEqualTo(value=self.value)
#         constraints = []
#         initial_level = ctx.json_type_variable.level
#         ctx.get_variable(PredicateType.Object)
#
#         for sub_level in range(self.max_depth):
#             child_ctx = ctx.create_child_context()
#
#             object_iterator = z3.String(f'iter_obj_{uuid4()}')
#             array_iterator = z3.Int(f'iter_arr_{uuid4()}')
#             if sub_level < self.max_depth - 1 and ctx.get_limitations().max_nesting_level >= sub_level + initial_level:
#                 array_var = ctx.get_variable(PredicateType.Array)
#                 object_var = ctx.get_variable(PredicateType.Object)
#                 constraints.append(
#                     z3.Or(
#                         main_predicate.to_z3(ctx),
#                         z3.And(
#                             array_var[array_iterator] == child_ctx.json_type_variable.z3_variable,
#                             ctx.json_type_variable.is_array(),
#                             array_iterator < z3.Length(array_var),
#                             array_iterator >= 0,
#                         ),
#                         z3.And(
#                             object_var[object_iterator] == child_ctx.json_type_variable.z3_variable,
#                             ctx.json_type_variable.is_object(),
#                         ),
#                     )
#                 )
#             else:
#                 constraints.append(main_predicate.to_z3(ctx))
#             ctx = child_ctx
#
#         return z3.And(*constraints)
#
#
# class NestedObjectNotEqualTo(BaseObjectPredicate):
#     type_of: Literal['NestedObjectNotEqualTo'] = 'NestedObjectNotEqualTo'
#     max_depth: int = 10
#
#     def verify(self, value: dict):
#         if not isinstance(value, dict):
#             return False
#
#         for k, v in value.items():
#             if isinstance(v, dict):
#                 if not ObjectEqualTo(value=self.value).verify(v):
#                     return False
#                 elif not self.verify(v):
#                     return False
#             if isinstance(v, list):
#                 for item in v:
#                     if isinstance(item, dict) and not self.verify(item):
#                         return False
#         return True
#
#     def __invert__(self):
#         return NestedObjectEqualTo(value=self.value, max_depth=self.max_depth)
#
#     @property
#     def predicate_types(self) -> set[PredicateType]:
#         return {PredicateType.Array, PredicateType.Object}
#
#     def calculate_limitations(self) -> PredicateLimitations:
#         limitation = PredicateLimitations(
#             level_gte=0,
#             level_lte=None,
#         )
#
#         for item in self.value.keys():
#             limitation.push(item.calculate_limitations().increment_level(reset_level_lte=True))
#         for item in self.value.values():
#             limitation.push(item.calculate_limitations().increment_level(reset_level_lte=True))
#
#         limitation.max_nesting_level += _DEFAULT_NESTED_PREDICATES_EXTRA_NESTING
#         return limitation
#
#     def build_nested_for_all(self, ctx, cur_obj, level, recursion_level=0, start_level=0):
#         dts = JsonDatatype._Z3_JSON_DATATYPES
#
#         object_iterator = z3.String(f'object_iterator_{uuid4()}')
#         array_iterator = z3.Int(f'array_iterator_{uuid4()}')
#
#         nested_object_expression = z3.BoolVal(True)
#         nested_array_expression = z3.BoolVal(True)
#
#         if (
#             recursion_level < self.max_depth
#             and level < JsonDatatype.MAX_NESTING_LEVEL - 1
#             and ctx.get_limitations().max_nesting_level >= level
#         ):
#             child_ctx = ctx.create_child_context()
#             nested_object_expression = z3.ForAll(
#                 [object_iterator],
#                 self.build_nested_for_all(
#                     ctx=child_ctx,
#                     cur_obj=dts[level].get_object(cur_obj)[object_iterator],
#                     level=level + 1,
#                     recursion_level=recursion_level + 1,
#                     start_level=start_level,
#                 ),
#             )
#             nested_array_expression = z3.ForAll(
#                 [array_iterator],
#                 z3.Implies(
#                     z3.And(array_iterator >= 0, array_iterator < z3.Length(dts[level].get_array(cur_obj))),
#                     self.build_nested_for_all(
#                         ctx=child_ctx,
#                         cur_obj=dts[level].get_array(cur_obj)[array_iterator],
#                         level=level + 1,
#                         recursion_level=recursion_level + 1,
#                         start_level=start_level,
#                     ),
#                 ),
#             )
#
#         sub_predicate_expression = z3.BoolVal(True)
#         if start_level <= level:
#             sibling_ctx = ctx.create_sibling_context()
#             sub_predicate_expression = z3.And(
#                 ObjectNotEqualTo(value=self.value).to_z3(sibling_ctx),
#                 sibling_ctx.json_type_variable.z3_variable == cur_obj,
#                 sibling_ctx.pop_from_global_constraints(),
#             )
#
#         return z3.And(
#             *[
#                 z3.Implies(
#                     dts[level].is_object(cur_obj),
#                     z3.And(
#                         sub_predicate_expression,
#                         nested_object_expression,
#                     ),
#                 ),
#                 z3.Implies(
#                     dts[level].is_array(cur_obj),
#                     nested_array_expression,
#                 ),
#             ]
#         )
#
#     def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
#         return self.build_nested_for_all(
#             ctx=ctx,
#             level=ctx.json_type_variable.level,
#             cur_obj=ctx.json_type_variable.z3_variable,
#             start_level=ctx.json_type_variable.level,
#         )
#
#
# class NestedObjectContainsSubset(BaseObjectPredicate):
#     type_of: Literal['NestedObjectContainsSubset'] = 'NestedObjectContainsSubset'
#     max_depth: int = 10
#
#     def verify(self, value: dict):
#         if not isinstance(value, dict):
#             return False
#
#         for k, v in value.items():
#             if isinstance(v, dict):
#                 if ObjectContainsSubset(value=self.value).verify(v):
#                     return True
#                 elif self.verify(v):
#                     return True
#             if isinstance(v, list):
#                 for item in v:
#                     if isinstance(item, dict) and self.verify(item):
#                         return True
#         return False
#
#     def __invert__(self):
#         return NesteObjectNotContainsSubset(value=self.value, max_depth=self.max_depth)
#
#     @property
#     def predicate_types(self) -> set[PredicateType]:
#         return {PredicateType.Array, PredicateType.Object}
#
#     def calculate_limitations(self) -> PredicateLimitations:
#         limitation = PredicateLimitations(
#             level_gte=0,
#             level_lte=None,
#         )
#
#         for item in self.value.keys():
#             limitation.push(item.calculate_limitations().increment_level(reset_level_lte=True))
#         for item in self.value.values():
#             limitation.push(item.calculate_limitations().increment_level(reset_level_lte=True))
#
#         limitation.max_nesting_level += _DEFAULT_NESTED_PREDICATES_EXTRA_NESTING
#         return limitation
#
#     def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
#         main_predicate = ObjectContainsSubset(value=self.value)
#         constraints = []
#         initial_level = ctx.json_type_variable.level
#         ctx.get_variable(PredicateType.Object)
#
#         for sub_level in range(self.max_depth):
#             child_ctx = ctx.create_child_context()
#
#             object_iterator = z3.String(f'iter_obj_{uuid4()}')
#             array_iterator = z3.Int(f'iter_arr_{uuid4()}')
#             if sub_level < self.max_depth - 1 and ctx.get_limitations().max_nesting_level >= sub_level + initial_level:
#                 array_var = ctx.get_variable(PredicateType.Array)
#                 object_var = ctx.get_variable(PredicateType.Object)
#                 constraints.append(
#                     z3.Or(
#                         main_predicate.to_z3(ctx),
#                         z3.And(
#                             array_var[array_iterator] == child_ctx.json_type_variable.z3_variable,
#                             ctx.json_type_variable.is_array(),
#                             array_iterator < z3.Length(array_var),
#                             array_iterator >= 0,
#                         ),
#                         z3.And(
#                             object_var[object_iterator] == child_ctx.json_type_variable.z3_variable,
#                             ctx.json_type_variable.is_object(),
#                         ),
#                     )
#                 )
#             else:
#                 constraints.append(main_predicate.to_z3(ctx))
#             ctx = child_ctx
#
#         return z3.And(*constraints)
#
#
# class NesteObjectNotContainsSubset(BaseObjectPredicate):
#     type_of: Literal['NesteObjectNotContainsSubset'] = 'NesteObjectNotContainsSubset'
#     max_depth: int = 10
#
#     def verify(self, value: dict):
#         if not isinstance(value, dict):
#             return False
#
#         for k, v in value.items():
#             if isinstance(v, dict):
#                 if not ObjectNotContainsSubset(value=self.value).verify(v):
#                     return False
#                 elif not self.verify(v):
#                     return False
#             if isinstance(v, list):
#                 for item in v:
#                     if isinstance(item, dict) and not self.verify(item):
#                         return False
#         return True
#
#     def __invert__(self):
#         return NestedObjectContainsSubset(value=self.value, max_depth=self.max_depth)
#
#     @property
#     def predicate_types(self) -> set[PredicateType]:
#         return {PredicateType.Array, PredicateType.Object}
#
#     def calculate_limitations(self) -> PredicateLimitations:
#         limitation = PredicateLimitations(
#             level_gte=0,
#             level_lte=None,
#         )
#
#         for item in self.value.keys():
#             limitation.push(item.calculate_limitations().increment_level(reset_level_lte=True))
#         for item in self.value.values():
#             limitation.push(item.calculate_limitations().increment_level(reset_level_lte=True))
#
#         limitation.max_nesting_level += _DEFAULT_NESTED_PREDICATES_EXTRA_NESTING
#         return limitation
#
#     def build_nested_for_all(self, ctx: VariableContext, cur_obj, level=0, recursion_level=0, start_level=0):
#         dts = JsonDatatype._Z3_JSON_DATATYPES
#
#         object_iterator = z3.String(f'iter_obj_{uuid4()}')
#         array_iterator = z3.Int(f'iter_arr_{uuid4()}')
#
#         nested_object_expression = z3.BoolVal(True)
#         nested_array_expression = z3.BoolVal(True)
#         if (
#             recursion_level < self.max_depth
#             and level < JsonDatatype.MAX_NESTING_LEVEL - 1
#             and ctx.get_limitations().max_nesting_level >= level
#         ):
#             child_context = ctx.create_child_context()
#             nested_object_expression = z3.ForAll(
#                 [object_iterator],
#                 self.build_nested_for_all(
#                     ctx=child_context,
#                     cur_obj=dts[level].get_object(cur_obj)[object_iterator],
#                     level=level + 1,
#                     recursion_level=recursion_level + 1,
#                     start_level=start_level,
#                 ),
#             )
#             nested_array_expression = z3.ForAll(
#                 [array_iterator],
#                 z3.Implies(
#                     z3.And(array_iterator >= 0, array_iterator < z3.Length(dts[level].get_array(cur_obj))),
#                     self.build_nested_for_all(
#                         ctx=child_context,
#                         cur_obj=dts[level].get_array(cur_obj)[array_iterator],
#                         level=level + 1,
#                         recursion_level=recursion_level + 1,
#                         start_level=start_level,
#                     ),
#                 ),
#             )
#
#         sub_predicate_expression = z3.BoolVal(True)
#         if start_level <= level:
#             sibling_ctx = ctx.create_sibling_context()
#             sub_predicate_expression = z3.And(
#                 ObjectNotContainsSubset(value=self.value).to_z3(sibling_ctx),
#                 sibling_ctx.json_type_variable.z3_variable == cur_obj,
#                 sibling_ctx.pop_from_global_constraints(),
#             )
#
#         return z3.And(
#             *[
#                 z3.Implies(
#                     dts[level].is_object(cur_obj),
#                     z3.And(
#                         sub_predicate_expression,
#                         nested_object_expression,
#                     ),
#                 ),
#                 z3.Implies(
#                     dts[level].is_array(cur_obj),
#                     nested_array_expression,
#                 ),
#             ]
#         )
#
#     def to_z3(self, ctx: VariableContext) -> z3.ExprRef:
#         return self.build_nested_for_all(
#             ctx=ctx,
#             cur_obj=ctx.json_type_variable.z3_variable,
#             start_level=ctx.json_type_variable.level,
#             level=ctx.json_type_variable.level,
#         )
